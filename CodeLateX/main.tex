\documentclass[hidelinks,letterpaper,12pt]{article}
\pagestyle{plain}
%====================================================================
% Tables des dessins des étapes Shift method
\usepackage{tabularx}
%====================================================================
% ceentre les images des experementation : 
\usepackage{pgfplots}
%dessiner table
\usepackage{multirow}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
%\pgfplotsset{width=15cm,compat=1.9}
%================== code java =======================
% https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted
\usepackage{listings}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\lstset{language=Java,
frame=single,
numbers=left,
captionpos=b,
breaklines=true,
showstringspaces=false
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
commentstyle=\color{pgreen},
keywordstyle=\color{pblue},
stringstyle=\color{pred},
basicstyle=\ttfamily,
%moredelim=[il][\textcolor{pgrey}]{$$},
moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}
%\lstset{
%    language=Java,
%    basicstyle=\ttfamily\small,
%    frame=single,
%    backgroundcolor=\color{lightgray},
%    numbers=left,
%    numberstyle=\tiny\color{gray},
%    captionpos=b,
%    breaklines=true,
%    showstringspaces=false
%}

%====================================================================
% Author-year citation in LaTeX
% source : http://merkel.texture.rocks/Latex/natbib.php
\usepackage[angle, comma, numbers, authoryear, colon]{natbib}

\usepackage{filecontents}
%====================================================================
% Ecrire en français source : https://fr.overleaf.com/learn/latex/French
% \usepackage[utf8]{inputenc} is no longer required (since 2018)
%Set the font (output) encoding
%--------------------------------------
\usepackage[T1]{fontenc} %Not needed by LuaLaTeX or XeLaTeX
%French-specific commands
%--------------------------------------
\usepackage[french]{babel}
\usepackage[autolanguage]{numprint} % for the \nombre command
%Hyphenation rules
%--------------------------------------
\usepackage{hyphenat}
\hyphenation{mate-mática recu-perar}
%--------------------------------------
%====================================================================

% pour les dessins 
\usepackage{tikz} 

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
%\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%====================================================================
%les maths 
%\usepackage{graphicx}
%\usepackage[colorlinks=true, allcolors=blue]{hyperref}
%\usepackage[pdfpagelabels, allcolors=blue, colorlinks=true]{hyperref}

\usepackage{hyperref}
\hypersetup{colorlinks=true,linkcolor=blue,urlcolor=blue,citecolor=blue,anchorcolor=blue}


\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsthm,amsmath}

% incrementation 
\newtheorem{prop}{Proposition}
\renewcommand{\qedsymbol}{$\blacktriangleright$}

%\newtheorem{theorem}{Theorem} %https://www.overleaf.com/learn/latex/Theorems_and_proofs
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

%====================================================================	
%Probleme : Unicode error in inputenc package
% https://tex.stackexchange.com/a/361070/256008
\DeclareUnicodeCharacter{2212}{-}
%====================================================================
% source : https://texnique.fr/osqa/questions/8826/numerotation-automatisee-delements-divers
% Compteur pour les n° de doc.
\newcounter{Exemple} % Appel avec \theExemple. Incrémentation avec \refstepcounter{Exemple} ou \stepcounter{Exemple}. Mettre un \label{} et rappeler la valeur de ce compteur ailleurs avec \ref{}
\setcounter{Exemple}{1} % ou \addtocounter{Exemple}{1}

%====================================================================
\usepackage{ulem} % Barré un text, Source : https://www.latex-fr.net/3_composition/texte/symboles/obtenir_des_caracteres_barres	
%====================================================================
%Photos : 
\usepackage{caption}  

%====================================================================
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\usetikzlibrary{pgfplots.fillbetween}
%====================================================================
%Gross Edge, source : https://tex.stackexchange.com/questions/132606/varying-edge-thickness	
%====================================================================
%Force figure placement in text
%Source : https://tex.stackexchange.com/a/8633/256008
\usepackage{float}
%====================================================================
% modulo , source : https://tex.stackexchange.com/questions/137073/writing-mod-in-congruence-problems-without-leading-space
%\newcommand{\Mod}[1]{\ (\mathrm{mod}\ #1)}
%====================================================================
% Solid black box in the proof environment
\renewcommand{\qedsymbol}{$\blacksquare$}
%====================================================================
% le dessin des graphes basé sur ce code trouvé dans : 
% % Source : https://www.baeldung.com/cs/latex-drawing-graphs 
% https://tex.stackexchange.com/questions/270543/draw-a-graph-in-latex-with-tikz
% https://tex.stackexchange.com/questions/315456/colouring-graphs-tikz	
%====================================================================
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
%====================================================================
\usetikzlibrary{graphs, graphs.standard}

%====================================================================
%===============================================================
%\normalem %%%% disable auto underline source : https://tex.stackexchange.com/questions/204064/conditions-in-algorithms-are-underlined
%\newcommand{\mycomment}[1]{}
%\mycomment{}
% https://tex.stackexchange.com/questions/87303/multi-line-block-comments-in-latex
%information supplementaire sur l'algorithme : 
%--------------------------------------------
%====================================================================
%====================================================================
%\usepackage[normalem]{ulem}
%\usepackage{algorithm}    % http://ctan.org/pkg/algorithm
\usepackage{algpseudocode} % http://ctan.org/pkg/algorithmicx

% source 1 : https://shantoroy.com/latex/how-to-write--in-latex/
\usepackage{xcolor}
\usepackage[linesnumbered,ruled,vlined,boxed]{algorithm2e}
%\usepackage[lined,algonl,boxed]{algorithm2e}
%%% Coloring the comment as blue 
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
\SetKwInput{KwInput}{Entrée}               % Set the Input
\SetKwInput{KwOutput}{Sortie}              % set the Output
% Traduction des algorithmes inspiré de : 
% https://mlg.ulb.ac.be/files/algorithm2e.pdf
\SetKw{Return}{retourner}
\SetKwComment{tcc}{/*}{*/}
\SetKwComment{tcp}{//}{}
\SetKwBlock{Begin}{Début}{Fin}
\SetKwFor{For}{Pour}{faire}{Fin pour}
\SetKwRepeat{Repeat}{Répéter}{jusqu'à}
\SetKwFor{While}{Tant que}{faire}{Fin tant que}
\SetKwIF{If}{ElseIf}{Else}{Si}{Alors}{Sinon Si}{Sinon}{Fin si}

%====================================================================

%\usepackage{calligra} % for dedication

%====================================================================
%====================================================================

\title{Représentation "Straight line" d'un graphe planaire par l'algorithme Shift method}

%====================================================================
%                           Début 
%====================================================================		

\begin{document}

%\pagenumbering{Alph}  %%%%
%====================================================================
%                           Page de garde 
% Source : https://fr.overleaf.com/latex/templates/masterthesisumons-latex/jwgczwyqzsyv
%====================================================================		
\begin{titlepage}
%\vspace*{0.3cm}
\begin{center}
\textnormal{\Large{Universit\'e de Mons}}\\[0.3em]
\textnormal{\Large{Facult\'e des Sciences}}\\[0.3em]
\textnormal{\Large{D\'epartement d'Informatique}}\\[0.3em]
%\textnormal{\Large{NOM DU SERVICE (optionnel)}}
\end{center}
\vspace*{1cm}
\begin{center}
\fbox{
\begin{minipage}{16cm}
\center
\vspace*{0.5cm}\textbf{\LARGE{Représentation "Straight line"}}\\[0.5em]
\textbf{\LARGE{d'un graphe planaire}}\vspace*{0.5em}\\
\textbf{\LARGE{par l'algorithme Shift method}}\vspace*{0.5cm}
\end{minipage}
}
\end{center}
\vspace*{1cm}

\large{
\begin{center}
\begin{tabular*}{16.7cm}{@{\extracolsep{\fill}}lr}
Directeur : M\textsuperscript{r} Jef \textsc{WIJSEN} & M\'emoire r\'ealis\'e par\\
& Youness \textsc{Kazzoul}\\[1em]
%Rapporteurs : 
%M\textsuperscript{r} Pr\'enom \textsc{NOM} 
%& en vue de l'obtention du grade de\\
%\hspace{26.4mm}M\textsuperscript{r} 
%Pr\'enom \textsc{Nom} 
%& Master en Sciences Informatiques
\end{tabular*}
\end{center}}
 En vue de l'obtention du grade de Master en Sciences Informatiques

\vspace*{4cm}
\begin{center}
\includegraphics[height=2cm]{images/UMONS-Logo.jpg}
\hspace{4cm}
\includegraphics[height=1.7cm]{images/FS-logo.jpg}
\\[1em]
Ann\'ee acad\'emique 2022-2023
\end{center}

\thispagestyle{empty}
\end{titlepage}


\newpage
\thispagestyle{empty}
\mbox{}
\newpage
%====================================================================
%                           Dédicace 
%====================================================================	
 \section{Dédicace}
 \thispagestyle{empty} %
 Je dédie ce travail à ma famille, qui a toujours été mon soutien et mon inspiration tout au long de mes études. Leur amour inconditionnel et leurs encouragements constants m'ont permis d'atteindre mes objectifs. Je tiens également à remercier mes amis et mes proches pour leur soutien et leur motivation. Ce travail est dédié à tous ceux qui ont cru en moi et ont été présents à chaque étape de mon parcours académique.
 \addtocounter{page}{-1}% Reduce page number by 1
 \newpage
	
%====================================================================
%                           Remerciements 
%====================================================================	
	\section{Remerciements}
	\thispagestyle{empty}
 Tous mes sincères remerciements à mon directeur de mémoire, Jef WIJSEN, pour sa précieuse guidance, son soutien continu et ses conseils avisés tout au long de la réalisation de ce travail. Sa vision, son expertise et son dévouement ont été essentiels pour mener à bien cette recherche.
\\ \\
Je souhaite également exprimer ma gratitude envers mes professeurs pour leurs enseignements de qualité, leur encadrement et leur disponibilité. Leur expertise et leur soutien ont grandement contribué à mon parcours académique et ont été essentiels à la réussite de ce mémoire.
\\ \\
Enfin, je tiens à exprimer ma reconnaissance envers toutes les personnes qui ont participé de près ou de loin à ce travail et qui ont contribué à son aboutissement.

	\addtocounter{page}{-1}% Reduce page number by 1
	\newpage

%====================================================================
%                           Contenu du travail de fin d'étude 
%====================================================================	
	\section{Contenu du travail de fin d'étude}
	\thispagestyle{empty}
Ce travail de fin d'étude existe en deux parties : 
\begin{enumerate}
    \item Le présent document qui décrit un algorithme pour dessiner un graphe planaire (le code \LaTeX est sur le Github).
    \item L'implémentation de cet algorithme qu'est disponible sur GitHub à
l’adresse suivante :  \url{https://github.com/Kazzoul-Youness/StraightLine-ShiftMethod}.
\end{enumerate}
	\addtocounter{page}{-1}% Reduce page number by 1
	\newpage
	
%====================================================================
%                           Sommaire 
%====================================================================		
% Best way to remove page numbers for tableofcontents pages and title page. 
% Source : https://tex.stackexchange.com/a/41558/256008
\cleardoublepage
\pagenumbering{gobble}	
\tableofcontents		
%	\listoffigures	
\cleardoublepage
\pagenumbering{arabic}

\newpage
\thispagestyle{empty}
\mbox{}
\newpage

%====================================================================
%                           Résumé 
%====================================================================		
%	\vspace{2cm} %Add a 2cm space

\begin{abstract}
\label{abstract}
La représentation en ligne droite des graphes planaires joue un rôle essentiel dans de nombreux domaines tels que les sciences humaines, la médecine, la topologie, l'informatique et bien d'autres encore. L'algorithme de Shift method, développé par Fraysseix, Pach et Pollack, offre une approche efficace pour créer des représentations visuelles claires et ordonnées de ces graphes. Cependant, cette méthode n'a pas été suffisamment étudiée et ses implications restent peu explorées.
\\
Dans cette étude, l'accent est mis sur une exploration détaillée de la Shift method et de son utilisation pour représenter des graphes planaires en ligne droite. L'ordre canonique des sommets, qui joue un rôle crucial dans l'algorithme, est introduit et appliqué pour générer des représentations en ligne droite qui préservent la structure et la connectivité du graphe d'origine.
\\
Les étapes clés de l'algorithme de Shift method sont décrites, mettant en évidence les techniques utilisées pour organiser les sommets de manière linéaire et créer des tracés optimaux. Les avantages et les limites de cette méthode sont discutés, en soulignant ses applications pratiques dans la visualisation et l'analyse de graphes planaires.
\\ 
Cette étude approfondie de la méthode Shift method vise à améliorer notre compréhension de la représentation en ligne droite des graphes planaires. En mettant en évidence ses fondements théoriques et ses techniques pratiques, elle ouvre de nouvelles perspectives intéressantes pour la visualisation et l'analyse de ces graphes dans divers domaines d'application. Nous espérons que ce travail encouragera la poursuite des recherches dans ce domaine et favorisera l'adoption de l'algorithme de Shift method en tant qu'outil essentiel pour la représentation en ligne droite des graphes planaires.
\end{abstract}
\newpage
%====================================================================
%                           État de l'art 
%===================================================================		
\section{État de l'art} 
Le but derrière les dessins en ligne droite des graphes planaires est de bien représenter la visibilité des données avec les liens ou les relations de façon lucide et déterminée. Les graphes planaires sont généralement utilisés dans divers domaines, quasiment toutes les sciences humains, politiques, médecines, la topologie, géométrie combinatoire…,
\\
En utilisant des lignes droites pour relier les points de données, il est possible de créer des représentations visuelles telles que les cartes de transport (métro, routier, ferroviaire, maritime et aérien), ainsi que des graphiques représentant des processus métaboliques, atomiques, et autres. Ces schémas permettent d'analyser le dynamisme et l'efficacité des modèles étudiés, ou de mettre en évidence des incohérences dans les données. Cette compréhension approfondie est cruciale pour aborder les problèmes de manière adéquate, prendre des décisions éclairées et résoudre des situations complexes.\\ \\ 
Pour créer une représentation en ligne droite d'un graphe planaire, diverses méthodes existent. Atteindre une qualité optimale, c'est-à-dire la meilleure représentation possible qui soit claire, précise, facile à comprendre, et sans chevauchements ni enchevêtrements de lignes, nécessite le respect de certaines conditions. Des algorithmes permettent de réaliser ces représentations en temps linéaire en utilisant la méthode de shift, tout en assurant la qualité optimale en respectant les conditions énoncées \citep{PhilippKindermann}. La méthode de shift, développée par de Fraysseix, Pach et Pollack  \citep{FraysseixPachPollack}, est une approche efficace pour construire des dessins planaires en ligne droite sur grille, où les arêtes ont des coordonnées entières. Elle permet de créer des représentations de graphes planaires avec une hauteur $\theta(n)$\footnote{La complexité temporelle de la méthode de shift utilisée pour créer les représentations de graphes planaires est $\theta(n)$. Cela signifie que la hauteur, la largeur et la superficie de ces représentations augmentent proportionnellement au nombre de sommets du graphe. En d'autres termes, plus le nombre de sommets augmente, plus ces mesures augmentent de manière linéaire. Ainsi, $\theta(n)$ indique que la croissance des mesures de taille et de la complexité temporelle est linéaire par rapport au nombre de sommets du graphe planaire.} et une largeur $\theta(n)$ , ce qui résulte en une superficie de $\theta(n^2)$ . La complexité temporelle de cette méthode est linéaire, c'est-à-dire $\theta(n)$ , où $n$ représente le nombre de sommets du graphe planaire. L'algorithme de la méthode de shift se concentre sur la création de représentations de graphes planaires qui sont visuellement claires et faciles à comprendre, tout en évitant les chevauchements et les enchevêtrements de lignes \citep{VismaraTamassia}.
\\ \\
L'algorithme de shift method est particulièrement utile pour les applications pratiques, car il permet d'obtenir des dessins de graphes planaires de manière efficace et avec une superficie minimale. Cette méthode utilise une approche itérative pour déterminer la position des nœuds du graphe sur un axe horizontal, en utilisant une technique de décalage pour résoudre les conflits entre les nœuds. Il est important de noter que les améliorations apportées à l'algorithme de shift method ont permis de résoudre certains problèmes liés à la représentation en ligne droite des graphes planaires. En particulier, la surface minimale nécessaire pour obtenir un dessin en ligne droite est un élément crucial pour la visualisation et l'analyse des relations entre les nœuds du graphe \citep{TakaoSaidur}.
\\ \\
Plusieurs améliorations et variantes de l'algorithme de shift method ont été proposées dans la littérature, permettant de réduire la surface minimale nécessaire pour obtenir un dessin en ligne droite tout en maintenant un temps de calcul linéaire en $\theta(n)$ . Ces avancées ont renforcé la position de l'algorithme de shift method comme l'une des méthodes les plus efficaces pour obtenir des représentations en ligne droite de graphes planaires. En conclusion, la méthode de shift et ses améliorations successives offrent des solutions performantes pour la visualisation et l'analyse de graphes planaires dans diverses applications pratiques \citep{PhilippKindermann}.

%====================================================================
%                           Introduction 
%===================================================================
\newpage
\section{Introduction}
\label{Introduction}
Les graphes planaires occupent une place centrale dans diverses disciplines allant des mathématiques à l'informatique, avec une portée qui s'étend bien au-delà. Que ce soit pour l'optimisation des réseaux, la modélisation des structures chimiques, la conception de circuits imprimés, ressources humains, la cartographie et la planification urbaine, voire l'étude des métabolismes humains en médecine, les graphes planaires sont omniprésents. Ils représentent une manière élégante et efficace de décrire des relations complexes. Leur dessin, en particulier lorsqu'il est réalisé en ligne droite sans croisement d'arêtes, est non seulement esthétiquement plaisant, mais aussi d'une grande utilité pratique. C'est cette richesse d'applications et ce défi de création qui m'ont poussé à choisir le sujet des graphes planaires pour mon travail de recherche. Plus précisément, l'objectif de ce mémoire est d'étudier et d'implémenter la méthode de décalage, ou \textbf{Shift method}, pour \textbf{la représentation en ligne droite des graphes planaires}, tout en soulignant leur importance fondamentale dans une multitude de domaines. Un dessin en ligne droite d'un graphe planaire est un dessin dans lequel chaque arête est dessinée comme un segment de ligne droite sans croisement d'arêtes, comme illustré à la figure suivante : 
\begin{figure}[H]
\centering
\begin{tikzpicture}
	\path
	(0,0) coordinate (a)
	(9,0) coordinate (b)
	(5,1) coordinate (c)
	(3,2) coordinate (d)
	(7,2) coordinate (e)
	(3,4) coordinate (f)
	(5,5) coordinate (g)
	(5,8) coordinate (h) ;
	%========  dessins des Arêtes =================			
	\draw (a)--(c)--(b)--(a);
	\draw (a)--(h)--(b);
	\draw (a)--(d)--(c);
	\draw (a)--(f)--(c);
	\draw (d)--(f)--(h)--(e);
	\draw (g)--(f)--(e)--(c);
	\draw (h)--(g)--(e)--(b);
	
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=black,inner sep = 3pt]
	\node[vertex] [label = left : ] at (a) {};
	\node[vertex] [label = right: ] at (b) {};
	\node[vertex] [label = right: ] at (c) {};
	\node[vertex] [label = right: ] at (d) {};
	\node[vertex] [label = right: ] at (e) {};
	\node[vertex] [label = right: ] at (f) {};
	\node[vertex] [label = right: ] at (g) {};
	\node[vertex] [label = right: ] at (h) {};
\end{tikzpicture}
\captionof{figure}{Dessin en ligne droite d'un graphe planaire}
\label{Dessin en ligne droite d'un graphe planaire}	
\end{figure}
Wagner \citep{Wagner}, Fary \citep{Fary} et Stein \citep{Stein} ont indépendamment prouvé que tout graphe planaire $G$ possède un dessin en ligne droite. Leurs preuves donnent immédiatement des algorithmes en temps polynomial pour trouver un dessin en ligne droite d'un graphe planaire donné. Cependant, l'air d'un rectangle entourant un dessin sur une grille d'entiers obtenu par ces algorithmes n'est pas limitée par un polynôme dans le nombre de$n$sommets de G. En fait, l'obtention d'un dessin dont l'aire est limitée par un polynôme est restée un problème ouvert pendant longtemps. En 1990, de Fraysseix et al \citep{FraysseixPachPollack}. et Schnyder \citep{Schnyder} ont montré par deux méthodes différentes que tout graphe planaire de $n > 3$ sommets possède un dessin en ligne droite sur une grille d'entiers de taille \( (2n-4) \times (n-2) \) et \( (n-2) \times (n-2) \), respectivement\citep{TakaoSaidur}. Les deux méthodes peuvent être mises en œuvre sous forme d'algorithmes en temps linéaire, et sont bien connues sous le nom de  "\textbf{Shift method}" et la "\textbf{realizer method}", respectivement. 
\\ \\
Dans ce travail on va voir la Shift method ou méthode de décalage à la section 8 \citep{TakaoSaidur}. De Fraysseix et al. ont montré que, pour chaque $n > 3$, il existe un graphe planair de$n$sommets, \textit{e.g.,} des triangles imbriqués, qui nécessite une grille de taille au moins égale à \( \frac{2}{3}(n-1) \times  \frac{2}{3}(n-1) \) pour tout tracé de grille \citep{ChrobakNakano} \citep{FraysseixPachPollack}. Il a été conjecturé que tout graphe plan de$n$sommets possède un dessin sur une grille de \( \frac{2}{3}(n) \times  \frac{2}{3}(n) \)
, mais il s'agit encore d'un problème ouvert. D'autre part, une classe restreinte de graphes possède une grille plus compacte. \textit{e.g.,}, si $G$ est un graphe plan à 4 connexions, alors $G$ a un dessin de grille plus compact\citep{TakaoSaidur}. 
\\ \\	
À la section 11 nous décrivons une preuve constructive du théorème de de Fraysseix et al \citep{FraysseixPachPollack} selon lequel tout graphe plan $G$ de $n > 3$ sommets possède une grille de lignes droites de taille \( (2n-4) \times (n-2) \), et nous présentons une implémentation en temps linéaire d'un algorithme permettant de trouver un tel dessin \citep{ChrobakPayne}. Si $G$ n'est pas triangulé, nous obtenons un graphe plan triangulé G' à partir de $G$ en ajoutant des arêtes fictives à G. À partir d'un dessin de grille de lignes droites de G', nous pouvons immédiatement obtenir un dessin de grille de lignes droites de $G$ en supprimant les arêtes fictives. Par conséquent, il suffit de prouver qu'un graphe plan triangulé $G$ de$n$sommets possède une grille de lignes droites de taille \(  (2n-4) \times (n-2) \). Pour construire un tel dessin, de Fraysseix et al. ont introduit un ordre des sommets appelé "\textbf{ordre canonique}" et ont installé les sommets un par un dans le dessin en fonction de l'ordre \citep{TakaoSaidur}.
\\ \\
Dans la section 7 nous présentons un ordre canonique, dans la section 9 nous appliquons Shift method, et dans la section 10 nous allons voir l'algorithme Shift method. Nous nous présentons une implémentation en langage Java de l'algorithme dans la section 12. 	

\newpage
\section{Motivation}
Les graphes planaires ont de nombreuses applications pratiques dans divers domaines tels que l'informatique, les mathématiques, la physique, la biologie, etc. Voici quelques exemples d'utilité des graphes planaires :
\bigbreak  
\begin{itemize}
\item[$\blacktriangleright$] \textbf{Algorithmes} : Les graphes planaires sont utilisés dans la conception d'algorithmes pour résoudre divers problèmes tels que la recherche de chemins les plus courts, la coloration de graphes, la planification de tournées, peuvent tous être appliqués à des graphes planaires.
\\			
\item[$\blacktriangleright$] \textbf{Conception de circuits imprimés} : Les graphes planaires sont utilisés pour modéliser la disposition des composants électroniques et les connexions entre eux dans la conception de circuits imprimés \citep{Freeman}. Les composants peuvent être représentés par des sommets et les connexions par des arêtes.
\\			
\item[$\blacktriangleright$] \textbf{Cartographie et planification urbaine} : Les graphes planaires sont utilisés pour représenter les réseaux de transport, les plans de ville et les cartes routières, ce qui permet de visualiser les connexions et les distances entre les différents points d'intérêt \citep{BattistaTamassia}. 			
\\		
\item[$\blacktriangleright$] \textbf{Modélisation moléculaire} : Les graphes planaires sont utilisés pour modéliser la structure moléculaire des composés chimiques, où les nœuds représentent les atomes et les arêtes représentent les liaisons entre les atomes 
\citep{TodeschiniConsonni}.		
\\						
\item[$\blacktriangleright$] \textbf{Réseaux informatiques} : Les graphes planaires sont utilisés pour modéliser les réseaux de communication, ce qui permet de visualiser les connexions entre les différents nœuds et de trouver les chemins les plus courts pour acheminer les données \citep{Wang}. 			
\\		
\item[$\blacktriangleright$] \textbf{Reconnaissance de formes} : Les graphes planaires sont utilisés pour représenter des données dans des domaines tels que la reconnaissance de formes et l'analyse d'image \citep{BalakrishnanRanganathan}...\textit{etc}


\end{itemize}
\bigbreak  
En résumé, les graphes planaires sont des outils utiles pour modéliser et résoudre des problèmes dans de nombreux domaines, car ils permettent de représenter visuellement les connexions et les relations entre les différents éléments d'un système.
\thispagestyle{empty}


%====================== Terminologie=======================================
\newpage
\section{Terminologie}
\subsection{Graphe}
\label{Graphe}
Un graphe est une structure mathématique qui représente deux ensembles : un ensemble de points appelés \textbf{sommets} ou \textbf{nœuds}, et un ensemble d'\textbf{arêtes}. Les arêtes représentent des relations qui relient certains ou tous ces sommets entre eux. \textit{e.g.,}, dans le cas des réseaux sociaux, une arête peut indiquer qu'il y a une relation d'amitié entre deux personnes. Si aucune arête n'existe entre deux sommets, cela signifie qu'il n'y a pas de relation entre eux.
\\ \\
Ces relations peuvent également représenter des liens entre des atomes, des objets, des entités ou des événements, entre autres. Les graphes sont utilisés dans de nombreux domaines tels que les mathématiques, l'informatique, les sciences humaines, sociales, médicales, électroniques et bien d'autres.
\\ \\
Un graphe est défini comme un ensemble de sommets et d'arêtes. En notant $V$ l'ensemble des sommets et $E$ l'ensemble des arêtes, un graphe $G$ peut donc s'écrire sous la forme :
\begin{quote}
\( G = (V, E) \), où chaque élément de $E$ est une paire de \( \{ v_1, v_2 \} \) avec \( v_1 \neq v_2 \) et \( v_1, v_2 \in V \).
\end{quote}

%=======================    Sommet  =====================================
\subsection{Sommet}
\label{Sommets}		
Un ensemble appelés noeuds ou sommets sont les éléments du graphe, dans notre exemple figure \ref{Graphe sans arêtes, nommé stable} A, B et C sont les sommets de ce graphe.
\\
\begin{figure}[H]
\centering
\begin{tikzpicture}
	\path
	(0,0) coordinate (A)
	(4,0) coordinate (B)
	(2.7,2) coordinate (C);			
	%========  dessins des Arêtes =================			
	%\draw[thick,black] (A)--(C);		
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : A] at (A) {};
	\node[vertex] [label = right: B] at (B) {};
	\node[vertex] [label = right: C] at (C) {};
\end{tikzpicture}
\captionof{figure}{Graphe sans arêtes, nommé stable} %\includegraphics{images/image1.png}
\label{Graphe sans arêtes, nommé stable}	
\end{figure}

%=======================    Arête  =====================================
\subsection{Arête}
\label{Arêtes}
Un ensemble d'arêtes représente les relations entre certains des sommets d'un graphe \citep{ChristianLaforest}. Ces relations peuvent prendre la forme de segments de droites ou de \textbf{courbes simples}, comme illustré dans la figure \ref{Graphe avec une courbe simple}. Le dessin d'un graphe n'est rien d'autre que la représentation visuelle de ces relations entre les différents éléments du graphe.

\begin{figure}[H]
\centering
\begin{tikzpicture}
	\path
	(0,0) coordinate (A)
	(4,0.5) coordinate (B)
	(7,0.5) coordinate (C)
	(0.5,1.8) coordinate (D);	
	%========  dessins des Arêtes =================			
	\draw[thick,black] (A)--(D);
	\draw (A) to[bend left=50] (C); 
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : A] at (A) {};
	\node[vertex] [label = right: B] at (B) {};
	\node[vertex] [label = right: C] at (C) {};
	\node[vertex] [label = left: D] at (D) {};
\end{tikzpicture} 
%\includegraphics{images/image2.png}
\captionof{figure}{Graphe avec une courbe simple} %\includegraphics{images/image1.png}
\label{Graphe avec une courbe simple}	
\end{figure}
%=======================    Courbe simple  =====================================
\subsection{Courbe simple}
\label{Courbe simple}
Par courbe simple, on entend un tracé continu sans point double. Des arêtes peuvent se croiser, un sommet n'étant pas indiqué à l'intersection. Mais cela peut être ambigu si le graphe a une allure "exotique" comme la figure \ref{Exemple d'un graphe licite}, l'arête (1,6) coupe l'arête (1,4) par trois fois. 
\\ \\
%=================================================================================
%	Exemple des exemple qui s'incremente ! tres utile
%=================================================================================	
\textbf{Exemple \theExemple \refstepcounter{Exemple}}
\\
\begin{figure}[H]
\centering
\begin{tikzpicture}
	\path
	(0,0) coordinate (1)
	(3,0) coordinate (2)
	(3,3) coordinate (3)
	(0,3) coordinate (4)
	(1.5,1.5) coordinate (5);
	%========  dessins des Arêtes =================			
	\draw[thick,black] (2)--(3)--(4)--(1)--(2);
	\draw[thick,black] (1)--(5)--(2);
	\draw[thick,black] (4)--(5)--(3);		
	
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : 1] at (1) {};
	\node[vertex] [label = right: 2] at (2) {};
	\node[vertex] [label = right: 3] at (3) {};
	\node[vertex] [label = left : 4] at (4) {};
	\node[vertex] [label = left : 5] at (5) {};
\end{tikzpicture}
\captionof{figure}{Exemple d'un graphe licite} %\includegraphics{images/image1.png}
\label{Exemple d'un graphe licite}	
\end{figure}
\bigbreak	
\begin{figure}[H]
\centering	
\begin{tikzpicture}
	\path
	(0,0) coordinate (1)
	%	(3,-2) coordinate (2)
	%	(3,0) coordinate (3)
	(5,0) coordinate (4)
	(-2,3) coordinate (5)
	(3,3) coordinate (6)
	%(2,4) coordinate (7)
	(4,4) coordinate (8)
	;
	%========  dessins des Arêtes =================			
	%\draw[thick,black] (2)--(3)--(4)--(1)--(2);
	%\draw[thick,black] (1)--(5)--(3);
	\draw[thick,black] (1)--(8);
	\draw[thick,black] (5)--(6)--(4);
	%\draw[thick,black] (1)--(3)--(4);
	\draw[thick,black] (1)--(5)--(8)--(4);
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : 1] at (1) {};
	%	\node[vertex] [label = right: 2] at (2) {};
	%	\node[vertex] [label = right: 3] at (3) {};
	\node[vertex] [label = right : 4] at (4) {};
	\node[vertex] [label = left : 5] at (5) {};
	\node[vertex] [label = right : 6] at (6) {};
	%	\node[vertex] [label = left : 7] at (7) {};
	\node[vertex] [label = right : 8] at (8) {};
	
	\draw (0,0) ..controls (2,3) and (-4,2)..(3,1)
	..controls (4,3) and (-2,3)..(5,0);	
	%\draw (2,0) arc (0:-300:5mm);
	%\draw (0,0) arc (0:270:8mm);
	%\draw (0,0) arc (0:315:1.75cm and 1cm);
\end{tikzpicture}
\captionof{figure}{Exemple d'un graphe illicite, avec une arête (1,4) illégale} %\includegraphics{images/image1.png}
\label{Exemple d'un graphe illicite, avec une arête (1,4) illégale}	
\end{figure}
%\includegraphics{images/image3.png}
\bigbreak

Le premier graphe \ref{Exemple d'un graphe licite} entrain une situation licites, mais le deuxième une situation illicites, car l'arête (1,4) possède deux points doubles, c'est illégal! \citep{ChristianLaforest}
\\ \\	
%\includegraphics{images/image4.png}
\textbf{Exemple \theExemple \refstepcounter{Exemple} \label{Courbe simple exemple 1}} 
\\ \\
Dans l'exemple suivant figure \ref{Exemple 1 d'un graphe avec courbe simple} on a les sommets : 1,2,3, et 4 et on a des arrêts : \( \{1,3\}, \{2,4\}, \{2,3\} \) et \( \{3,4\} \). 
%\includegraphics{images/image5.png}
\\
\begin{figure}[H]
\centering	
\begin{tikzpicture}
	\path
	(0,0) coordinate (1)
	(2,0) coordinate (2)
	(2,2) coordinate (3)
	(0,2) coordinate (4)		
	(1,1) coordinate (5);
	\tikzstyle{vertex} = [draw,circle,fill=orange!30!white,inner sep = 4pt]
	\node[vertex] [] at (5) {};
	%========  dessins des Arêtes =================			
	\draw[thick,black] (4)--(3)--(2);
	\draw[thick,black] (4)--(2);
	\draw[thick,black] (1)--(3);
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : 1] at (1) {};
	\node[vertex] [label = right: 2] at (2) {};
	\node[vertex] [label = below right: 3] at (3) {};
	\node[vertex] [label = left : 4] at (4) {};
\end{tikzpicture} 
\captionof{figure}{Exemple 1 d'un graphe avec courbe simple} %\includegraphics{images/image1.png}
\label{Exemple 1 d'un graphe avec courbe simple}	
\end{figure}    	
Et on peut le dessiner autrement, \textit{e.g.,} voir la figure \ref{Exemple 2 d'un graphe avec courbe simple} \citep{ChristianLaforest}.
\\ \\ 
\textbf{Exemple \theExemple \refstepcounter{Exemple} \label{Courbe simple exemple 2}}
\\ \\
%\includegraphics{images/image6.png}	
%\includegraphics{images/image7.png}	
Le dessin suivant représente le même graphe, mais avec les sommets positionnés d'une autre façon différente dans le plan. En conséquence, l'intersection entre les arêtes \{1,3\} et \{2,4\} n'est plus présente, comme le montre la figure suivante \ref{Exemple 2 d'un graphe avec courbe simple} \citep{ChristianLaforest}.
\begin{figure}[H]
\centering	
\begin{tikzpicture}
	\path
	(0,0) coordinate (4)
	(2,0) coordinate (2)
	(2,2) coordinate (3)
	(0,2) coordinate (1);
	
	%========  dessins des Arêtes =================			
	\draw[thick,black] (4)--(3)--(2);
	\draw[thick,black] (4)--(2);
	\draw[thick,black] (1)--(3);
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : 1] at (1) {};
	\node[vertex] [label = right: 2] at (2) {};
	\node[vertex] [label = below right: 3] at (3) {};
	\node[vertex] [label = left : 4] at (4) {};
\end{tikzpicture} 
\captionof{figure}{Exemple 2 d'un graphe avec courbe simple} %\includegraphics{images/image1.png}
\label{Exemple 2 d'un graphe avec courbe simple}	
\end{figure}  
Dans un graphe comme celui-ci, avec cette intersection entre les arêtes \{1,3\} et \{2,4\} l'essentiel est de bien déterminer qu'il y a effectivement les quatre arêtes qui sont représentées, que ce soit sur la figure \ref{Exemple 1 d'un graphe avec courbe simple} ou sur la figure \ref{Exemple 2 d'un graphe avec courbe simple}. Il est important que le dessin du graphe ne prête pas à confusion et qu'il n'y ait pas d'ambiguïté quant à la présence ou l'absence de certaines arêtes ou de certains sommets \citep{ChristianLaforest}.
\\ \\  
\textbf{Exemple \theExemple \refstepcounter{Exemple} \label{Courbe simple exemple 3}}
\\ \\
Ci-dessous une autre représentation graphique du même graphe, potentiellement plus originale, comme illustré dans la figure suivante \citep{ChristianLaforest}.
\begin{figure}[H]
\centering	
\begin{tikzpicture}
	\path
	(1,1.5) coordinate (1)
	(3,0) coordinate (2)
	(0,0) coordinate (3)
	(0,3) coordinate (4);
	
	%========  dessins des Arêtes =================			
	\draw[thick,black] (4)--(3)--(2);
	\draw[thick,black] (4) to[bend left=60] (2);
	\draw[thick,black] (3)to[bend right=50] (1);    
	
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : 1] at (1) {};
	\node[vertex] [label = right: 2] at (2) {};
	\node[vertex] [label = below right: 3] at (3) {};
	\node[vertex] [label = left : 4] at (4) {};
\end{tikzpicture} 
\captionof{figure}{Exemple 3 d'un graphe avec courbe simple} %\includegraphics{images/image1.png}
\label{Exemple 3 d'un graphe avec courbe simple}	
\end{figure}   		
%\includegraphics{images/image8.png} 
Il s'agit toujours du même graphe, même si les arêtes sont représentées de manière un peu plus tordue. Cela n'a pas d'importance, car ce qui compte avant tout, c'est de savoir quelles sont les relations entre les différents sommets, comme le montre la figure \ref{Exemple 3 d'un graphe avec courbe simple} \citep{ChristianLaforest}.
\bigbreak 
%=======================   Ordre   =====================================
\subsection{Ordre}
\label{Ordre}
L'ordre d'un graphe est défini comme étant le nombre de sommets qui le composent \citep{PortieMenyr}. La disposition spatiale des sommets ainsi que la forme des arêtes ne sont pas des paramètres pertinents pour le calcul de l'ordre d'un graphe.

%=======================   Voisin   =====================================	
\bigbreak  
\subsection{Voisin}
\label{Voisin}
À partir des deux notions de base vu avant: les \textbf{sommets} qui sont les éléments et les \textbf{arêtes} qui sont les relations, on va définir d’autres vocabulaires, qui seront bien utiles, sont les notions de \textbf{voisin} et de \textbf{degré}, \citep{ChristianLaforest}.
% source : https://tex.stackexchange.com/a/685168/256008
{\color{white}-}\\ % This line will now show in pdf and no error will be generated.
On dit qu'un sommet $A$ est un voisin d'un sommet $B$ dans un graphe si et seulement si les deux sommets sont reliés par une arête, notée $\{A,B\}$ ou $\{B,A\}$, conformément à la définition mathématique de la relation de voisinage entre deux sommets.
%=======================   Degré   =====================================	
\bigbreak
\subsection{Degré}
\label{Degré} 
Le degré d'un sommet $v$ dans un graphe $G$, noté $d_G(v)$, est défini comme étant le nombre d'arêtes de $G$ qui sont incidentes avec ce sommet. Autrement dit, le degré d'un sommet correspond simplement au nombre de ses voisins. Dans le cas particulier d'un graphe simple, le degré d'un sommet représente donc le nombre de voisins de ce sommet. Enfin, un sommet de degré zéro est appelé sommet isolé \citep{Bondy-Murty}. 
%\textbf{\underline{Source page 19 du livre : Traduction-Bondy-Murty.pdf}}
%\citep{Bondy-Murty}
%\includegraphics{images/image12.png}
\\
\textbf{Exemples}:
\begin{itemize}
\item[$\blacktriangleright$] \textbf{Exemple 2:}
{\color{white}-} % This line will now show in pdf and no error will be generated.
\begin{figure}[H]
	\centering		
	\begin{tikzpicture}
		\path
		(0,0) coordinate (C)
		(3,0) coordinate (F)
		(3,3) coordinate (D)
		(0,3) coordinate (A)
		(5,2.6) coordinate (B)
		(4.5,1) coordinate (E)
		;		
		%========  dessins des Arêtes =================			
		\draw[thick,black] (F)--(D)--(A)--(C)--(F);
		\draw[thick,black] (D)--(B)--(E);
		%========  posisionement des nom des sommets =================
		\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
		\node[vertex] [label = left : C] at (C) {};
		\node[vertex] [label = right: F] at (F) {};
		\node[vertex] [label = below right: D] at (D) {};
		\node[vertex] [label = left : A] at (A) {};
		\node[vertex] [label = right: B] at (B) {};
		\node[vertex] [label = left : E] at (E) {};
	\end{tikzpicture}
	\captionof{figure}{Exemple différents cas de voisinage} 
	\label{Exemple différents cas de voisinage}	
\end{figure}	
Sur le graphe de la figure \ref{Exemple différents cas de voisinage}, on dit que:
\begin{itemize}
	\item les voisins de A, sont D et C puisqu'il a une Arête AD et une arête AC;
	\\
	\item E et F ne sont pas voisins malgré le fait qu'ils sont proches sur le dessin, ils ne sont pas voisins parce qu'ils ne sont pas reliés par une arête; 
	\\
	\item E il a un seul voisin qu’est B, du coup son degré, c'est 1. \citep{Bondy-Murty};
	\\
	\item et puis un autre exemple sommet D est de degré 3, puisqu'il a trois voisins qui sont à B, F et A \citep{ChristianLaforest}.
\end{itemize}
\bigbreak 
\end{itemize}		
\bigbreak  
%=======================  Chaîne, longueur d’un chemin    =====================================
\subsection{Chaîne, longueur d’un chemin}
\label{Chaîne, longeur d’un chemin}    
\textbf{Une chaîne} : Dans un graphe, une chaîne est définie comme une suite d'arêtes consécutives, représentant une sorte de promenade le long du graphe. Elle est généralement identifiée par la liste ordonnée des sommets qu'elle relie. Le terme "chaîne" est couramment utilisé en théorie des graphes pour désigner ce type de parcours, bien que les termes "chemin" ou "parcours" soient également courants \citep{mehl}.	
\\ \\
Une \textbf{chaîne simple} est une \textbf{chaîne} qui ne passe pas deux fois par la même arête.
\\ \\
\textbf{\textit{e.g.,}}: Prenant deux sommets A et B dans ce graphe, et le chemin donc c'est une suite d'arêtes qui permet de relier A à B.
\\
La \textbf{longueur d’un chemin} est son nombre d’Arêtes.
\\ \\ 
\textbf{Exemple :}
\begin{figure}[ht]
\centering			
\begin{tikzpicture}
	\path
	(0,0)  coordinate (1)
	(3,0) coordinate (2)
	(0,2)  coordinate (3)
	(3,2)  coordinate (4)
	(0,4) coordinate (5)
	(3,4) coordinate (6) 
	(6,3.5)  coordinate (7)
	(5,1.5) coordinate (8)
	;				
	%========  dessins des Arêtes =================			
	\draw[thick,black] (1)--(2)--(8)--(7)--(6)--(5)--(3)--(4)--(1);
	\draw[thick,black] (5) -- (4);
	\draw[thick,black] (3) -- (6);
	\draw[thick,black] (6) -- (8);
	\draw[line width=3pt, color=green!50!black]  (3)--(5)--(6)--(7)--(8);
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : 1] at (1) {};
	\node[vertex] [label = right: 2] at (2) {};
	\node[vertex] [label = left: 3] at (3) {};
	\node[vertex] [label = right : 4] at (4) {};
	\node[vertex] [label = left: 5] at (5) {};
	\node[vertex] [label = below: 6] at (6) {};
	\node[vertex] [label = right: 7] at (7) {};
	\node[vertex] [label = right: 8] at (8) {};		
\end{tikzpicture}
\captionof{figure}{Exemple 1 d'un chemin de longueur 4} 
\label{Exemple 1 d'un chemin de longueur 4}	
\end{figure}	
\\
%\includegraphics{images/image14.png}
Le chemin vert représenté sur la figure \ref{Exemple 1 d'un chemin de longueur 4} est un exemple de chemin dans le graphe considéré, qui est composé de quatre arêtes consécutives. On dit alors que la longueur de ce chemin est égale à 4. Il est important de souligner que ce n'est pas le seul chemin existant dans le graphe : il existe en effet de nombreux autres chemins possibles, avec des longueurs allant de 3 à 8 arêtes.	
\bigbreak 
%=======================   Cycle, longeur d’un cycle   =====================================
\subsection{Cycle, longueur d’un cycle}
\label{Cycle, longeur d’un cycle}
Un cycle est un\textbf{ chemin/chaîne} dans les deux extrémités sont reliées [2], ou qui commence et se termine au même sommet. [4]
\\
Et la \textbf{longueur d’un cycle} est la somme des Arêtes, regardons des exemples: 
\\
\begin{itemize}
\item[$\blacktriangleright$] \textbf{Exemple:}
%\includegraphics{images/image16.png}
\begin{figure}[H]
	\centering		
	\begin{tikzpicture}
		\path
		(0,0)  coordinate (1)
		(3,0) coordinate (2)
		(0,2)  coordinate (3)
		(3,2)  coordinate (4)
		(0,4) coordinate (5)
		(3,4) coordinate (6) 
		(6,3.5)  coordinate (7)
		(5,1.5) coordinate (8)
		;				
		%========  dessins des Arêtes =================			
		\draw[thick,black] (1)--(2)--(8)--(7)--(6)--(5)--(3)--(4)--(1);
		\draw[thick,black] (5) -- (4);
		\draw[thick,black] (3) -- (6);
		\draw[thick,black] (6) -- (8);
		\draw[line width=3pt,red]  (6) -- (8)--(7)--(6);
		%========  posisionement des nom des sommets =================
		\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
		\node[vertex] [label = left : 1] at (1) {};
		\node[vertex] [label = right: 2] at (2) {};
		\node[vertex] [label = left: 3] at (3) {};
		\node[vertex] [label = right : 4] at (4) {};
		\node[vertex] [label = left: 5] at (5) {};
		\node[vertex] [label = below: 6] at (6) {};
		\node[vertex] [label = right: 7] at (7) {};
		\node[vertex] [label = right: 8] at (8) {};		
	\end{tikzpicture}
	\captionof{figure}{Exemple 1 d'un cycle de longueur 3} 
	\label{Exemple 1 d'un cycle de longueur 3}	
\end{figure}
Ce cycle rouge est de longueur=3, la longueur d'un cycle, c'est le nombre de ces Arêtes.	
\end{itemize} 

%\bigbreak
%================ D’autres vocabulaire ===============================
\iffalse  --------------
\textbf{Autres vocabulaire} : 
\\
\begin{itemize}
\item     
Un \textbf{cycle simple}: est un cycle dans lequel chaque arête est utilisée une seule fois. \textbf{[4]}
\\ \\
\item Un \textbf{graphe acyclique} est un graphe qui ne contient pas de cycle. Et chaque composante d’un graphe acyclique est un \textbf{arbre} ; Pour cette raison, les graphes acycliques sont habituellement appelés des \textbf{forêts} \citep{Bondy-Murty}, qu'on verra un peut plus tard à la section Forêts et arbres \ref{Forêts et arbres}; \\ \\
%\textbf{Source : Traduction-Bondy-Murty.pdf}
\end{itemize}	
\bigbreak 
-------------
\fi 


%========= Connexe   =====================
\subsection{Connexe}
\label{Connexe}
\textbf{Définition} : Un graphe \( G = (V, E) \) est connexe si pour tout \( A,B \in V \) il existe un chemin entre $A$ et $B$. \\ 
Donc on dit si pour chaque paire de sommet, le graphe contient un \textbf{chemin} entre ces deux sommets, alors le \textbf{graphe est connexes} \citep{ChristianLaforest}.
\\
\textit{i.e.} il ne doit pas y avoir de sommet isolé, nous allons voir après un exemple dans la section Graphe 2-connexe \ref{Graphe 2-connexe}.
\\ \\ 
\textbf{Exemples :}
\\
\begin{itemize}
\item[$\blacktriangleright$] Exemples 1
\\		
\begin{figure}[H]
	\centering	
	\newcommand\size{2}% distance of nodes from center
	\begin{tikzpicture}
		\draw[thick,black]  (18:\size) \foreach \a in {90,162,234,306} { -- (\a:\size) } -- cycle;
		\draw[thick,black] (18:\size) \foreach \a in {162,306,90,234} { -- (\a:\size) } -- cycle;
		\foreach \a in {18,90,162,234,306} { \node[draw,circle,fill=teal!30!white,inner sep = 3pt] at (\a:\size){}; }
	\end{tikzpicture}
	\captionof{figure}{Exemple 1 d'un graphe connexe} 
	\label{Exemple 1 d'un graphe connexe}	
\end{figure}

Ce graphe nommé $K_5$ est un graphe complet non orienté de cinq sommets, c'est-à-dire qu'il contient toutes les arêtes possibles entre ses sommets. Par conséquent, chaque sommet de $K_5$ est adjacent à tous les autres sommets, ce qui signifie qu'il existe un chemin de longueur 1 entre chaque paire de sommets. En d'autres termes, le graphe $K_5$ est connexe et cette propriété est assurée par sa structure particulière en tant que graphe complet.
%\\ 
% \item[$\blacktriangleright$] Exemples 2
% \\
% \begin{tikzpicture}
	% \path
	% ( 0  , 2.2 ) coordinate (1)
	% ( 2.5, 4 ) coordinate (2)
	% ( 5  , 3.5 ) coordinate (3)
	% ( 5, 1.5 ) coordinate (4)
	% ( 1.5  ,1 ) coordinate (5);				
	% %========  dessins des Arêtes =================			
	% \draw[thick,black] (2) -- (3) -- (4) -- (5) -- (2)--(1);		
	% \draw[thick,black] (2) -- (5);
	% \draw[thick,black] (3) -- (5);
	% %========  posisionement des nom des sommets =================
	% \tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	% \node[vertex] [label = left: 1] at (1) {};
	% \node[vertex] [label = above : 2] at (2) {};
	% \node[vertex] [label = right: 3] at (3) {};
	% \node[vertex] [label = right: 4] at (4) {};
	% \node[vertex] [label = left: 5] at (5) {};
	% \end{tikzpicture}
% \\ \\
% %%\includegraphics{images/image20.png}
% Ce graphe il est connexes aussi, puisque si je prends deux sommets quelconque, x et y il aura bien un chemin entre ces deux sommets là.
\\
\item[$\blacktriangleright$] Exemples 3
\\ \\
\begin{figure}[H]
	\centering	
	\begin{tikzpicture}
		\path
		(0,0) coordinate (1)
		(3,-1) coordinate (2)
		(3,3) coordinate (3)
		(0,2) coordinate (4)
		(6,0.5) coordinate (5)
		(6,2.5) coordinate (6) ;	
		
		%========  dessins des Arêtes =================			
		\draw[thick,black] (1) -- (3) -- (4) -- (2)--(1);
		\draw[thick,black] (5) -- (6);
		%========  posisionement des nom des sommets =================
		\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
		\node[vertex] [label = left : 1] at (1) {};
		\node[vertex] [label = right: 2] at (2) {};
		\node[vertex] [label = right: 3] at (3) {};
		\node[vertex] [label = left : 4] at (4) {};
		\node[vertex] [label = right: 5] at (5) {};
		\node[vertex] [label = right: 6] at (6) {};		
	\end{tikzpicture}
	\captionof{figure}{Exemple 2 d'un graphe non-connexe} 
	\label{Exemple 2 d'un graphe non-connexe}	
\end{figure}
%\includegraphics{images/image21.png}	
%\\	
En revanche, il est intéressant de considérer l'exemple de graphe suivant pour illustrer une propriété importante des graphes : la connexité. Ce graphe est composé de deux morceaux séparés, ce qui le rend non connexe. En effet, il n'existe pas de chemin reliant les sommets 3 et 6, ni entre les sommets 4 et 5 \textit{etc.}, ce qui empêche de se déplacer de l'un à l'autre de ces sommets en suivant les arêtes du graphe. \\
\end{itemize}
\bigbreak

%===========   Graphes planaires   ========================
\subsection{Graphes planaires}	
\label{Graphes planaires}
\textbf{Définition d'un graphe planaire}.\\ 
En théorie des graphes, un graphe planaire est un graphe qui peut être incorporé dans le plan, c'est-à-dire qu'il peut être dessiné sur le plan de telle sorte que ses arêtes ne se croisent qu'à leurs extrémités. En d'autres termes, il peut être dessiné de manière à ce qu'aucune arête ne croise une autre. Un tel dessin est appelé graphe planaire ou plongement. Un graphe planaire peut être défini comme un graphe planaire dont chaque nœud est relié à un point d'un plan et chaque arête à une courbe planaire de ce plan, de sorte que les points extrêmes de chaque courbe sont les points reliés à ses nœuds d'extrémité et que toutes les courbes sont disjointes, sauf en leurs points extrêmes.
\\ \\	
\textbf{Exemple} : Le graphe figure suivante \ref{Exemple d'un graphe planaire} est planaire si on déplace les sommets \citep{MathieuSablik}.
\\ \\ \\
\begin{figure}[H]
\centering	
\begin{tikzpicture}
	\path
	(0,0) coordinate (1)
	(3,0) coordinate (2)
	(3,3) coordinate (3)
	(0,3) coordinate (4);		    
	%========  dessins des Arêtes =================			
	\draw (2) -- (3) -- (4) -- (1)--(2);
	\draw (3) -- (1);
	\draw (4) -- (2);
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : 1] at (1) {};
	\node[vertex] [label = right: 2] at (2) {};
	\node[vertex] [label = right: 3] at (3) {};
	\node[vertex] [label = left : 4] at (4) {};
\end{tikzpicture}
\captionof{figure}{Exemple d'un graphe planaire} 
\label{Exemple d'un graphe planaire}
\end{figure}
Dans cette image, les chemins \( <1, 4, 3> \) et \( <1, 2, 3> \) sont distincts, même s'ils partagent les sommets 1 et 3.
\bigbreak  

%================   Face d'un graphe   ======================
\subsection{Face d'un graphe planaire}
\label{Face d'un graphe}		
En théorie des graphes, on appelle "face" d'un graphe $G$ planaire tout cycle de $G$ de longueur au moins égale à 3 ne contenant en son intérieur aucun sommet ni arête. Par convention, la frontière extérieure d'un graphe connexe planaire est considérée comme une face, appelée "face extérieure" ou "face infinie" (au sens de non limitée). Cette notion de face est essentielle en théorie des graphes planaires, où elle permet notamment de décrire la structure des graphes planaires et de caractériser leur planarité ou non-planarité à partir de leur nombre de faces et de sommets.
\\ \\
\textbf{Exemple}: \\ \\
Le graphe ci-dessous possède 5 faces finies : la face 1 adf, la face 2 afb, la face 3 bfc, la face 4 cfd et la face cbe. la face abcd n'en est pas une. Ce graphe connexe contient donc 5 faces si on lui adjoint sa face 6 extérieure.    
\\ \\
\begin{figure}[H]
\centering	
\begin{tikzpicture}						
	\path
	( 0  , 0 ) coordinate (A) 
	( 6, 0 ) coordinate (B)
	( 6  , 6 ) coordinate (C)
	( 0, 6 ) coordinate (D)
	( 10  , 0 ) coordinate (E)
	( 3  , 3 ) coordinate (F) ;	
	
	%\draw  [fill = green!5!white]  (5,3) ellipse (8cm and 5cm);
	\draw[fill=cyan!7!white]
	(-1, -2) .. controls (0, -3) and (12, -2) .. (12, 1)
	.. controls (8, 10) and (8, 9) .. (0, 9)
	.. controls (-4, 10) and (-1, -2) .. cycle;	
	
	\draw [fill = purple!40!white](C)--(B)--(E)--(C);
	\draw [fill = blue!20!white](A)--(F)--(B)--(A) ;
	\draw [fill = yellow!50!white](B)--(F)--(C)--(B) ;
	\draw [fill = pink!50!white](C) -- (F) -- (D)--(C);
	\draw [fill = green!40!white](D)--(F)--(A)--(D) ;
	
	\tikzstyle{vertex} = [draw,circle,fill=cyan,inner sep = 3pt]
	\node[vertex] [label = left : a] at (A) {};
	\node[vertex] [label = below: b] at (B) {};
	\node[vertex] [label = right: c] at (C) {};
	\node[vertex] [label = left : d] at (D) {};
	\node[vertex] [label = right: e] at (E) {};
	\node[vertex] [label = left : f] at (F) {};
	
	\path 
	(2 , 3)    coordinate () {} node[left]	{face 1}
	(3.5 , 1.5 )    coordinate () {} node[left]	{face 2}
	(5 , 3)    coordinate () {} node[left]	{face 3}
	(3.5 , 4.5 )    coordinate () {} node[left]	{face 4}
	(8 , 1.5)    coordinate () {} node[left]	{face 5} 
	(3.5, 7)    coordinate () {} node[left]	{face 6} ;
	
\end{tikzpicture}
%	\includegraphics{images/image22.png}
\captionof{figure}{Les faces d'un graphe} 
\label{Les faces d'un graphe}	
\end{figure}
\citep{mehl}

\bigbreak 
%===============   Frontière   ==============================
\subsection{Frontière}
\label{Frontière}
En théorie des graphes planaires, la \textbf{frontière} d'une face dans un graphe planaire est le "contour" qui délimite cette face, c'est-à-dire l'ensemble des arêtes qui se trouvent sur le bord de la face. Dans le cas particulier des graphes planaires dessinés avec des arêtes droites, la frontière d'une face correspond au tracé rectiligne qui relie les sommets de la face. La notion de frontière est une notion essentielle en théorie des graphes planaires, car elle permet de caractériser la structure des faces qui composent le graphe planaire, ainsi que leur relation avec les autres faces du graphe. La frontière est également utilisée pour décrire la propriété de "faces adjacentes" dans un graphe planaire, qui correspond au fait que deux faces ont une partie de leur frontière en commun.	

%===============   Corde   ==============================
\subsection{Corde}
\label{Corde}
Une corde, dans le contexte de la théorie des graphes, est une arête qui relie deux sommets non adjacents d'un cycle. Autrement dit, une corde est une arête supplémentaire qui connecte deux sommets d'un cycle sans passer par les sommets intermédiaires du cycle.
\\ 
Nous verrons plus tard dans la section du Graphe cordal \ref{Graphe cordal}, un exemples intéressant.
\footnote{ Introduc graphes 
\href{https://fr.wikipedia.org/wiki/Cycle_(th\%C3\%A9orie_des_graphes)}     
{\texttt{Théorie des graphes sur Wiki} }  }
\bigbreak  
%=======================   Les types de graphes   =====================================
\section{Types de graphes}
\label{Les types de graphes}
%=======================      
%=============== Sous-graphes et sur-graphes   =============================
\subsection{Sous-graphes et sur-graphes}
\label{Sous-graphes et sur-graphes}
Un sous-graphe est un graphe qui est obtenu en retirant des sommets et/ou des arêtes d'un graphe initial, tout en conservant les relations entre les sommets restants. Plus précisément, un sous-graphe est \textbf{induit par} \footnote{La notion de "induit par" est utilisée pour spécifier qu'un sous-graphe est construit en sélectionnant un ensemble spécifique de sommets et/ou d'arêtes à partir d'un graphe initial.\label{refnote3}}  un ensemble de sommets sélectionnés à partir du graphe initial, ce qui signifie que seuls les sommets choisis et les arêtes qui les relient sont inclus dans le sous-graphe. Ainsi, le sous-graphe conserve la structure de connexion entre ses sommets, mais peut avoir moins de sommets et d'arêtes que le graphe initial.
\\ \\
Étant donné un graphe $G$. Si $e$ est une arête de $G$, on peut obtenir un graphe à $m−1$ arêtes en supprimant $e$ de $G$, mais en laissant les sommets et les autres arêtes intacts. Le graphe ainsi obtenu est noté $G'=G-e$. De manière similaire, si $v$ est un sommet de $G$, on peut obtenir un graphe à $n−1$ sommets en supprimant de $G$ le sommet $v$ ainsi que toutes les arêtes incidentes à $v$. Le graphe ainsi obtenu est noté $G−v$, comme illustré dans les deux figures suivates \citep{Bondy-Murty}.
\\ \\
\begin{figure}[H]
\centering		
\begin{tikzpicture}
	\path
	(0,0) coordinate (C)
	(3,0) coordinate (F)
	(3,3) coordinate (D)
	(0,3) coordinate (A)
	(5,2.6) coordinate (B)
	(4.5,1) coordinate (E)
	;		
	%========  dessins des Arêtes =================			
	\draw[thick,black] (F)--(D)--(A)--(C)--(F);
	\draw[thick,black] (D)--(C);
	\draw[thick,black] (D)--(B)--(E);
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : C] at (C) {};
	\node[vertex] [label = right: F] at (F) {};
	\node[vertex] [label = below right: D] at (D) {};
	\node[vertex] [label = left : A] at (A) {};
	\node[vertex] [label = right: B] at (B) {};
	\node[vertex] [label = left : E] at (E) {};
\end{tikzpicture}
\captionof{figure}{Exemple d'un sur-graphe} 
\label{Exemple d'un sur-graphe}

\begin{tikzpicture}
	\path
	(0,0) coordinate (C)
	(3,0) coordinate (F)
	(3,3) coordinate (D)
	(0,3) coordinate (A)
	(5,2.6) coordinate (B)
	(4.5,1) coordinate (E)
	;		
	%========  dessins des Arêtes =================			
	\draw[thick,black] (D)--(A)--(C)--(F);
	\draw[thick,black] (D)--(C);
	\draw[thick,black] (D)--(B)--(E);
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 3pt]
	\node[vertex] [label = left : C] at (C) {};
	\node[vertex] [label = right: F] at (F) {};
	\node[vertex] [label = below right: D] at (D) {};
	\node[vertex] [label = left : A] at (A) {};
	\node[vertex] [label = right: B] at (B) {};
	\node[vertex] [label = left : E] at (E) {};
\end{tikzpicture}
\captionof{figure}{Exemple d'un sous-graphes} 
\label{Exemple d'un sous-graphes}
\end{figure}

\bigbreak  

%=========   Graphe 2-connexe   =======================
\subsection{Graphe 2-connexe}
\label{Graphe 2-connexe}
%\label{Connexité}
\textbf{Définition}:
\\
Un graphe est dit "2-connexe" ou "biconnexe" s'il existe au moins deux chemins complètement distincts entre chaque paire de sommets (c'est-à-dire qu'aucun sommet n'est partagé entre les chemins). Cela implique que si on retire un sommet (et toutes les arêtes qui lui sont connectées), le graphe reste toujours connexe\citep{west2001introduction}. En d'autres termes, la suppression de n'importe quel sommet ou n'importe quelle arête permet au graphe de rester connexe, sans le séparer en plusieurs parties non connectées\citep{belbeze2012}.
\\ \\	
\noindent\fbox{
\parbox{\textwidth}{
	\begin{theorem}
		\label{theorem 3.1}	
		Un graphe $G$ est 2-connexe si et seulement si, pour toute paire de sommets de G, il existe un cycle dans $G$ qui contient ces deux sommets.
	\end{theorem}	
}
}		

\subsection{Graphe 3-connexe}
\label{Graphe 3-connexe}

Un graphe 3-connexe est un graphe non orienté dans lequel il existe au moins trois chemins internes distincts entre chaque paire de sommets. Autrement dit, pour chaque paire de sommets, il existe au moins trois chemins différents reliant ces deux sommets qui ne partagent aucun sommet commun autre que les deux extrémités \citep{Bondy-Murty}, on dit: Le graphe \( G = (V, E) \) est 3-connexe si pour tout \( v_1, v_2 \in V \), le graphe \textbf{induit par} \footref{refnote3} $ V \setminus \{v_1,v_2\} $ est connexe.

%===========   Graphe cordal   ===========================	
\subsection{Graphe cordal}
\label{Graphe cordal}

En théorie des graphes, on dit qu'un \textbf{graphe est cordal} figure \ref{figure Graphe cordal} si chacun de ses cycles de quatre sommets ou plus possède une \textbf{corde}, c'est-à-dire une arête reliant deux sommets non adjacents du cycle. Une définition équivalente est que tout cycle sans corde possède au plus trois sommets.
\\ \\
\textbf{Exemple}
\begin{figure}[H]
\centering
\begin{tikzpicture}
	\path
	( 0  , 2.5 ) coordinate (1)
	( 2.5, 4 ) coordinate (2)
	( 6  , 3 ) coordinate (3)
	( 4.5, .8 ) coordinate (4)
	( 1.5  , 0 ) coordinate (5);		
	
	%========  dessins des Arêtes =================			
	\draw  (2) -- (3) -- (4) -- (5) -- (1)--(2);		
	\draw[thick,green] (2) -- (4);
	\draw[thick,green] (2) -- (5);
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left: 1] at (1) {};
	\node[vertex] [label = above : 2] at (2) {};
	\node[vertex] [label = below: 3] at (3) {};
	\node[vertex] [label = right: 4] at (4) {};
	\node[vertex] [label = left: 5] at (5) {};
	
	%	\draw (0,0) arc (0:270:8mm);
	%	\draw (0,0) arc (0:315:1.75cm and 1cm);
\end{tikzpicture}
\captionof{figure}{Graphe cordal} 
\label{figure Graphe cordal}
\end{figure}
%	\includegraphics{images/image23.png}	
Un cycle, en noir, avec deux cordes, en vert. Si l'on s'en tient à cette partie, le graphe est cordal. Supprimer l'une des arêtes vertes \textit{e.g.} \{2,5\} rendrait le graphe non cordal.
\\
En effet, l'arête \{2,4\} formerait, avec les trois arêtes noires \{1,2\}, \{1,5\} et \{5,4\}, un cycle de longueur 4 sans corde 
\footnote{Graphe cordal \href{https://fr.wikipedia.org/wiki/Graphe_cordal}     
{\texttt{sur Wikipedia} } }.
\\
Les \textbf{graphes complets} et les \textbf{arbres} sont des exemples simples de graphes cordaux. \citep{Bondy-Murty}.
\bigbreak 
%===========   Graphe triangulé - Triangulation   ============
\subsection{Graphe planaire triangulé}
\label{Graphe triangulé - Triangulation}
Examinons l'exemple présenté dans la figure ci-dessous : 
\begin{figure}[H]
\centering
\begin{tikzpicture}				
	% Source : https://www.baeldung.com/cs/latex-drawing-graphs 
	% https://tex.stackexchange.com/questions/270543/draw-a-graph-in-latex-with-tikz
	% https://tex.stackexchange.com/questions/315456/colouring-graphs-tikz		
	% source ellipse : https://www.overleaf.com/learn/latex/LaTeX_Graphics_using_TikZ%3A_A_Tutorial_for_Beginners_(Part_1)%E2%80%94Basic_Drawing
	
	%\draw  [fill = green!5!white] 
	%		(-1,-2) .. controls (0,-3) .. (5,-2) .. controls (9,1) and (7,7) .. (4,7.5) .. controls (0,8) and (-4,8) .. (-1,-2) ;												
	\path
	( 0, 0 ) coordinate (1)
	( 3, 0 ) coordinate (2)
	( 3, 3 ) coordinate (3)
	( 0, 3 ) coordinate (4);		
	
	\draw (1)--(2)--(3)--(4)--(1)--(3) ;
	%			\draw [fill = white] (2) -- (4) -- (5) -- (1) -- (2);
	%			\draw [fill = cyan] (2) -- (3) -- (4) -- (2); 		
	%			\draw (5) -- (1);
	%			\draw (2) -- (4);	
	%			
	\path (1.7,2) coordinate () {} node[left]		{face1}	;
	\path (2.5,1) coordinate () {} node[left]		{face2}	;				
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : 1] at (1) {};
	\node[vertex] [label = right: 2] at (2) {};
	\node[vertex] [label = right: 3] at (3) {};
	\node[vertex] [label = left : 4] at (4) {};
	
	%	\draw (0,0) arc (0:270:8mm);
	%	\draw (0,0) arc (0:315:1.75cm and 1cm);
\end{tikzpicture}
\captionof{figure}{Graphe non-triangulé} 
\label{figure Graphe non-triangulé}
\end{figure}
Nous avons un graphe non triangulé, car la face extérieure contient 4 arêtes. Comment pouvons-nous alors effectuer une triangulation pour ce graphe ? En ajoutant une arête entre les sommets (1) et (3), nous obtenons le graphe modifié ci-dessous :
\begin{figure}[H]
\centering
\begin{tikzpicture}	
	
	% Ajoutez un contour personnalisé autour de votre graphe en utilisant des courbes de Bézier
	\draw[fill=green!30!white]
	(-1, -2) .. controls (0, -3) and (5, -2) .. (5, 1)
	.. controls (6, 5) and (4, 5) .. (0, 5)
	.. controls (-4, 6) and (-1, -2) .. cycle;		
	
	\path
	( 0, 0 ) coordinate (1)
	( 3, 0 ) coordinate (2)
	( 3, 3 ) coordinate (3)
	( 0, 3 ) coordinate (4);		
	
	\draw (1)--(2)--(3)--(4)--(1)--(3) ;
	\draw [fill = yellow!20!white] (1)--(4)--(3)--(1);
	\draw [fill = cyan!20!white  ] (2)--(3)--(1)--(2); 		
	\draw[fill = red!20!white] (0, 0) to[out=180, in=-135] (-0.5, 3.5) to[out=45, in=90] (3, 3)--(4)--(1);
	
	\path (1.7,2) coordinate () {} node[left]		{face1}	;
	\path (2.5,1) coordinate () {} node[left]		{face2}	;	
	\path (2, -1) coordinate () {} node[left]		{face3}	;		
	\path (2,  3.5) coordinate () {} node[left]		{face4}	;
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = below: 1] at (1) {};
	\node[vertex] [label = right: 2] at (2) {};
	\node[vertex] [label = right: 3] at (3) {};
	\node[vertex] [label = left : 4] at (4) {};
	
	%	\draw (0,0) arc (0:270:8mm);
	%	\draw (0,0) arc (0:315:1.75cm and 1cm);
\end{tikzpicture}
\captionof{figure}{Graphe triangulé} 
\label{Graphe triangulé}
\end{figure}	
Et maintenant, nous avons notre triangulation, également appelée \textbf{graphe planaire avec triangulation interne} \citep{Bondy-Murty}.
\\ \\	
\textbf{Définition}
\\
Un graphe triangulé est un graphe planaire, simple, connexe, non orienté, où toutes ses faces sont des triangles \citep{Bondy-Murty}. Dans la figure précédente, nous voyons que les faces (4) et face3 sont des triangles, car elles contiennent chacune trois arêtes, mais elles n'ont pas la forme d'un triangle classique, comme illustré dans la figure suivante :
\\
\begin{figure}[H]
\centering
\begin{tikzpicture}
	% Définir les coordonnées des sommets du triangle équilatéral
	\coordinate (1) at (0, 0);
	\coordinate (2) at (2, 0);
	\coordinate (3) at (1, {sqrt(3)});
	
	% Dessiner le triangle équilatéral
	\draw (1) -- (2) -- (3) -- cycle;
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left: 1] at (1) {};
	\node[vertex] [label = right: 2] at (2) {};
	\node[vertex] [label = right: 3] at (3) {};
	
\end{tikzpicture}
\captionof{figure}{Triangle} 
\label{Triangle}
\end{figure}


%=======================  Mineurs de graphes    ===========================	
\subsection{Mineurs de graphes}
\label{Mineurs de graphes}
Un mineur de graphe est un sous-graphe obtenu à partir d'un graphe d'origine en supprimant des arêtes et/ou des nœuds. En d'autres termes, un graphe G' est un mineur du graphe G si G' peut être obtenu à partir de G en supprimant des arêtes et/ou des nœuds, et en effectuant des contractions d'arêtes.
\\
La contraction d'une arête fait référence à une opération qui consiste à fusionner les deux extrémités d'une arête en un seul nœud, tout en maintenant les arêtes adjacentes à l'arête contractée. Plus précisément, si nous avons un graphe planaire et que nous effectuons la contraction d'une arête, nous supprimons cette arête du graphe et fusionnons les nœuds aux extrémités de l'arête en un seul nœud. Les arêtes adjacentes à l'arête contractée sont préservées et continuent de se connecter au nouveau nœud résultant de la contraction.
\\
Les mineurs de graphes sont largement étudiés en théorie des graphes, en informatique théorique et en mathématiques discrètes, car ils ont de nombreuses applications dans différents domaines, tels que la théorie des réseaux, l'optimisation combinatoire, l'algorithmique et la complexité \cite{DieterJungnickel} \cite{RDiestel}.	
\\ \\
Et \cite{HasslerWhitney} a prouvé que la suppression ou la contraction d'une arête d'un graphe planaire produit toujours un autre graphe planaire. Plus précisément, il a montré que tout graphe planaire est "mineur" d'un autre graphe planaire obtenu par suppression ou contraction d'arêtes.
\\
Cette affirmation est maintenant considérée comme un résultat fondamental de la théorie des graphes planaires et est souvent utilisée dans la preuve d'autres résultats importants dans ce domaine.
\\ \\
\noindent\fbox{
\parbox{\textwidth}{
	\begin{theorem}{\textbf{Théorème de Whitney}}
		La suppression ou la contraction d’une arête d’un graphe planaire donne un autre graphe planaire.
	\end{theorem}	
}
}	
{\color{white}-} % This line will now show in pdf and no error will be generated.
\bigbreak
Ainsi nous avons :	
\begin{prop}
Les mineurs de graphes planaires sont planaires.
\end{prop}

\bigbreak

%=================	Graphes planaires maximaux	=======================
\subsection{Graphes planaires maximaux}
\label{Graphes planaires maximaux}
Un graphe simple est dit planaire maximal s'il est planaire mais que l'ajout d'une arête (sur l'ensemble de sommets donné) détruirait cette propriété (planarité). Toutes les faces (y compris la face extérieure) sont alors délimitées par trois arêtes, ce qui explique le terme alternatif de triangulation planaire. Les noms alternatifs "graphe triangulaire" \citep{schnyder1989planar} ou "graphe triangulé"\citep{bhasker1988linear} ont également été utilisés, mais ils sont ambigus, car ils font plus communément référence au graphe linéaire d'un graphe complet et aux graphes chordaux respectivement. 
\\
Tout graphe planaire maximal est au moins 3-connexe. Si un graphe planaire maximal a $v$ sommets avec $v > 2$, alors il a précisément \((3v-6)\) arêtes et \((2v-4)\) faces, conformément au \textbf{théorème d'Euler} pour les graphes planaires. Ce résultat peut être illustré en utilisant un exemple concret.
\\
Par exemple, si nous considérons le graphe planaire maximal illustré dans la figure \ref{Graphe triangulé} avec \(v = 4\) sommets, nous pouvons appliquer la formule pour calculer le nombre d'arêtes et de faces. Ainsi, nous avons \(3v - 6 = 3 x 4 - 6 = 6\) arêtes et \(2v - 4 = 2 x 4 - 4 = 4\) faces. Cette correspondance entre le nombre de sommets, d'arêtes et de faces est vérifiée dans cet exemple spécifique, ce qui confirme la validité de la formule.

\bigbreak

%====================================================================
%	Dessins de lignes droites de graphe planaires 
%====================================================================
\newpage
\section{Dessins en lignes droites des graphe planaires}
\label{Dessins en lignes droites des graphe planaires}
%$\boxed{\text{Ce texte est encadré}}$
Il y a beaucoup d'études par des chercheurs sur ce sujet, on a \textit{e.g.,} l'article : 
\\
\begin{quote}
By far the most agreed-upon edge placement heuristic is to minimize the number of edge crossings in a graph [BMRW98,Har98,DH96,Pur02,TR05,TBB88]. The importance of avoiding edge crossings has also been extensively	validated in terms of user preference and performance (see Section 4). Similarly, based on perceptual principles, it is beneﬁcial to minimize the number of edge bends within a graph [Pur02, TR05, TBB88]. Edge bends make edges more
difﬁcult to follow because an edge with a sharp bend is more likely to be perceived as two separate objects. This leads to the heuristic of keeping edge bends uniform with respect to
the bend’s position on the edge and its angle [TR05]. If an edge must be bent to satisfy other aesthetic criteria, the angle of the bend should be as little as possible, and the bend
placement should evenly divide the edge.
\end{quote}
\textbf{"The Aesthetics of Graph Visualization"} \citep[3.2, page 8]{BRSG}.
\\ \\
Dans cet article ils disent que l'heuristique de placement des arêtes la plus reconnue consiste à minimiser le nombre de croisements des arêtes dans un graphe. \\
Et plus tard ils disent aussi qu'il est bénéfique de minimiser le nombre de courbes d’Arêtes\footnote{courbes d’Arêtes : où une arête change de direction dans une représentation graphique d'un graphe. Dans le contexte de la visualisation de graphes, les courbes d'arêtes peuvent rendre les arêtes plus difficiles à suivre, car ils peuvent donner l'impression que l'arête se compose de plusieurs segments distincts plutôt que d'une seule entité continue. }, et si nous voulons minimiser quelque chose, dans le cas optimal nous n'avons rien de tout cela! donc si nous n'avons pas de croisements d’Arêtes alors nous avons un dessin planaire, et si nous n'avons pas d’Arêtes alors nous avons un dessin en ligne droite. alors la question est de savoir \textbf{quelle est l'esthétique de nos dessins?}, et pour cela, dans cette partie, nous nous concentrerons sur les graphes planaires.\\
Chaque fois qu'on regarde une classe de graphe, il y a quelques questions importantes qu'on doit poser, et les trois les plus importantes sont :
\begin{enumerate}
\item pouvons-nous caractériser cette classe?
\item pouvons-nous reconnaître cette classe?
\item comment pouvons-nous la dessiner ?
\end{enumerate}

\bigbreak
%=======================   Caractérisation   =====================================	
\subsection{Caractérisation} 
\label{Caractérisation} 
Caractériser les graphes planaires implique d'identifier les propriétés distinctives qui les séparent des autres classes de graphes, en définissant les critères nécessaires pour qu'un graphe appartienne à cette catégorie. La caractérisation des graphes planaires repose sur le théorème de Kuratowski, selon lequel un graphe est planaire si et seulement si ni $K_{5}$ (graphe complet à 5 sommets) ni $K_{3,3}$ (graphe biparti complet avec deux ensembles de 3 sommets) ne sont présents en tant que mineurs. Cette absence de deux graphes spécifiques en tant que mineurs constitue la base de la caractérisation des graphes planaires.
\\ \\
%=======================  Reconnaissance    =====================================	
\subsection{Reconnaissance} 
\label{Reconnaissance}
Étant donné un graphe à savoir si c'est un graphe planaire est appelé test de planarité. Plusieurs algorithmes ont été proposés pour ce problème. Les meilleurs atteignent une complexité en temps linéaire, ce qui est optimal asymptotiquement. Le premier tel algorithme date de 1974, et est dû à \textbf{John Hopcroft} et \textbf{Robert Tarjan} 1974, qui reconnaît un graphe planaire en temps linéaire. Donc dans le future on suppose que nous avons déjà vérifié si le graphe qu'on veut dessiner est planaire
\footnote{Graphe planaire 
\href{https://fr.wikipedia.org/wiki/Graphe_planaire}     
{\texttt{ sur Wikipedia} }}.   
%=======================   Dessin   =====================================	
\subsection{Dessin}
\label{Dessin}
Dans le domaine des graphes, différents algorithmes ont été développés pour traiter divers types de graphes. L'algorithme de \textbf{Tutte}, par exemple, est conçu spécifiquement pour les graphes planaires 3-connexes. D'autres algorithmes existent pour les arbres et les graphes en séries parallèles. Cependant, il n'existe pas d'algorithme universel pour tous les graphes planaires et leurs représentations.
\\
Des théorèmes anciens de \textbf{Wagner} (1936), \textbf{Fary} (1948) et \textbf{Stein} (1951), prouvés indépendamment, affirment que chaque graphe planaire admet une représentation planaire avec des arêtes droites. Bien que cela permette de représenter tous les graphes planaires de cette manière, ces preuves présentent un inconvénient : la taille (ou le nombre d'arêtes) de la région entourée par les arêtes dans une représentation planaire n'est pas bornée par une fonction polynomiale de n, où$n$est le nombre de sommets du graphe. En conséquence, la taille de cette région peut croître au moins de manière exponentielle par rapport à n, ce qui peut rendre la représentation du graphe inefficace ou difficile à réaliser en pratique.
\bigbreak
D’abord nous voulons une classe spéciale de \textbf{graphes planaires, appelés triangulations} \ref{Graphe triangulé}, ou toutes les faces doivent être des triangles, et il y a une deuxième sous-classe qui sont les \textbf{graphes planaires maximaux} \ref{Graphes planaires maximaux}.	
\\	\\ \\ \\ 
%======= Extension d'un graphe planaire à une triangulation planaire ===============
\textbf{Extension d'un graphe planaire à une triangulation planaire :}
\bigbreak
Examinons la figure \ref{Graphe triangulé} de notre précédent exemple de graphe triangulé et essayons de trouver une arête que nous pouvons ajouter sans compromettre la planarité.
\\
En réalité, nous ne le pouvons pas. Par exemple, si nous ajoutons une arête entre les sommets (2) et (4), cela créerait un croisement avec l'arête \{1,3\}. Si nous la faisons passer par le face externe, nous avons également un croisement avec l'arête externe \{1,3\}. Étant donné que chaque face est un triangle et que chaque arête que nous souhaitons ajouter ne peut être dessinée de manière planaire que si elle se trouve entièrement à l'intérieur d'une face, nous ne pouvons pas ajouter d'arête arbitrairement, car dans un triangle, tous les sommets sont déjà voisins.
\\
Ainsi, nous pouvons observer qu'un graphe planaire maximal \ref{Graphes planaires maximaux} est exactement une triangulation planaire ; ces deux classes de graphes sont donc identiques.
\\ \\
En se concentrant sur les triangulations planaires, nous pouvons dessiner tous les graphes planaires, car chaque graphe planaire est un sous-graphe d'une triangulation planaire.
\\ \\
Supposons que nous ayons un graphe planaire et qu'il y ait une face trop grande, ayant plus de trois sommets. Comment pouvons-nous étendre ce graphe à un super-graphe qui est une triangulation planaire ? Il y a deux façons :
\\ \\
\textbf{Réponse 1 :} 	
\bigbreak 	
Prenons un seul sommet, comme illustré dans la figure \ref{Exemple 1, transformer un sous-graphe en super-graphe}, et connectons-le à tous les sommets de cette face, à l'exception de ses voisins, car il est déjà connecté à eux. Ainsi, nous obtenons un super-graphe dont notre graphe original est le sous-graphe.
\\
\begin{figure}[H]
\centering	
\begin{tikzpicture}
	\path
	(0,0) coordinate (1)
	(2,0) coordinate (2)
	(2,2) coordinate (3)
	(0,2) coordinate (4)		    
	(3,1) coordinate (5)
	
	(7,0) coordinate (6)
	(9,0) coordinate (7)
	(9,2) coordinate (8)
	(7,2) coordinate (9)		    
	(10,1) coordinate (10)		
	;
	%========  dessins des Arêtes =================			
	\draw (1)--(2)--(5)--(3)--(4)--(1);
	\draw (6)--(7)--(10)--(8)--(9)--(6);
	\draw[<->, line width=2pt] (4.5,1) -- (6,1);
	\draw[line width=1.5pt, color=green!50!black] (8)--(6)--(10);
	
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : ] at (1) {};
	\node[vertex] [label = right: ] at (2) {};
	\node[vertex] [label = right: ] at (3) {};
	\node[vertex] [label = left : ] at (4) {};
	\node[vertex] [label = right: ] at (5) {};
	
	\node[vertex] [label = left : ] at (6) {};
	\node[vertex] [label = right: ] at (7) {};
	\node[vertex] [label = right: ] at (8) {};
	\node[vertex] [label = left : ] at (9) {};
	\node[vertex] [label = right:] at (10) {};
\end{tikzpicture}
\captionof{figure}{Exemple 1, transformer un sous-graphe en super-graphe}
\label{Exemple 1, transformer un sous-graphe en super-graphe}
\end{figure}
%
%	\includegraphics[width=0.2\linewidth]{images/image29.png}	
%	\label{fig:image29}
%	\bigbreak
\bigbreak
\textbf{Réponse 2 :}
\bigbreak 
Ajouter un seul sommet dans chaque face et de le connecter à tous les sommets qui se trouvent sur la frontière \ref{Frontière} de la face cela fonctionne tant que le graphe d'entrée est déjà 2-connexe, donc toutes nos faces sont des cycles simples si elles ne sont pas des cycle simples, alors nous devons ajouter quelques arêtes supplémentaires mais nous pouvons encore le faire facilement
%	\bigbreak 	
%	\includegraphics[width=0.2\linewidth]{images/image30.png}	
%	\label{fig:image30}
\bigbreak
\begin{figure}[H]
\centering	
\begin{tikzpicture}
	\path
	(0,0) coordinate (1)
	(2,0) coordinate (2)
	(2,2) coordinate (3)
	(0,2) coordinate (4)		    
	(3,1) coordinate (5)			
	(7,0) coordinate (6)
	(9,0) coordinate (7)
	(9,2) coordinate (8)
	(7,2) coordinate (9)		    
	(10,1) coordinate (10)			
	(8,1) coordinate (11) ;
	%========  dessins des Arêtes =================			
	\draw (1)--(2)--(5)--(3)--(4)--(1);
	\draw (6)--(7)--(10)--(8)--(9)--(6);
	\draw[<->, line width=2pt] (4.5,1) -- (6,1);
	\draw[line width=1.5pt, color=red] (8)--(11)--(9);
	\draw[line width=1.5pt, color=red] (6)--(11)--(7);
	\draw[line width=1.5pt, color=red] (10)--(11);
	%========  posisionement des nom des sommets =================
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : ] at (1) {};
	\node[vertex] [label = right: ] at (2) {};
	\node[vertex] [label = right: ] at (3) {};
	\node[vertex] [label = left : ] at (4) {};
	\node[vertex] [label = right : ] at (5) {};
	
	\node[vertex] [label = left : ] at (6) {};
	\node[vertex] [label = right : ] at (7) {};
	\node[vertex] [label = right : ] at (8) {};
	\node[vertex] [label = left : ] at (9) {};
	\node[vertex] [label = right : ] at (10) {};
	
	\node[vertex] [label = right : ] at (11) {};
	
\end{tikzpicture}
\captionof{figure}{Exemple 2, transformer un sous-graphe en super-graphe}
\label{Exemple 2, transformer un sous-graphe en super-graphe}
\end{figure}
Avec ces deux observations nous pourrons dire que chaque triangulation est 3-connexe, nous pouvons utiliser le théorème \ref{theorem 5.1} pour dessiner la triangulation,
\\ \\
\noindent\fbox{
\parbox{\textwidth}{
	\begin{theorem}	
		\label{theorem 5.1}		
		Toute triangulation planaire est au moins 3-connexe et possède un plongement planaire unique.  \citep{PhilippKindermann}
	\end{theorem}	
}
}	
\\ \\ \\
Ce théorème affirme que pour toute triangulation planaire donnée, il existe un unique plongement planaire qui représente graphiquement cette triangulation sans que les arêtes ne se croisent. Le plongement planaire est déterminé de manière unique et ne dépend pas de choix ou de variations arbitraires. De plus, la triangulation planaire est garantie d'être au moins 3-connexe, ce qui signifie qu'il y a au moins trois chemins indépendants reliant tout couple de sommets distincts dans le graphe planaire.
\\ \\
Et si nous avons n'importe quel graphe planaire, nous ajoutons simplement des arêtes pour en faire une triangulation, et pour le dessiner, il existe un \textbf{algorithme de Tutte} \citep{Tutte} qui crée un dessin en ligne droite pour chaque graphe planaire. Et après on supprime à nouveau les arêtes \citep{PhilippKindermann}.
\\	\\ \\ \\ 
\textbf{Algorithmes de dessin pour les graphes planaires des années 1990 :}
\\ \\
Il existe deux algorithmes indépendamment découverts vers 1990 qui permettent de générer des dessins de graphes planaires de manière efficace:
\begin{enumerate}
\item Le premier par \textbf{De Fraysseix, Pach, Pollack} \citep{FraysseixPachPollack} permet de dessiner une ligne droite simple pour chaque graphe planaire à$n$sommets sur une grille de taille \textbf{(2n-4)x(n-2)}.
\item Le seconde par \textbf{(Schnyder)} \citep{Schnyder} obtient une liaison légèrement meilleure avec \textbf{(n-2)x(n-2)}. 
\end{enumerate}	
{\color{white}-}
\bigbreak
{\color{white}-}
\textbf{L'idée principale de l'algorithme} : 
\\
Nous choisissons une arête \( \{v_{1},v_{2}\} \) de la face externe du graphe que nous souhaitons dessiner. Ensuite, nous introduisons de nouveaux sommets de manière intuitive pour créer un nouveau sous-graphe, appelé $G_{i}$, comme illustré dans la figure suivante.
\bigbreak 	
%	\includegraphics[width=0.2\linewidth]{images/image31.png}	
%	\label{fig:image31}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[c/.style={circle,fill=black,draw,inner sep=3pt}] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(8,0)   	coordinate	(v2)
	(4,3.5)       coordinate (vk+1)	
	(0.3,1.4)	coordinate	(v3)
	(1,2.4)	    coordinate	(v4)
	(2.3,2.1)	coordinate	(v5)
	(3.5,2.1)	coordinate	(v6)
	(4.8,2.1)	coordinate	(v7)
	(6.3,2.5)	coordinate	(v8)
	(7.5,1.5)	coordinate	(v9) ;
	
	\draw[fill = cyan!20!white] (v1)--(v3)--(v4)--(v5)--(v6)--(v7)--(v8)--(v9)--(v2)--(v1);
	\draw[line width=2pt, color=red] (v4)--(vk+1)--(v8);
	\draw[line width=2pt, color=orange] (v5)--(vk+1)--(v6);
	\draw[line width=2pt, color=orange] (vk+1)--(v7);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (v2)  {};
	\node[vertex] [label = above: $v_{i+1}$] at (vk+1)  {};
	\node[vertex] [label = left: ] 	at (v3)  {};
	\node[vertex] [label = left: ] 	at (v4)  {};
	\node[vertex] [label = below: ] 	at (v5)  {};
	\node[vertex] [label = below: ] 	at (v6)  {};
	\node[vertex] [label = below: ] 	at (v7)  {};
	\node[vertex] [label = right: ] 	at (v8)  {};
	\node[vertex] [label = right :] 	at (v9)  {};
	
	\path 
	(4,1) coordinate () {} node[left]	{$G_{i}$};
	
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{i}$} %\includegraphics{images/image1.png}
\label{Graphe $G_{i}$}	
\end{figure}
{\color{white}-}		
Une fois cette étape accomplie, nous sélectionnons un sommet sur la face externe qui n'a pas encore été dessiné. La "face externe" fait référence à la région entourant le graphe, c'est-à-dire l'espace situé à l'extérieur de toutes les autres faces formées par les arêtes du graphe. Ensuite, nous établissons des connexions, c'est-à-dire des arêtes, entre ce sommet sélectionné et les autres sommets du graphe. Ces connexions respectent la propriété de planarité, ce qui signifie qu'elles sont tracées de manière à éviter les croisements d'arêtes. Pour réaliser ces dessins, il est nécessaire d'avoir au moins deux sommets situés sur la frontière du graphe, c'est-à-dire des sommets qui sont à la fois à l'intérieur et à l'extérieur du graphe.
\\ 
Cette approche progressive nous permet de construire le dessin complet du graphe en ajoutant les sommets un par un, en suivant un schéma prédéfini et en garantissant la planarité du dessin final.
\\ \\ \\ 
Dans les chapitres suivants nous allons voir à la\textbf{ méthode Shift} qui prend un \textbf{graphe planaire} et son \textbf{ordre canonique} et donne le graphe dans cet ordre, cela fonctionne récursivement, mais \textbf{c'est quoi l'ordre canonique?} 
C'est ce qu'on vas voir dans le chapitre suivant.


%=======================================================
%		Ordre anonique
%=======================================================

\newpage 
\section{Ordre canonique}
\label{Ordre canonique}
Dans le cadre de notre algorithme de dessin, nous nous concentrons sur l'ajout ordonné des sommets dans un ordre spécifique qui possède des propriétés particulières. Cet ordre, connu sous le nom d'ordre canonique, a été défini par \citep{FraysseixPachPollack}. L'objectif de cet ordre est de garantir que l'ajout de chaque nouveau sommet ne crée pas de croisements indésirables \citep[PartII]{PhilippKindermann} un exemple d'ordre canonique est illustré dans la figure suivante.

\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=.7]
	\path 
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4,6.8)	    coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);	
	
	\draw(v1)--(v3)--(v2)--(v1);			
	
	\draw (v4)--(v13)--(v12);
	\draw (v11)--(v6);
	\draw (v4)--(v11)--(v5);
	
	\draw (v1)--(v2)--(v6);
	\draw (v13)--(v10)--(v4);
	%\draw[line width=2pt, color=green!70!black] (v4)--(v13);
	
	\draw (v13) -- (v15);
	\draw (v16) -- (v15);
	\draw (v16) -- (v14);
	\draw (v14)--(v11)--(v12)--(v14)--(v13);
	
	\draw (v2)--(v3)--(v1); 
	\draw (v3)--(v4)--(v2)--(v3);
	\draw (v4)--(v5)--(v2)--(v4); 
	\draw (v5)--(v6); 
	\draw (v1)--(v7)--(v3)--(v1); 
	\draw (v1)--(v8)--(v7)--(v1); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v12)--(v4);	
	
	\draw (v6) to[bend right=25] (v16); 
	\draw (v1) to[bend left=40]  (v16);
	\draw (v2) to[bend right=40] (v16);
	\draw (v6) to[bend right=20] (v14);
	\draw (v1) to[bend left=25] (v15);
	
	\draw[color=black] (v10)--(v8);
	\draw[color=black] (v10)--(v7);
	\draw[color=black] (v10)--(v3);
	
	\draw[color=black] (v11)--(v5);
	
	\draw[color=black] (v13)--(v4);
	
	\draw[color=black] (v14)--(v11);
	\draw[color=black] (v14)--(v12);
	
	\draw[color=black] (v15)--(v9);
	\draw[color=black] (v15)--(v10);
	
	\draw[color=black] (v16)--(v13);
	\draw[color=black] (v16)--(v14);
	\draw[color=black] (v16)--(v15);
	
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = below: $v_{3}$] 	at (v3)  {};
	\node[vertex] [label = below: $v_{4}$] 	at (v4)  {};
	\node[vertex] [label = below: $v_{5}$] 	at (v5)  {};
	\node[vertex] [label = right: $v_{6}$] 	at (v6)  {};
	\node[vertex] [label = below: $v_{7}$] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = below right: $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	
	%\path (8 , 0.5)    coordinate () {} node[left]	{$G_{3}$} ;			
\end{tikzpicture}
\captionof{figure}{Ordre canonique d'un graphe planaire maximal.} %\includegraphics{images/image1.png}
\label{Ordre canonique d'un graphe planaire maximal.}	
\end{figure}


%============================================================
%			Conditions
%==============================================================	
\subsection{Conditions}
\label{Conditions}
%$\boxed{\text{Ce texte est encadré}}$
Pour un cycle $C$ dans un graphe, une arête joignant deux sommets non consécutifs de $C$ est appelée une corde \ref{Corde} de $C$ (un exemple de graphe cordal est illustré à la figure \ref{figure Graphe cordal}). Pour un graphe planaire $G$ à deux connexions, nous désignons par $C_0(G)$ le cycle extérieur de $G$, c'est-à-dire la frontière de la face extérieure de $G$. Un sommet sur $C_0(G)$ est appelé un sommet extérieur et une arête sur $C_0(G)$ est appelée une arête extérieure. Un graphe plan est intérieurement triangulé si chaque face intérieure est un triangle \citep{TakaoSaidur}.
\\ \\ \\
Supposons que nous avons un graphe planaire maximal triangulé \(G=(V,E) \), avec $n$ sommets, et soit $u_0$, $u_1$, $u_2$ les sommets externes de $G$ dans le sens inverse des aiguilles d'une montre. \textbf{Un ordre canonique} de $G$ (voir Figure) est un ordre \(\pi=(v_{1}, v_{2}, \ldots ,v_k, \ldots ,v_{n}) \) des sommets de $G$ tel que les conditions suivantes sont vérifiées :
\\ \\
\begin{itemize}
\item \textbf{Condition 1}:
\label{C1} 
\\
$v_1$ = $u_1$ , $v_2$ = $u_2$, l'arête ($v_{1}$, $v_{2}$) appartient à laface extérieure du graphe $G$ voir la figure suivante;
\begin{figure}[H]
	\centering		
	\begin{tikzpicture}[scale=.7][c/.style={circle,fill=black,draw,inner sep=3pt}] 
		\path[nodes={text=black}]  
		(0,0)   	coordinate	(v1) 
		(8,0)   	coordinate	(v2)
		(0.3,1.4)	coordinate	(v3)
		(1,2.4)	    coordinate	(v4)
		(2.3,2.1)	coordinate	(v5)
		(3.5,2.1)	coordinate	(v6)
		(4.8,2.1)	coordinate	(v7)
		(6.3,2.5)	coordinate	(v8)
		(7.5,1.5)	coordinate	(v9) ;
		
		\draw[fill = cyan!20!white] (v1)--(v3)--(v4)--(v5)--(v6)--(v7)--(v8)--(v9)--(v2)--(v1);	
		
		\tikzstyle{vertex} = [draw,circle,fill=green!50,inner sep = 3pt]
		\node[vertex] [label = left : \large{$v_{1}$}] 	at (v1)  {};
		\node[vertex] [label = right: \large{$v_{2}$}] 	at (v2)  {};
		\node[vertex] [label = left: ] 	at (v3)  {};
		\node[vertex] [label = left: ] 	at (v4)  {};
		\node[vertex] [label = below: ] 	at (v5)  {};
		\node[vertex] [label = below: ] 	at (v6)  {};
		\node[vertex] [label = below: ] 	at (v7)  {};
		\node[vertex] [label = right: ] 	at (v8)  {};
		\node[vertex] [label = right: ] 	at (v9)  {};
		
		\path 
		(4,.7) coordinate () {} node[left]	{\Large{$G$}};
		
	\end{tikzpicture}	
	\captionof{figure}{Graphe avec l'arête ($v_{1}$, $v_{2}$) qui appartient à la face extérieure}
	\label{Graphe avec l'arête ($v_{1}$, $v_{2}$) qui appartient à la face extérieure}	
\end{figure}
\item \textbf{Condition 2}:
\label{C2} 
\\		
Les sommets \{$v_1$, $v_2$, $\ldots$ ,$v_k$\} induisent un graphe:
\begin{itemize}
\item \textbf{2-connexe} \ref{Graphe 2-connexe} c'est-à-dire que si l'on retire n'importe quel sommet, il reste connecté, voir figure \ref{Graphe non 2-connexe};
\item \textbf{Triangulé intérieurement}, c'est-à-dire chaque arête intérieure doit appartenir à un triangle, voir figure suivante \ref{Graphe $G_{k}$ 2-connexe et triangulé}; 
\item \textbf{Maximal à l'intérieur}, chaque sous-graphe $G_k$ est maximal à l'intérieur, c'est-à-dire, toutes les faces internes de $G_k$ sont des triangles, voir figure suivante \ref{Graphe $G_{k}$ 2-connexe et triangulé}.	
\end{itemize}

\begin{figure}[H]
	\centering		
	\begin{tikzpicture}[scale=.7][c/.style={circle,fill=black,draw,inner sep=3pt}] 
		\path[nodes={text=black}]  
		(0,0)   	coordinate	(v1) 
		(8,0)   	coordinate	(v2)
		(0.3,1.4)	coordinate	(v3)
		(1,2.4)	    coordinate	(v4)
		(2.3,2.1)	coordinate	(v5)
		(3.5,2.1)	coordinate	(v6)
		(4.8,2.1)	coordinate	(v7)
		(6.3,2.5)	coordinate	(v8)
		(7.5,1.5)	coordinate	(v9) ;
		
		\draw[fill = cyan!20!white] (v1)--(v3)--(v4)--(v5)--(v6)--(v7)--(v8)--(v9)--(v2)--(v1);
		\draw[thick,dash dot] (v3)--(v5);
		\draw[thick,dash dot] (v1)--(v5);
		\draw[thick,dash dot] (v1)--(v6);
		\draw[thick,dash dot] (v2)--(v6);
		\draw[thick,dash dot] (v2)--(v7);
		\draw[thick,dash dot] (v9)--(v7);
		
		
		\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
		\node[vertex] [label = left : \large{$v_{1}$}, fill=green!50] 	at (v1)  {};
		\node[vertex] [label = right: \large{$v_{2}$}, fill=green!50] 	at (v2)  {};
		\node[vertex] [label = left: ] 	at (v3)  {};
		\node[vertex] [label = left: ] 	at (v4)  {};
		\node[vertex] [label = below: ] 	at (v5)  {};
		\node[vertex] [label = below: ] 	at (v6)  {};
		\node[vertex] [label = below: ] 	at (v7)  {};
		\node[vertex] [label = right: ] 	at (v8)  {};
		\node[vertex] [label = right: ] 	at (v9)  {};
		
		\path 
		(4,.7) coordinate () {} node[left]	{\Large{$G_{k}$}};
		
	\end{tikzpicture}	
	\captionof{figure}{Graphe $G_{k}$ 2-connexe et triangulé} %\includegraphics{images/image1.png}
	\label{Graphe $G_{k}$ 2-connexe et triangulé}	
\end{figure}
{\color{white}-}
\\
{\color{white}-}
\textbf{Pourquoi le graphe $G_k$ doit-il être 2-connexe ?} 
\\
Considérons l'exemple suivant \ref{Graphe non 2-connexe}  :
\\ \\
\textbf{Exemple:}
\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=.7]
		\path
		(0,0) coordinate (v1)
		(4,0) coordinate (v2)
		(4,4) coordinate (v5)
		(0,4) coordinate (v4)
		(2,2) coordinate (v3);		    
%========  dessins des Arêtes =================			
		\draw (v1)--(v2)--(v3)--(v5)--(v4)--(v3)--(v1);
		\draw[fill = cyan!20!white] (v1)--(v3)--(v2)--cycle;
%========  posisionement des nom des sommets ==========
		\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
		\node[vertex] [label = left : $v_1$, fill=green!50] at (v1) {};
		\node[vertex] [label = right: $v_2$, fill=green!50] at (v2) {};
		\node[vertex] [label = right: $v_5$] at (v5) {};
		\node[vertex] [label = left : $v_4$] at (v4) {};
		\node[vertex] [label = left : $v_3$] at (v3) {};
	\end{tikzpicture}
	\captionof{figure}{Graphe non 2-connexe} 
	\label{Graphe non 2-connexe}
\end{figure}
Si nous effectuons la suppression du sommet $v_3$, le graphe résultant devient disconnexe. En d'autres termes, le graphe se divise en deux parties distinctes qui ne sont pas connectées entre elles. Ce qui viole la propriété essentielle de 2-connexité \ref{Graphe 2-connexe}.
\\
Aussi, Si nous supprimons le sommet $v_5$, une situation similaire se produit. Le graphe se fragmente en plusieurs parties disjointes, ce qui indique que le graphe initial ne satisfait pas la condition de 2-connexité. Il est important de noter qu'il existe au moins deux sommets, $v_3$ et $v_5$, dont la suppression entraîne une déconnexion du graphe, ce qui est en contradiction avec la propriété fondamentale de 2-connexité \ref{Graphe 2-connexe}.
\\
\item \textbf{Condition 3}:
\label{C3} 
Pour \( 3 \leq k \leq n \), soit $G_k$ le sous-graphe plan de $G$ induit par les sommets \(v_{1}, \ldots ,v_k \) et soit $C_k$ la face externe de $G_k$. Le prochain sommet \(v_{k+1}\) que nous souhaitons installer se trouve sur la face $C_k$ \citep[chapitre 4, page 46]{TakaoSaidur}. De plus, si \(k < n\), le sommet $v_k$ a au moins un voisin dans $G \setminus G_k$. Tous ses voisins apparaissent consécutivement\footnote{"Voisins apparaissent consécutivement" signifie que les sommets adjacents (voisins) au sommet en question se présentent les uns à la suite des autres, sans interruption, sur la frontière de la face externe du graphe. Autrement dit, il n'y a pas d'autres sommets entre ces voisins lorsqu'ils sont disposés le long de la frontière.} sur la frontière, pour \(3 \le k \le n \) comme le montre bien la figure \ref{Graphe insértion du sommet $v_{k+1}$} précédente.
\begin{figure}[H]
	\centering		
	\begin{tikzpicture}[c/.style={circle,fill=black,draw,inner sep=3pt}] 
		\path[nodes={text=black}]  
		(0,0)   	coordinate	(v1) 
		(8,0)   	coordinate	(v2)
		(0.3,1.4)	coordinate	(v3)
		(1,2.4)	    coordinate	(v4)
		(2.3,2.1)	coordinate	(v5)
		(3.5,2.1)	coordinate	(v6)
		(4.8,2.1)	coordinate	(v7)
		(6.3,2.5)	coordinate	(v8)
		(7.5,1.5)	coordinate	(v9) 
		(3.5,4  )	coordinate	(vk) 
		;
		
		\draw[fill = cyan!20!white] (v1)--(v3)--(v4)--(v5)--(v6)--(v7)--(v8)--(v9)--(v2)--(v1);
		\draw[line width=2pt, color=red] (v4)--(vk)--(v8);
		\draw[line width=2pt, color=orange] (v5)--(vk)--(v7)--(vk)--(v6);
		
		\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
		\node[vertex] [label = left : \large{$v_{1}$}, fill=green!50] 	at (v1)  {};
		\node[vertex] [label = right: \large{$v_{2}$}, fill=green!50] 	at (v2)  {};
		\node[vertex] [label = left: ] 	at (v3)  {};
		\node[vertex] [label = left:  $w_{p}$] 	at (v4)  {};
		\node[vertex] [label = below: $w_{p+1}$] 	at (v5)  {};
		\node[vertex] [label = below: ] 	at (v6)  {};
		\node[vertex] [label = below: $w_{q-1}$] 	at (v7)  {};
		\node[vertex] [label = right: $w_{q}$] 	at (v8)  {};
		\node[vertex] [label = right: ] 	at (v9)  {};
		\node[vertex] [label = right: \large{$v_{k+1}$}] 	at (vk)  {};
		
		\path 
		(4,.7) coordinate () {} node[left]	{\Large{$G_{k}$}};
		
	\end{tikzpicture}	
	\captionof{figure}{Graphe insértion du sommet $v_{k+1}$}
	\label{Graphe insértion du sommet $v_{k+1}$}	
\end{figure}
\end{itemize}
\bigbreak 	
Ce sont exactement les conditions que l'algorithme de dessin a besoin \citep{PhilippKindermann} \citep{VismaraTamassia}.
\\ \\	
Un ordre canonique de $G$ permet une construction incrémentale du graphe $G$ à partir de l'arête ($v_{1}$, $v_{2}$). À l'étape k, \( 3 \leq k \leq n \), le sommet $v_k$ et les arêtes entre $v_k$ et ses voisins dans $C_{k-1}$ sont ajoutés au graphe courant $G_{k-1}$ (illustré sur la figure suivante en gras). Pour chaque \( 3 \leq k \leq n \), nous notons par \( v_1 = w_1, w_2, ..., w_t = v_2 \) la séquence des sommets de $C_{k-1}$, lorsqu'ils sont parcourus dans l'ordre horaire. Pour faciliter l'intuition, nous visualisons \( w_2, ..., w_{t-1} \) comme étant disposés de gauche à droite au-dessus de \(\{v_1,v_2\}\) dans le plan. 
\\ \\
Pour chaque \( 3 \leq k \leq n \), soit \( w_p, ..., w_q \) la sous-séquence des sommets de $C_{k-1}$ qui sont adjacents à $v_k$ (on note que \(p + 1\) peut être égal à $q$). Après que $v_k$ a été ajouté à $G_{k-1}$, les sommets \( w_{p+1}, ..., w_{q-1} \) \ref{Graphe insértion du sommet $v_{k+1}$} (s'il y en a) ne sont plus externes; nous disons que le sommet $v_k$ couvre ces sommets.
\\ \\
Un ordre canonique \( v_1, ..., v_n \) du graphe $G$ définit un \textbf{spanning tree ou arbre couvrant} du graphe \(G \setminus \{v_1, v_2\} \), appelé \textbf{arbre de couverture}, qui se compose de toutes les arêtes \(\{u,v\}\) telles que $u$ couvre $v$, ce qui signifie que le sommet $u$ est directement relié au sommet $v$ dans l'arbre de couverture du graphe \(G \setminus \{v_1, v_2\} \). Cela indique une relation parent-enfant entre les sommets $u$ et $v$ dans l'arbre de couverture. En d'autres termes, $u$ est un prédécesseur immédiat de $v$ dans l'arborescence induite par l'ordre canonique du graphe planaire maximal.
\\ \\
Nous fixons $v_n$ comme racine de l'arbre de couverture. Ainsi, les enfants d'un sommet $u$ dans l'arbre de couverture sont les sommets couverts par $u$, voir la figure \ref{Arbre de couverture induit par un ordre canonique d'un graphe planaire maximal}. Nous définissons la \textbf{forêt} de couverture associée à un ordre canonique comme étant son arbre de couverture avec les arbres à un seul sommet $v_1$ et $v_2$ \citep{VismaraTamassia}.


\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=.8]
	\path 
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4,6.8)	    coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);	
	
	\draw(v1)--(v3)--(v2)--(v1);			
	
	\draw (v4)--(v13)--(v12);
	\draw (v11)--(v6);
	\draw (v4)--(v11)--(v5);
	
	\draw (v1)--(v2)--(v6);
	\draw (v13)--(v10)--(v4);
	%\draw[line width=2pt, color=green!70!black] (v4)--(v13);
	
	\draw (v13) -- (v15);
	\draw (v16) -- (v15);
	\draw (v16) -- (v14);
	\draw (v14)--(v11)--(v12)--(v14)--(v13);
	
	\draw (v2)--(v3)--(v1); 
	\draw (v3)--(v4)--(v2)--(v3);
	\draw (v4)--(v5)--(v2)--(v4); 
	\draw (v5)--(v6); 
	\draw (v1)--(v7)--(v3)--(v1); 
	\draw (v1)--(v8)--(v7)--(v1); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v12)--(v4);	
	
	\draw (v6) to[bend right=25] (v16); 
	\draw (v1) to[bend left=40]  (v16);
	\draw (v2) to[bend right=40] (v16);
	\draw (v6) to[bend right=20] (v14);
	\draw (v1) to[bend left=25] (v15);
	
	\draw[color=black, line width=2pt] (v10)--(v8);
	\draw[color=black, line width=2pt] (v10)--(v7);
	\draw[color=black, line width=2pt] (v10)--(v3);
	
	\draw[color=black, line width=2pt] (v11)--(v5);
	
	\draw[color=black, line width=2pt] (v13)--(v4);
	
	\draw[color=black, line width=2pt] (v14)--(v11);
	\draw[color=black, line width=2pt] (v14)--(v12);
	
	\draw[color=black, line width=2pt] (v15)--(v9);
	\draw[color=black, line width=2pt] (v15)--(v10);
	
	\draw[color=black, line width=2pt] (v16)--(v13);
	\draw[color=black, line width=2pt] (v16)--(v14);
	\draw[color=black, line width=2pt] (v16)--(v15);
	
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = below: $v_{3}$] 	at (v3)  {};
	\node[vertex] [label = below: $v_{4}$] 	at (v4)  {};
	\node[vertex] [label = below: $v_{5}$] 	at (v5)  {};
	\node[vertex] [label = right: $v_{6}$] 	at (v6)  {};
	\node[vertex] [label = below: $v_{7}$] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = below right : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	
	%\path (8 , 0.5)    coordinate () {} node[left]	{$G_{3}$} ;			
\end{tikzpicture}
\captionof{figure}{Arbre de couverture induit par un ordre canonique d'un graphe planaire maximal. Les arêtes de l'arbre sont dessinées avec des traits épais noir} %\includegraphics{images/image1.png}
\label{Arbre de couverture induit par un ordre canonique d'un graphe planaire maximal}	
\end{figure}

%====================================================================================
%								Exemple
%====================================================================================	
\newpage
\subsection{Exemple}
Dans cette section, nous nous attacherons à établir un ordre canonique. À chaque étape de cette procédure, nous examinerons soigneusement si les trois conditions établies sont continuellement satisfaites. Pour faciliter la compréhension, nous avons utilisé une codification couleur :
\\	
Les sommets de couleur verte ont déjà été ajoutés à l'ordre canonique.
\\
Les sommets de couleur bleue sont ceux qui viennent d'être ajoutés à l'ordre canonique.
\\
Les sommets de couleur orange sont les prochains sommets qui seront ajoutés à l'ordre canonique.
\\
Les arêtes bleues constituent le graphe formé par les sommets qui ont été sélectionnés pour l'ordre canonique.
\\
Les arêtes orange seront incluses dans le graphe à mesure que les sommets orange seront sélectionnés pour l'ordre canonique.
\\ \\
%============================================================================
\textbf{Étape 1:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.9] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A](v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v2)--(v3)--(v1);			
	\draw[line width=2pt, color=blue!50]  (v1)--(v3)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v3)--(v4)--(v2);
	
	\draw (v4)--(v5)--(v2); 
	\draw (v5)--(v6)--(v2)--(v5); 
	\draw (v1)--(v7)--(v3); 
	\draw (v1)--(v8)--(v7)--(v1); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v4)--(v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v5)--(v11)--(v6);
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v4)--(v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: $v_{3}$, fill=blue!50] 	at (v3)  {};
	\node[vertex] [label = below: $v_{4}$, fill=orange] 	at (v4)  {};
	\node[vertex] [label = below: $v_{5}$] 	at (v5)  {};
	\node[vertex] [label = right: $v_{6}$] 	at (v6)  {};
	\node[vertex] [label = below: $v_{7}$] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{3}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{3}$} %\includegraphics{images/image1.png}
\label{Graphe $G_{3}$}	
\end{figure}
Dans la première étape, notre objectif est d'intégrer le sommet $v_3$ (de couleur mauve) à l'ordre canonique, en le positionnant entre ses voisins consécutifs, $v_1$ et $v_2$.
\\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\
\textbf{Condition 2} : Les sommets \{$v_1$, $v_2$, $v_3$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_3$, et toutes les faces internes de sont des triangles.
\end{itemize}
\textbf{Condition 3} : Nous avons $3=k \leq n=16$, et le prochain sommet $v_{k+1}=v_4$ (de couleur orange) se trouve dans la face extérieure. De plus, tous ses voisins, $v_3$ et $v_2$, apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.
\\ \\
%============================================================================
\textbf{Étape 2:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.9] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v3)--(v4)--(v2)--(v1);		
	\draw[line width=2pt, color=blue!50]  (v1)--(v3)--(v4)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v4)--(v5)--(v2);
	
	\draw (v2)--(v3);
	\draw (v5)--(v6)--(v2); 
	\draw (v1)--(v7)--(v3); 
	\draw (v1)--(v8)--(v7)--(v1); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v4)--(v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v5)--(v11)--(v6);
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v4)--(v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: $v_{4}$, fill=blue!50] 	at (v4)  {};
	\node[vertex] [label = below: $v_{5}$, fill=orange] 	at (v5)  {};
	\node[vertex] [label = right: $v_{6}$] 	at (v6)  {};
	\node[vertex] [label = below: $v_{7}$] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{4}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{4}$} 
\label{Graphe $G_{4}$}	
\end{figure}
Dans la seconde étape, nous voulons insérer le sommet $v_4$ à l'ordre canonique, en le positionnant entre les voisins consécutifs, $v_3$ et $v_2$.
\\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\
\textbf{Condition 2} : Les sommets \{$v_1$, $v_2$, $v_3$ ,$v_4$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_4$, et toutes les faces internes de sont des triangles.
\end{itemize}
\textbf{Condition 3} : Nous avons $4=k \leq n=16$, et le prochain sommet $v_{k+1}=v_5$ se trouve dans la face extérieure. Ses voisins, $v_4$ et $v_2$, apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.
\\ \\
%============================================================================
\textbf{Étape 3:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.9] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v3)--(v4)--(v5)--(v2)--(v1);
	\draw[line width=2pt, color=blue!50] (v1)--(v3)--(v4)--(v5)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v5)--(v6)--(v2);
	
	\draw (v1)--(v7)--(v3)--(v2); 
	\draw (v4)--(v2)--(v3);
	\draw (v1)--(v7)--(v3); 
	\draw (v1)--(v8)--(v7)--(v1); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v4)--(v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v5)--(v11)--(v6);
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v4)--(v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: $v_{5}$, fill=blue!50] 	at (v5)  {};
	\node[vertex] [label = right: $v_{6}$, fill=orange] 	at (v6)  {};
	\node[vertex] [label = below: $v_{7}$] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{5}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{5}$} 
\label{Graphe $G_{5}$}	
\end{figure}

Dans la troisième étape, nous voulons insérer le sommet $v_5$ à l'ordre canonique, en le positionnant entre les voisins consécutifs, $v_4$ et $v_2$.
\\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\
\textbf{Condition 2} : Les sommets \{$v_1$, $v_2$, $v_3$, $v_4$ ,$v_5$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_5$, et toutes les faces internes de sont des triangles.
\end{itemize}
\textbf{Condition 3} : Nous avons $v_5=k \leq n=16$, et le prochain sommet $v_{k+1}=v_6$ se trouve dans la face extérieure. Les voisins, $v_5$ et $v_2$, apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.

\newpage
%============================================================================
\textbf{Étape 4:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=.8] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v3)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=blue!50] (v1)--(v3)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v1)--(v7)--(v3);
	
	\draw (v4)--(v2)--(v3);
	\draw (v5)--(v2); 
	\draw (v1)--(v8)--(v7); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v4)--(v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v5)--(v11)--(v6);
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v4)--(v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	%\draw (v1) to[bend left=30] (v16);
	%\draw (v2) to[bend right=30] (v16);
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: $v_{6}$, fill=blue!50] 	at (v6)  {};
	\node[vertex] [label = below: $v_{7}$, fill=orange] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{6}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{6}$} 
\label{Graphe $G_{6}$}	
\end{figure}


%============================================================================
\textbf{Étape 5:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.8] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v7)--(v3)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=blue!50] (v1)--(v7)--(v3)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v1)--(v8)--(v7);
	
	\draw (v4)--(v2)--(v3);
	\draw (v5)--(v2); 
	\draw (v1)--(v3); 
	\draw (v1)--(v9)--(v8);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v4)--(v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v5)--(v11)--(v6);
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v4)--(v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	%\draw (v1) to[bend left=30] (v16);
	%\draw (v2) to[bend right=30] (v16);
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: $v_{7}$, fill=blue!50] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$, fill=orange] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{7}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{7}$} 
\label{Graphe $G_{7}$}	
\end{figure}

\newpage
%============================================================================
\textbf{Étape 6:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.8] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v8)--(v7)--(v3)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=blue!50] (v1)--(v8)--(v7)--(v3)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v1)--(v9)--(v8);
	
	\draw (v4)--(v2)--(v3);
	\draw (v5)--(v2); 
	\draw (v7)--(v1)--(v3);
	\draw (v9)--(v10)--(v8);		
	\draw (v7)--(v10)--(v3); 
	\draw (v4)--(v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v5)--(v11)--(v6);
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v4)--(v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$, fill=blue!50] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$, fill=orange] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{8}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{8}$} 
\label{Graphe $G_{8}$}	
\end{figure}
%============================================================================	
\textbf{Étape 7:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.8] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v9)--(v8)--(v7)--(v3)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=blue!50] (v1)--(v9)--(v8)--(v7)--(v3)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v9)--(v10)--(v4);
	
	\draw (v4)--(v2)--(v3);
	\draw (v5)--(v2); 
	\draw (v7)--(v1)--(v3);
	\draw (v1)--(v8)--(v10);		
	\draw (v7)--(v10)--(v3); 
	\draw (v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v5)--(v11)--(v6);
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v4)--(v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v7)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$, fill=blue!50] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$, fill=orange] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{9}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{9}$} 
\label{Graphe $G_{9}$}	
\end{figure}
Dans la septième étape nous souhaitons insérer le sommet $v_9$ dans l'ordre canonique en le positionnant entre les voisins consécutifs $v_1$ et $v_8$.
\\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\
\textbf{Condition 2} : Les sommets \{$v_1$, \ldots ,$v_9$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_9$, et toutes les faces internes de sont des triangles.
\end{itemize}
\textbf{Condition 3} : Nous avons $v_9=k \leq n=16$, et le prochain sommet $v_{k+1}=v_{10}$ se trouve dans la face extérieure. Et les voisins \(v_9, v_8, v_7, v_3, v_4\) apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.

%============================================================================	
\textbf{Étape 8:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.8] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v9)--(v10)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=blue!50] (v1)--(v9)--(v10)--(v4)--(v5)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v4)--(v11)--(v6);
	
	\draw (v9)--(v8)--(v7)--(v3)--(v4);
	\draw (v4)--(v2)--(v3);
	\draw (v5)--(v2); 
	\draw (v7)--(v1)--(v3);
	\draw (v1)--(v8)--(v10);		
	\draw (v7)--(v10)--(v3); 
	\draw (v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	
	\draw[line width=2pt, color=black] (v10)--(v8);
	\draw[line width=2pt, color=black] (v10)--(v7);
	\draw[line width=2pt, color=black] (v10)--(v3);
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v7)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v8)  {};
	\node[vertex] [label = left : , fill=green!50] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$, fill=blue!50] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$, fill=orange] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{10}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{10}$} 
\label{Graphe $G_{10}$}	
\end{figure}
Nous avons parcouru toutes les étapes précédentes jusqu'à l'étape 8, car elles étaient toutes similaires et ne présentaient aucune particularité. À présent, nous souhaitons insérer le sommet $v_{10}$ à l'ordre canonique, en le positionnant entre les voisins consécutifs, $v_9$ et $v_4$.
\\ \\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\ \\
\textbf{Condition 2} : Les sommets \{$v_1$, \ldots ,$v_{10}$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_{10}$, et toutes les faces internes de sont des triangles.
\\
\end{itemize}
\textbf{Condition 3} : Nous avons $v_{10}=k \leq n=16$, et le prochain sommet $v_{k+1}=v_{11}$ se trouve dans la face extérieure. et les voisins \(v_4, v_5, v_6\) apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.
\\ \\
\textbf{Observation :}
\\
Il convient de noter qu'une observation significative est que le sommet $v_{10}$ remplace les sommets $v_8$, $v_7$, $v_3$ dans la frontière du graphe, ainsi, l'ordre des sommets sur la frontière devient : \( \{v_1, v_9, v_{10}, v_4, v_5, v_6, v_2 \} \)
au lieu de : \( \{v_1, v_9, v_8, v_7, v_3, v_4, v_5, v_6, v_2\} \) 
\\
Donc le sommet \(v_{10}\) sera le parent des enfants \(v_8, v_7\) et \(v_3\) dans l'arbre couvrant.
%================================================================
\\ \\ \\ 
\textbf{Étape 9:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.8] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v9)--(v10)--(v4)--(v11)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=blue!50] (v1)--(v9)--(v10)--(v4)--(v11)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v4)--(v12)--(v11);
	
	\draw (v9)--(v8)--(v7)--(v3)--(v4)--(v5)--(v6);
	\draw (v4)--(v2)--(v3);
	\draw (v5)--(v2); 
	\draw (v7)--(v1)--(v3);
	\draw (v1)--(v8)--(v10);		
	\draw (v7)--(v10)--(v3); 
	\draw (v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v5)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	
	\draw[line width=2pt, color=black] (v10)--(v8);
	\draw[line width=2pt, color=black] (v10)--(v7);
	\draw[line width=2pt, color=black] (v10)--(v3);
	\draw[line width=2pt, color=black] (v11)--(v5);
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v7)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v8)  {};
	\node[vertex] [label = left : , fill=green!50] 	at (v9)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$, fill=blue!50] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$, fill=orange] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{11}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{11}$} 
\label{Graphe $G_{11}$}	
\end{figure}
\textbf{Situation particulière:}
\\ \\
Dans la neuvième étape nous souhaitons insérer le sommet $v_{11}$ à l'ordre canonique, imaginons que nous voudrions le positionnant entre les voisins, $v_{12}$ et $v_6$, On a un problème! 
\\
Car d'abord $v_{12}$ n'apparaît pas sur la frontière! (condition 3) 
\\ \\
Le Graphe n'est pas 2-connexe (condition 2) : Imaginons si on supprime ce sommet $v_{11}$ et en travers le graphe en partant de $v_1$ direction $v_{8}$, $v_{9}$, $v_{4}$, $v_{12}$ on revient vers $v_{4}$, puis on supprime $v_{4}$ on auras le point $v_{12}$ isolé! et c'est situation que nous nous voulons pas!
\\ \\
L'idéal est de le positionnant entre (deux voisins qui appartient à la frontière) comme les voisins, $v_4$ et $v_6$.
\\ \\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\ \\
\textbf{Condition 2} : Les sommets \{$v_1$, \ldots ,$v_{11}$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_{11}$, et toutes les faces internes de sont des triangles.
\\
\end{itemize}
\textbf{Condition 3} : Nous avons $v_{11}=k \leq n=16$, et le prochain sommet $v_{k+1}$=$v_{12}$ se trouve dans la face extérieure. De plus, tous ses voisins, \( v_4, v_11 \), apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.
\\ \\
\textbf{Observation :}
\\
Une remarque à souligner : le sommet $v_{11}$ prend la place de sommet $v_5$ dans la délimitation du graphe. De ce fait, la séquence des sommets se modifie pour devenir : \(\{v_1, v_9, v_{10}, v_4, v_{11}, v_6, v_2\}\) au lieu de la séquence initiale : \(\{v_1, v_9, v_{10}, v_4, v_5, v_6, v_2\}\)
\\
Donc le sommet \(v_{11}\) sera le parent d'enfant \(v_5\) dans l'arbre couvrant.

%============================================================================
\textbf{Étape 10:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.8] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v9)--(v10)--(v4)--(v12)--(v11)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=blue!50] (v1)--(v9)--(v10)--(v4)--(v12)--(v11)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v10)--(v13)--(v12);
	
	\draw (v9)--(v8)--(v7)--(v3)--(v4)--(v5)--(v6);
	\draw (v11)--(v4)--(v2)--(v3);
	\draw (v5)--(v2); 
	\draw (v7)--(v1)--(v3);
	\draw (v1)--(v8)--(v10);		
	\draw (v7)--(v10)--(v3); 
	\draw (v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v5)--(v11)--(v14);
	
	\draw (v16)--(v14)--(v13);
	\draw (v12)--(v14);
	
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	
	\draw[line width=2pt, color=black] (v10)--(v8);
	\draw[line width=2pt, color=black] (v10)--(v7);
	\draw[line width=2pt, color=black] (v10)--(v3);
	\draw[line width=2pt, color=black] (v11)--(v5);
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v7)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v8)  {};
	\node[vertex] [label = left : , fill=green!50] 	at (v9)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v10) {};
	\node[vertex] [label = right: , fill=green!50] 	at (v11) {};
	\node[vertex] [label = left : $v_{12}$, fill=blue!50] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$, fill=orange] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{12}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{12}$} 
\label{Graphe $G_{12}$}	
\end{figure}
Dans la dixième étape nous souhaitons insérer le sommet $v_{12}$ à l'ordre canonique, en le positionnant entre les voisins consécutifs, $v_4$ et $v_{11}$.
\\ \\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\ \\
\textbf{Condition 2} : Les sommets \{$v_1$, \ldots ,$v_{12}$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_{12}$, et toutes les faces internes de sont des triangles.
\\
\end{itemize}
\textbf{Condition 3} : Nous avons $v_{12}=k \leq n=16$, et le prochain sommet $v_{k+1}$=$v_{13}$ se trouve dans la face extérieure. Tous ses voisins \(v_{10}, v_{4}, v_{12}\) apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.
\\ \\
\textbf{Observation :}
\\
Une remarque : Le sommet \(v_{12}\) n'a pas d'enfant dans l'arbre couvrant, de ce fait, la séquence des sommets se modifie pour devenir : \(\{v_1, v_9, v_{10}, v_4, v_{12}, v_{11}, v_6, v_2 \}\) au lieu de la séquence initiale : \(\{v_1, v_9, v_{10}, v_4, v_{11}, v_6, v_2\}\).
%============================================================================

\textbf{Étape 11:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.8] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[fill=cyan!10] (v1)--(v9)--(v10)--(v13)--(v12)--(v11)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=blue!50] (v1)--(v9)--(v10)--(v13)--(v12)--(v11)--(v6)--(v2)--(v1);
	\draw[line width=2pt, color=orange] (v13)--(v14);
	
	\draw (v9)--(v8)--(v7)--(v3)--(v4)--(v5)--(v6);
	\draw (v4)--(v2)--(v3);
	\draw (v5)--(v2); 
	\draw (v7)--(v1)--(v3);
	\draw (v1)--(v8)--(v10);		
	\draw (v7)--(v10)--(v3); 
	\draw (v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v5)--(v11)--(v4);
	\draw (v12)--(v4)--(v10);
	
	\draw (v16)--(v14)--(v11);
	\draw (v12)--(v14);
	
	\draw (v6) to[bend right=25] (v16); 
	\draw[line width=2pt, color=orange] (v6) to[bend right=15] (v14);
	
	\draw[line width=2pt, color=black] (v10)--(v8);
	\draw[line width=2pt, color=black] (v10)--(v7);
	\draw[line width=2pt, color=black] (v10)--(v3);
	\draw[line width=2pt, color=black] (v11)--(v5); 
	\draw[line width=2pt, color=black] (v13)--(v4);
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v7)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v8)  {};
	\node[vertex] [label = left : , fill=green!50] 	at (v9)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v10) {};
	\node[vertex] [label = right: , fill=green!50] 	at (v11) {};
	\node[vertex] [label = left : , fill=green!50] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$, fill=blue!50] 	at (v13) {};		
	\node[vertex] [label = right: $v_{14}$, fill=orange] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{13}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{13}$} 
\label{Graphe $G_{13}$}	
\end{figure}
Dans la onzième étape nous souhaitons insérer le sommet $v_{13}$ à l'ordre canonique, en le positionnant entre les voisins consécutifs, $v_{10}$ et $v_{12}$.
\\ \\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\ \\
\textbf{Condition 2} : Les sommets \{$v_1$, \ldots ,$v_{13}$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_{13}$, et toutes les faces internes de sont des triangles.
\\
\end{itemize}
\textbf{Condition 3} : Nous avons $v_{13}=k \leq n=16$, et le prochain sommet $v_{k+1}$=$v_{14}$ se trouve dans la face extérieure. Et tous ses voisins \(v_{13}, v_{12}, v_{11}, v_{6}\) apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.
\\ \\
\textbf{Observation :}
\\
Une remarque à souligner : le sommet \(v_{13}\) sera le parent d'enfant \(v_4\) dans l'arbre couvrant, ainsi la séquence des sommets se modifie pour devenir : \(\{v_1, v_9, v_{10}, v_{13}, v_{12}, v_{11}, v_6, v_2\}\) au lieu de la séquence initiale : \(\{v_1, v_9, v_{10}, v_4, v_{12}, v_{11}, v_6, v_2\}\).

%============================================================================
\newpage
\textbf{Étape 12:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.9] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C]  (v1) to [bend left=40] (v16);
	\draw[name path=B]  (v2) to [bend right=40] (v16);
	
	\draw[name path=D]  (v6) to [bend right=15] (v14);
	\draw[name path=C, fill=cyan!10] (v6)--(v2)--(v1)--(v9)--(v10)--(v13)--(v14);
	\tikzfillbetween[of=C and D] {fill=cyan!10};
	
	\draw[line width=2pt, color=blue!50] (v1)--(v9)--(v10)--(v13)--(v14);
	
	\draw[line width=2pt, color=orange] (v9)--(v15)--(v13);
	
	\draw (v9)--(v8)--(v7)--(v3)--(v4)--(v5)--(v6);
	\draw (v4)--(v2)--(v3);
	\draw (v5)--(v2)--(v6); 
	\draw (v7)--(v1)--(v3);
	\draw (v1)--(v8)--(v10);		
	\draw (v7)--(v10)--(v3); 
	\draw (v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v15)--(v10);	
	\draw (v15)--(v16)--(v13);
	\draw (v5)--(v11)--(v4);
	\draw (v12)--(v4)--(v10);
	
	\draw (v16)--(v14)--(v11);
	\draw (v12)--(v14);
	\draw (v13)--(v12)--(v11)--(v6);
	
	\draw (v6) to[bend right=25] (v16); 
	\draw[line width=2pt, color=blue!50] (v6) to[bend right=15] (v14); 
	
	\draw[line width=2pt, color=black] (v10)--(v8);
	\draw[line width=2pt, color=black] (v10)--(v7);
	\draw[line width=2pt, color=black] (v10)--(v3);
	\draw[line width=2pt, color=black] (v11)--(v5); 
	\draw[line width=2pt, color=black] (v13)--(v4);
	\draw[line width=2pt, color=black] (v14)--(v12);
	\draw[line width=2pt, color=black] (v14)--(v11);
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v7)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v8)  {};
	\node[vertex] [label = left : , fill=green!50] 	at (v9)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v10) {};
	\node[vertex] [label = right: , fill=green!50] 	at (v11) {};
	\node[vertex] [label = left : , fill=green!50] 	at (v12) {};			
	\node[vertex] [label = above left: , fill=green!50] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$, fill=blue!50] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$, fill=orange] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{14}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{14}$} 
\label{Graphe $G_{14}$}	
\end{figure}
Dans la douzième étape nous souhaitons insérer le sommet $v_{14}$ à l'ordre canonique, en le positionnant entre les voisins consécutifs, $v_{13}$ et $v_{6}$.
\\ \\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\ \\
\textbf{Condition 2} : Les sommets \{$v_1$, \ldots ,$v_{14}$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_{14}$, et toutes les faces internes de sont des triangles.
\\
\end{itemize}
\textbf{Condition 3} : Nous avons $v_{14}=k \leq n=16$, et le prochain sommet $v_{k+1}$=$v_{15}$ se trouve dans la face extérieure. De plus, tous ses voisins, \(v_{9}, v_{10}, v_{13}\) apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.
\\ \\
\textbf{Observation :}
\\
Une remarque à souligner : le sommet \(v_{14}\) sera le parent des enfants \(v_{12}, v_{11}\) dans l'arbre couvrant, ainsi la séquence des sommets se modifie pour devenir : \(\{v_1, v_9, v_{10}, v_{13}, v_{14}, v_{6}, v_2\}\) au lieu de la séquence initiale : \(\{v_1, v_9, v_{10}, v_{13}, v_{12}, v_{11}, v_6, v_2\}\).

%============================================================================
\newpage
\textbf{Étape 13:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.9] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C, line width=2pt, color=orange]  (v1) to [bend left=40] (v16);
	\draw[name path=B, line width=2pt, color=orange]  (v2) to [bend right=40] (v16);
	
	\draw[name path=A]  (v9) to (v9);
	\draw[name path=B]  (v1) to [bend left=25] (v15);
	\tikzfillbetween[of=A and B] {fill=cyan!10};
	
	\draw[name path=C]  (v11) to (v11);
	\draw[name path=D]  (v6) to [bend right=15] (v14);
	\tikzfillbetween[of=C and D] {fill=cyan!10};
	
	\draw[fill=cyan!10] (v1)--(v9)--(v15)--(v13)--(v14)--(v11)--(v6)--(v2)--(v1);
	
	\draw[line width=2pt, color=blue!50] (v1) to[bend left=25] (v15); 
	\draw[line width=2pt, color=blue!50] (v15)--(v13)--(v14);
	\draw[line width=2pt, color=blue!50] (v6) to[bend right=15] (v14); 
	\draw[line width=2pt, color=blue!50] (v6)--(v2);
	
	\draw (v1)--(v2)--(v3)--(v1); 
	\draw (v3)--(v4)--(v2)--(v3);
	\draw (v4)--(v5)--(v2)--(v4); 
	\draw (v6)--(v5)--(v2); 
	\draw (v1)--(v7)--(v3)--(v1); 
	\draw (v1)--(v8)--(v7)--(v1); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v4)--(v10)--(v13)--(v4);	
	
	\draw (v9)--(v15)--(v10);	
	\draw (v5)--(v11)--(v6);
	\draw (v15)--(v16)--(v13);
	\draw (v4)--(v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	
	
	\draw[line width=2pt, color=black] (v10)--(v8);
	\draw[line width=2pt, color=black] (v10)--(v7);
	\draw[line width=2pt, color=black] (v10)--(v3);
	\draw[line width=2pt, color=black] (v11)--(v5); 
	\draw[line width=2pt, color=black] (v13)--(v4);
	\draw[line width=2pt, color=black] (v14)--(v12);
	\draw[line width=2pt, color=black] (v14)--(v11);
	\draw[line width=2pt, color=black] (v15)--(v10);
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v7)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v8)  {};
	\node[vertex] [label = left : , fill=green!50] 	at (v9)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v10) {};
	\node[vertex] [label = right: , fill=green!50] 	at (v11) {};
	\node[vertex] [label = left : , fill=green!50] 	at (v12) {};			
	\node[vertex] [label = above left: , fill=green!50] 	at (v13) {};			
	\node[vertex] [label = right: , fill=green!50] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$, fill=blue!50] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$, fill=orange] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{15}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{15}$} 
\label{Graphe $G_{15}$}	
\end{figure}
Dans la treizième étape nous souhaitons insérer le sommet $v_{15}$ à l'ordre canonique, en le positionnant entre les voisins consécutifs, $v_{1}$ et $v_{13}$.
\\ \\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\ \\
\textbf{Condition 2} : Les sommets \{$v_1$, \ldots ,$v_{15}$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_{15}$, et toutes les faces internes de sont des triangles.
\\
\end{itemize}
\textbf{Condition 3} : Nous avons $v_{15}=k \leq n=16$, et le prochain sommet $v_{k+1}$=$v_{16}$ se trouve dans la face extérieure. Et tous ses voisins \(v_{15}, v_{13}, v_{14}\), apparaissent consécutivement sur la frontière du graphe.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.
\\ \\
\textbf{Observation :}
\\
Une remarque à souligner : le sommet \(v_{15}\) sera le parent des enfants \(v_{9}, v_{10}\) dans l'arbre couvrant, ainsi la séquence des sommets se modifie pour devenir : \(\{v_1, v_{15}, v_{13}, v_{14}, v_{6}, v_2\}\) au lieu de la séquence initiale : \(\{v_1, v_9, v_{10}, v_{13}, v_{14}, v_{6}, v_2\}\).
%============================================================================
\newpage        
\textbf{Étape 14:}
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=0.9] 
	\path[nodes={text=black}]  
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4.5,6.2)	coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);
	
	\draw[name path=A]  (v1) -- (v2);
	\draw[name path=D]  (v16) to (v16);
	\draw[name path=C, line width=3pt, color=blue!50]  (v1) to [bend left=40] (v16);
	\draw[name path=B, line width=3pt, color=blue!50]  (v2) to [bend right=40] (v16);
	\tikzfillbetween[of=C and B] {fill=cyan!10};	
	\tikzfillbetween[of=A and D] {fill=cyan!10};
	
	\draw (v1)--(v2)--(v3)--(v1); 
	\draw (v3)--(v4)--(v2)--(v3);
	\draw (v4)--(v5)--(v2)--(v4); 
	\draw (v5)--(v6)--(v2)--(v5); 
	\draw (v1)--(v7)--(v3)--(v1); 
	\draw (v1)--(v8)--(v7)--(v1); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v4)--(v10)--(v13)--(v4);	
	\draw (v1) to[bend left=25] (v15); 
	\draw (v9)--(v15)--(v10);	
	\draw (v5)--(v11)--(v6);
	\draw (v15)--(v16)--(v13)--(v15);
	\draw (v4)--(v11)--(v5);
	\draw (v4)--(v12)--(v11)--(v14);
	\draw (v16)--(v14)--(v13);
	\draw (v13)--(v12)--(v14);
	\draw (v6) to[bend right=25] (v16); 
	\draw (v6) to[bend right=15] (v14); 
	
	
	\draw[line width=2pt, color=black] (v10)--(v8);
	\draw[line width=2pt, color=black] (v10)--(v7);
	\draw[line width=2pt, color=black] (v10)--(v3);
	\draw[line width=2pt, color=black] (v11)--(v5); 
	\draw[line width=2pt, color=black] (v13)--(v4);
	\draw[line width=2pt, color=black] (v14)--(v12);
	\draw[line width=2pt, color=black] (v14)--(v11);
	\draw[line width=2pt, color=black] (v15)--(v10);
	\draw[line width=2pt, color=black] (v16)--(v15);
	\draw[line width=2pt, color=black] (v16)--(v13);
	\draw[line width=2pt, color=black] (v16)--(v14);
	
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = above: , fill=green!50] 	at (v3)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v4)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v5)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v6)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v7)  {};
	\node[vertex] [label = below: , fill=green!50] 	at (v8)  {};
	\node[vertex] [label = left : , fill=green!50] 	at (v9)  {};
	\node[vertex] [label = right: , fill=green!50] 	at (v10) {};
	\node[vertex] [label = right: , fill=green!50] 	at (v11) {};
	\node[vertex] [label = left : , fill=green!50] 	at (v12) {};			
	\node[vertex] [label = above left: , fill=green!50] 	at (v13) {};			
	\node[vertex] [label = right: , fill=green!50] 	at (v14) {};
	\node[vertex] [label = left : , fill=green!50] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$, fill=blue!50] 	at (v16) {};			
	\path (8 , 0.6)    coordinate () {} node[left]	{$G_{16}$} ;					
\end{tikzpicture}	
\captionof{figure}{Graphe $G_{16}$} 
\label{Graphe $G_{16}$}	
\end{figure}
Dans la treizième étape nous souhaitons insérer le sommet $v_{16}$ à l'ordre canonique, en le positionnant entre les voisins consécutifs, $v_{1}$ et $v_{2}$.
\\ \\
\textbf{Condition 1} : L'arête \( (v_1,v_2) \) appartient à la face extérieure du graphe.
\\ \\
\textbf{Condition 2} : Les sommets \{$v_1$, \ldots ,$v_{16}$\} induisent un graphe qui est :
\begin{itemize}
\item Biconnexe (ou 2-connexe),nous observons qu'en éliminant n'importe quel sommet, le graphe demeure connecté.
\item Triangulé intérieurement : chaque arête interne appartient à un triangle.
\item Maximal intérieurement pour chaque sous-graphe de $G_{16}$, et toutes les faces internes de sont des triangles.
\\
\end{itemize}
\textbf{Condition 3} : Nous avons $v_{16}=k \leq n=16$, nous n'avons pas de prochain sommet.
\\
Ainsi, nous constatons que les trois conditions sont bien respectées.
\\ \\
\textbf{Observation :}
\\
Une remarque à souligner : le sommet \(v_{16}\) sera le parent des enfants \(v_{15}, v_{13}, v_{14}\) dans l'arbre couvrant, ainsi la séquence des sommets se modifie pour devenir : \(\{v_1, v_{16}, v_2 \}\) au lieu de la séquence initiale : \(\{ v_1, v_{15}, v_{13}, v_{14}, v_{6}, v_2 \}\).

%===============================================================================
%               Partie ajoutée du pseudo code de ordre canonique
%===============================================================================
\newpage
\subsection{Pseudo code de l'Ordre Canonique}
L'ordre canonique est un concept essentiel en théorie des graphes qui permet de déterminer un ordre linéaire des sommets d'un graphe planaire. Cela permet de représenter graphiquement la structure du graphe de manière ordonnée, ce qui facilite son analyse et sa compréhension. Les algorithmes de l'ordre canonique sont conçus pour être efficaces, garantissant un temps d'exécution linéaire et les rendant adaptés aux graphes de grande taille. Ils utilisent des marqueurs de sommets, des sommets externes et des corde pour établir l'ordre correct des sommets et maintenir la cohérence planaire du graphe. En résumé, l'ordre canonique permet d'obtenir une représentation structurée et systématique des sommets d'un graphe planaire, favorisant ainsi une meilleure analyse et compréhension de sa connectivité.
\\ \\
L'algorithme suivant \citep{TakaoSaidur} permet de calculer un ordre canonique pour un graphe plan triangulé $G = (V, E)$. Pour chaque sommet $v$, nous utilisons les variables suivantes :
\begin{enumerate}
    \item mark($v$) : indique si $v$ a été ajouté à l'ordre (true) ou non (false).
    \item out($v$) : indique si $v$ est un sommet extérieur du graphe plan actuel (true) ou non (false).
    \item corde($v$) : le nombre de cordes du cycle extérieur dont $v$ est l'extrémité.
\end{enumerate}
{\color{white}-} 
\\ 
{\color{white}-} 
\begin{algorithm}[H]
\label{pseudoCode}
\KwInput{(Graphe $G = (V, E)$, ($v_1$, $v_2$, $v_n$))}
\KwOutput{(Ordre canonique des sommets)}
\Begin{
\tcp{Initialisation}
\For{chaque sommet $v$ dans $V$}{
corde($v$) $\leftarrow$ 0; \tcp{Initialiser le nombre de corde du sommet $v$ à 0}
out($v$) $\leftarrow$ false; \tcp{Marquer le sommet $v$ comme n'étant pas un sommet externe}
mark($v$) $\leftarrow$ false; \tcp{Marquer le sommet $v$ comme n'ayant pas été ajouté à l'ordre canonique}
}
mark($v1$) $\leftarrow$ true;
mark($v2$) $\leftarrow$ true;
out($v1$) $\leftarrow$ true;
out($v2$) $\leftarrow$ true; \\
out($vn$) $\leftarrow$ true; \\

\tcp{Construction de l'ordre canonique}
\For{k de $n$ à 3}{
	choisir $v$ tel que mark($v$) = false, out($v$) = true et corde($v$) = 0\; 
	$v_k \leftarrow v$, mark($v$) $\leftarrow$ true; 
 
	\tcp{Détermination des voisins}
	$w1 = v1, w2, \dots, wt-1, wt = v2$\;
	Notation: $wp, \dots, wq$ désigne les voisins de $v_k$\;
        mark($w_i$) = false; 

	\tcp{Mise à jour des sommets et de leurs voisins}
	\For{chaque sommet $wi$ avec $p < i < q$}{
		out($wi$) $\leftarrow$ true; \tcp{ Marquer le sommet $wi$ comme un sommet externe}
		Mettre à jour le nombre de corde pour $wi$ et ses voisins\;
	}
}
}
\caption{Pseudo code de l'Ordre Canonique}
\end{algorithm}

\textbf{Explication}
\\ \\
la ligne 6 : Marquer les sommets $v_1$, $v_2$, $v_n$ comme true pour mark($v$) et out($v$), car ce sont les sommets externes du graphe initial.
\\
la ligne 9 : Cela garantit que nous sélectionnons un sommet qui n'a pas encore été ajouté à l'ordre canonique et qui est un sommet externe sans corde.
\\
La ligne 10 : Assigner $v_k = v$ et marquer v comme true pour indiquer qu'il a été ajouté à l'ordre canonique.
\\
La line 11 : Définir $w1 = v1, w2, \dots, wt-1, wt = v2$ comme les sommets délimitant le bord de $G_{k-1}$. Ces sommets serviront de référence pour trouver les voisins de $v_k$.
\\
La ligne 12 et 13 : 
Trouver $w_p$, $w_{p+1}$, ..., $w_q$ qui sont les voisins de $v_k$ et ont mark($w_i$) = false. Ces sommets sont les voisins non ajoutés de $v_k$ et se trouvent entre les sommets $w_1$ et $w_t$ dans l'ordre canonique précédent.
\\
La dernière boucle à la ligne 14 pour chaque sommet $w_i$ :
\\
La ligne 15 : Marquer le sommet $w_i$ comme un sommet externe
\\
La ligne 16 : Mettre à jour le nombre de corde pour $w_i$ et ses voisins. Cela peut nécessiter de parcourir les arêtes du graphe pour vérifier les connexions entre les sommets et mettre à jour les valeurs de corde en conséquence. Cette mise à jour permet de garder une trace du nombre de corde pour chaque sommet externe.
%===============================================================================
%===============================================================================
\newpage 
\section{Shift method}
\label{Shift méthode}
\subsection{Conditions pour dessiner des invariants}
\label{Condition pour dessiner des invariants}
Nous allons maintenant examiner la méthode de \textbf{Shift} qui prend en entrée un \textbf{graphe planaire} et l'\textbf{ordre canonique} que nous avons vu dans la section précédente (bien qu'il existe plusieurs types d'ordres canoniques tels que leftist, rightist, \textit{etc} \citep{EppsteinGansnerEmden}). Cette méthode produit en sortie un graphe selon cet ordre. Cela fonctionne de manière inductive, donc nous souhaitons préserver certains invariants de dessin. Plus précisément, à chaque étape $k$,  on place le sommets $v_k$, avec \( k = \{3, 4, 5, \dots , n\}\), et nous veillons à ce que notre graphe $G_{k-1}$ soit dessiné de telle sorte que $v_1$ se situe exactement à l'origine et $v_2$ se situe aux coordonnées \((2k-6, 0)\). Ainsi, il est dessiné sous la forme d'un segment horizontal, voir la figure suivante;
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.5]	
	\path
	(0,0) coordinate (a)
	(16,0) coordinate (b);			
	\draw (a)--(b);
	\tikzstyle{vertex} = [draw,circle,fill=green!50,inner sep = 3pt]
	\node[vertex] [label = left : $v_1$] at (a) {};
	\node[vertex] [label = right: $v_2$] at (b) {};	
	\path (0.5,-1)  coordinate () {} node[left]{(0,0)} ;
	\path (18,-1)  coordinate () {} node[left]{(2k-6, 0)} ;		
\end{tikzpicture} 
\captionof{figure}{Le graphe $G_{k-1}$ dessiné comme un segement} 
\label{Le graphe $G_{k-1}$ dessiné comme un segement}	
\end{figure}
La frontière du graphe $G_{k-1}$ à l'exception de l'arête \( \{v_1,v_2\} \) est dessiné x-monotone, signifie que pour chaque arête de la frontière de $G_{k-1}$, lorsque nous la suivons de gauche à droite le long de l'axe des abscisses, elle ne se croise pas avec une autre arête et ne change pas de direction horizontale. Cette propriété garantit que les arêtes de la frontière de $G_{k-1}$ sont dessinées de manière ordonnée et cohérente le long de l'axe des abscisses.
\\
De plus, chaque arête est dessinée avec une pente \( \pm 1\) . C'est ainsi que pourrait se présenter la frontière de $G_{k-1}$. 
\\
Supposons maintenant que nous disposions d'un dessin de $G_{k-1}$ respectant toutes ces conditions, voir la figure suivante.
\\ \\
\textbf{Conditions}
\label{Conditions}
\begin{enumerate}
\item $v_1$ se trouve sur (0, 0) et $v_2$ sur (2k-6, 0);
\item Le frontière de $G_{k-1}$ (sauf l'arête $\{v_1, v_2\}$) est dessiné x-monotone;	
\item Chaque arête de la frontière du $G_{k-1}$ (sauf l'arête $\{v_1, v_2\}$) est dessinée avec des pentes de $\pm 1$. 
\end{enumerate} 
{\color{white}-} 
\\ \\
{\color{white}-} 
\textbf{Placement de sommet $v_k$}
\\ \\ 
À l'étape $k$, nous voulons placer notre nouveau sommet $v_k$ comme illustré dans la figure suivante \ref{Le graphe $G_{k-1}$ à l'étape $k-1$, avant de placer le sommet $k$}. Nous avons le voisin le plus à gauche $w_p$ et le voisin le plus à droite $w_q$, et nous devons nous assurer que ces conditions sont toujours respectées. 
\\
\begin{figure}[H]
\centering
\begin{tikzpicture}	[scale=0.8]	
	\path
	(0,0) coordinate (a)
	(1,1) coordinate (c)
	(2,2) coordinate (d)
	(3,1) coordinate (e)
	(4,2) coordinate (f)
	(5,3) coordinate (g)
	(6,4) coordinate (h)
	(7,3) coordinate (i)
	(8,4) coordinate (j)
	(9,3) coordinate (k)
	(10,2) coordinate (l)
	(11,1) coordinate (m)
	(12,2) coordinate (n)
	(13,3) coordinate (o)
	(14,2) coordinate (p)
	(15,1) coordinate (q)			
	(16,0) coordinate (b)
	(7,6) coordinate (vk)
	(3.5,1.5) coordinate (wp)	
	(10.5,1.5) coordinate (wq)	
	;	
	
	\draw [fill = cyan!30!white] (a)--(c)--(d)--(e)--(f)--(g)--(h)--(i)--(j)--(k)--(l)--(m)--(n)--(o)--(p)--(q)--(b)--(a);
	
	\draw[dotted, color=orange, line width=1pt] (wp) to[bend left=50]  (vk);
	\draw[dotted, color=orange, line width=1pt] (f) to[bend left=40]  (vk);
	\draw[dotted, color=orange, line width=1pt] (g) to[bend left=30]  (vk);
	\draw[dotted, color=orange, line width=1pt] (h) to[bend left=20]  (vk);
	\draw[dotted, color=orange, line width=1pt] (i) to[bend left=10]  (vk);
	
	\draw[dotted, color=orange, line width=1pt] (j) to[bend right=10] (vk);
	\draw[dotted, color=orange, line width=1pt] (k) to[bend right=35] (vk);
	\draw[dotted, color=orange, line width=1pt] (l) to[bend right=40] (vk);
	\draw[dotted, color=orange, line width=1pt] (wq) to[bend right=50] (vk);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_1$] at (a) {};
	\node[vertex] [label = right: $v_2$] at (b) {};	
	\node[vertex] [label = left: a] at (c) {};	
	\node[vertex] [label = above: b] at (d) {};
	\node[vertex] [label = below: c] at (e) {};
	\node[vertex] [label = right: d] at (f) {};
	\node[vertex] [label = right: e] at (g) {};
	\node[vertex] [label = below: f] at (h) {};
	\node[vertex] [label = below: g] at (i) {};
	\node[vertex] [label = below: h] at (j) {};
	\node[vertex] [label = left: i] at (k) {};
	\node[vertex] [label = left: j] at (l) {};l
	\node[vertex] [label = below: l] at (m) {};
	\node[vertex] [label = above: m] at (n) {};
	\node[vertex] [label = above: n] at (o) {};
	\node[vertex] [label = right: o] at (p) {};
	\node[vertex] [label = right: s] at (q) {};
	
	\node[vertex] [label = right: $w_p$,fill=orange] at (wp) {};
	\node[vertex] [label = left: $w_q$,fill=orange] at (wq) {};
	
	\node[vertex] [label = above : $v_k$,fill=orange] at (vk) {};
	
	\path (0.5,-0.5)  coordinate () {} node[left]{(0,0)} ;
	\path (17,-0.5)  coordinate () {} node[left]{(2k-6, 0)} ;
	\path (8,1)  coordinate () {} node[left]{$G_{k-1}$} ;
	
\end{tikzpicture} 
\captionof{figure}{Le graphe $G_{k-1}$ à l'étape $k-1$, avant de placer le sommet $k$} 
\label{Le graphe $G_{k-1}$ à l'étape $k-1$, avant de placer le sommet $k$}	
\end{figure} 

{\color{white}-} 
\\ \\ \\ 
{\color{white}-} 
\textbf{Problème de superposition d'arêtes}
\\ \\
La position de $v_k$ est déterminée par l'intersection de la droite passante par $w_p$ avec une pente de $+1$ et de la droite passante par $w_q$ avec une pente de $-1$, comme le montre la figure suivante \ref{La position du sommet $v_k$ sur le graphe $G_{k-1}$ est à l'intersection de la droite passante par $wp$ avec une pente $+1$ et de la droite passante par $w_q$ avec une pente $-1$}.

\begin{figure}[H]
\centering
\begin{tikzpicture}	[scale=0.8]		
	\path
	(0,0) coordinate (a)
	(1,1) coordinate (c)
	(2,2) coordinate (d)
	(3,1) coordinate (e)
	(4.5,2.5) coordinate (f)
	(5,3) coordinate (g)
	(6,4) coordinate (h)
	(7,3) coordinate (i)
	(8,4) coordinate (j)
	(9,3) coordinate (k)
	(9.5,2.5) coordinate (l)
	(11,1) coordinate (m)
	(12,2) coordinate (n)
	(13,3) coordinate (o)
	(14,2) coordinate (p)
	(15,1) coordinate (q)			
	(16,0) coordinate (b)
	(7,6)  coordinate (vk)
	(3.5,1.5) coordinate (wp)	
	(10.5,1.5) coordinate (wq)
	(7,5) coordinate (r)	
	;	
	
	\draw [fill = cyan!30!white] (a)--(c)--(d)--(e)--(f)--(g)--(h)--(i)--(j)--(k)--(l)--(m)--(n)--(o)--(p)--(q)--(b)--(a);
	
	\draw[line width=2pt, color=orange] (wp)--(r)--(wq);
	\draw[->, color=red, line width=2pt] (vk) to[bend left=50] (7,5.1);
	
	\draw[dotted, color=orange, line width=1pt] (wp) to[bend left=50]  (vk);
	\draw[dotted, color=orange, line width=1pt] (f) to[bend left=40]  (vk);
	\draw[dotted, color=orange, line width=1pt] (g) to[bend left=30]  (vk);
	\draw[dotted, color=orange, line width=1pt] (h) to[bend left=20]  (vk);
	\draw[dotted, color=orange, line width=1pt] (i) to[bend left=10]  (vk);
	
	\draw[dotted, color=orange, line width=1pt] (j) to[bend right=10] (vk);
	\draw[dotted, color=orange, line width=1pt] (k) to[bend right=35] (vk);
	\draw[dotted, color=orange, line width=1pt] (l) to[bend right=40] (vk);
	\draw[dotted, color=orange, line width=1pt] (wq) to[bend right=50] (vk);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_1$] at (a) {};
	\node[vertex] [label = right: $v_2$] at (b) {};	
	\node[vertex] [label = left: a] at (c) {};	
	\node[vertex] [label = above: b] at (d) {};
	\node[vertex] [label = below: c] at (e) {};
	\node[vertex] [label = right: d] at (f) {};
	\node[vertex] [label = right: e] at (g) {};
	\node[vertex] [label = below: f] at (h) {};
	\node[vertex] [label = below: g] at (i) {};
	\node[vertex] [label = below: h] at (j) {};
	\node[vertex] [label = left: i] at (k) {};
	\node[vertex] [label = left: j] at (l) {};l
	\node[vertex] [label = below: l] at (m) {};
	\node[vertex] [label = above: m] at (n) {};
	\node[vertex] [label = above: n] at (o) {};
	\node[vertex] [label = right: o] at (p) {};
	\node[vertex] [label = right: s] at (q) {};
	
	\node[vertex] [label = below: r,fill=red] at (r) {};
	
	\node[vertex] [label = right: $w_p$,fill=orange] at (wp) {};
	\node[vertex] [label = left: $w_q$,fill=orange] at (wq) {};
	
	\node[vertex] [label = above : $v_k$,fill=orange] at (vk) {};
	
	\path (0.5,-0.5)  coordinate () {} node[left]{(0,0)} ;
	\path (17,-0.5)  coordinate () {} node[left]{(2k-6, 0)} ;
	\path (8,1)  coordinate () {} node[left]{$G_{k-1}$} ;
	
\end{tikzpicture} 
\captionof{figure}{La position du sommet $v_k$ sur le graphe $G_{k-1}$ est à l'intersection de la droite passante par $wp$ avec une pente $+1$ et de la droite passante par $w_q$ avec une pente $-1$} 
\label{La position du sommet $v_k$ sur le graphe $G_{k-1}$ est à l'intersection de la droite passante par $wp$ avec une pente $+1$ et de la droite passante par $w_q$ avec une pente $-1$}	
\end{figure}
Par conséquent, nous devons placer le sommet à cette position $r$, et là on a un problème, les arêtes \( \{v_k,h\} \), \( \{v_k,i\} \), \( \{v_k,j\} \), \dots seront superposées, donc le dessin n'est plus planaire.
\\ 
Cependant, un avantage de cette situation est que lorsqu'on passe de $G_{k-1}$ à $G_{k}$, cela nous permet d'obtenir deux coordonnées $x$ supplémentaires. Ainsi, nous avons la possibilité de déplacer les sommets.

\newpage
\textbf{Découpages le graphe}
\\
Et donc ce que nous pouvons faire c'est de créer deux coupures : une entre le voisin le plus à gauche et son voisin, et une autre entre le voisin le plus à droite et son voisin, et maintenant, nous déplaçons tous les sommets qui se trouvent à gauche d'une x-coordonnée à gauche $w_p$ et tous les sommets qui se trouvent à droite de cette même coordonnée à droite $w_q$, voir la figure suivante. 


%===========================================================================
%===========================================================================
%		Fin de la 1er partie corrigé
%			Début de la 2eme partie.
%===========================================================================
%===========================================================================


\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8]			
	\path
	(0,0) coordinate (a)
	(1,1) coordinate (c)
	(2,2) coordinate (d)
	(3,1) coordinate (e)
	(4.5,2.5) coordinate (f)
	(5,3) coordinate (g)
	(6,4) coordinate (h)
	(7,3) coordinate (i)
	(8,4) coordinate (j)
	(9,3) coordinate (k)
	(9.5,2.5) coordinate (l)
	(11,1) coordinate (m)
	(12,2) coordinate (n)
	(13,3) coordinate (o)
	(14,2) coordinate (p)
	(15,1) coordinate (q)			
	(16,0) coordinate (b)
	(7,6)  coordinate (vk)
	(3.5,1.5) coordinate (wp)	
	(10.5,1.5) coordinate (wq)
	(7,5) coordinate (r)	
	;							
	
	\draw [fill = cyan!30!white] (a)--(c)--(d)--(e)--(f)--(g)--(h)--(i)--(j)--(k)--(l)--(m)--(n)--(o)--(p)--(q)--(b)--(a);
	
	\draw[line width=2pt, color=orange] (wp)--(r)--(wq);
	\draw[->, color=red, line width=2pt] (vk) to[bend left=50] (7,5.1);
	
	\draw[dotted, color=red, line width=1pt] (wp) to[bend left=50]  (vk);
	\draw[dotted, color=orange, line width=1pt] (f) to[bend left=40]  (vk);
	\draw[dotted, color=orange, line width=1pt] (g) to[bend left=30]  (vk);
	\draw[dotted, color=orange, line width=1pt] (h) to[bend left=20]  (vk);
	\draw[dotted, color=orange, line width=1pt] (i) to[bend left=10]  (vk);
	
	\draw[dotted, color=orange, line width=1pt] (j) to[bend right=10] (vk);
	\draw[dotted, color=orange, line width=1pt] (k) to[bend right=35] (vk);
	\draw[dotted, color=orange, line width=1pt] (l) to[bend right=40] (vk);
	\draw[dotted, color=red, line width=1pt] (wq) to[bend right=50] (vk);
	%coupure========================================
	\draw[black,thick,decorate,decoration={snake,amplitude=0.1cm,segment length=1cm}] (4,5) -- (4,-0.5);			
	\draw[->, color=black, line width=2pt] (3.5,3.5)--(2.5,3.5);
	\draw[->, color=black, line width=2pt] (3.5,3)--(2.5,3);
	\draw[->, color=black, line width=2pt] (3.5,2.5)--(2.5,2.5);
	
	\draw[black,thick,decorate,decoration={snake,amplitude=0.1cm,segment length=1cm}] (10,5) -- (10,-0.5);
	\draw[->, color=black, line width=2pt] (10.5,3.5)--(11.5,3.5);
	\draw[->, color=black, line width=2pt] (10.5,3)--(11.5,3);
	\draw[->, color=black, line width=2pt] (10.5,2.5)--(11.5,2.5);

 \draw[color=red] (wp)--(r);
 \draw[color=red] (wq)--(r);
 \draw[color=red, line width=2pt] (wp)--(f);
 \draw[color=red, line width=2pt] (wq)--(l);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_1$] at (a) {};
	\node[vertex] [label = right: $v_2$] at (b) {};	
	\node[vertex] [label = left: a] at (c) {};	
	\node[vertex] [label = above: b] at (d) {};
	\node[vertex] [label = below: c] at (e) {};
	\node[vertex] [label = right: d,fill=orange] at (f) {};
	\node[vertex] [label = right: e,fill=orange] at (g) {};
	\node[vertex] [label = below: f,fill=orange] at (h) {};
	\node[vertex] [label = below: g,fill=orange] at (i) {};
	\node[vertex] [label = below: h,fill=orange] at (j) {};
	\node[vertex] [label = left: i,fill=orange] at (k) {};
	\node[vertex] [label = left: j,fill=orange] at (l) {};l
	\node[vertex] [label = below: l] at (m) {};
	\node[vertex] [label = above: m] at (n) {};
	\node[vertex] [label = above: n] at (o) {};
	\node[vertex] [label = right: o] at (p) {};
	\node[vertex] [label = right: s] at (q) {};
	
	\node[vertex] [label = below: r,fill=red] at (r) {};
	
	\node[vertex] [label = left: $w_p$,fill=red] at (wp) {};
	\node[vertex] [label = right: $w_q$,fill=red] at (wq) {};
	
	\node[vertex] [label = above : $v_k$,fill=orange] at (vk) {};
	
	\path (0.5,-0.5)  coordinate () {} node[left]{(0,0)} ;
	\path (17,-0.5)  coordinate () {} node[left]{(2k-4, 0)} ;
	\path (8,1)  coordinate () {} node[left]{$G_{k-1}$} ;
	
\end{tikzpicture} 
\captionof{figure}{Illustration de l'idée de décaler la partie gauche vers la gauche, et la partie droite vers la droite du $G_{k-1}$, après avoir découpé le graphe} 
\label{Illustration de l'idée de décaler la partie gauche vers la gauche, et la partie droite vers la droite du $G_{k-1}$, après avoir découpé le graphe}
\end{figure}

{\color{white}-}
\\
{\color{white}-}
\textbf{Reconnexion des arêtes \( \{w_p,v_k\} \) et \( \{w_q,v_k\} \) découpées avant}
\\ \\
Après cela, dans la figure suivante, nous procédons à la reconnexion des deux arêtes \( \{w_p,v_k\} \) et \( \{w_q,v_k\} \). La reconnexion des arêtes est réalisée en les reliant au sommet $v_k$, comme illustré dans la Figure \ref{Insertion du sommet $v_k$ dans le graphe $G_{k-1}$ après le décalage}. Les résultats de cette reconnexion sont prometteurs, montrant une nette amélioration par rapport à l'état précédent. Cependant, il convient de mener davantage d'analyses et de tests pour fournir une évaluation complète de cette méthode.
\begin{figure}[H]
\centering
\begin{tikzpicture}	[scale=0.7]		
%\draw[step=1cm,gray!50,very thin] (-1,-1) grid (19,7);
%	\foreach \x in {1,...,14} {
%		\draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
%	}
%	\foreach \y in {1,2,3,4,5,7} {
%		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
%	}
	\path
	(0,0)      coordinate (a) %v1
	(1,1)      coordinate (c) %a
	(2,2)      coordinate (d) %b
	(3,1)      coordinate (e) %c
	(5.5,2)    coordinate (f) %d
	(6,2.65)   coordinate (g) %e
	(7,4)      coordinate (h) %f
	(8,3)      coordinate (i) %g
	(9,4)      coordinate (j) %h
	(10,2.65)   coordinate (k) %i
	(10.5,2)    coordinate (l) %j
	(13,1)     coordinate (m) %l
	(14,2)     coordinate (n) %m
	(15,3)     coordinate (o) %n
	(16,2)     coordinate (p) %o
	(17,1)     coordinate (q) %s		
	(18,0)     coordinate (b) %v2
	(8,6)      coordinate (vk) %vk
	(4,1.4)  coordinate (wp) %wp
	(12,1.4) coordinate (wq); %wq	;							
	
\draw [fill = cyan!30!white] (a)--(c)--(d)--(e)--(f)--(g)--(h)--(i)--(j)--(k)--(l)--(m)--(n)--(o)--(p)--(q)--(b)--(a);
	
	\draw[color=red, line width=2pt] (wp) -- (vk);
	\draw[color=orange, line width=1pt] (f)--(vk);
	\draw[color=orange, line width=1pt] (g)--(vk);
	\draw[color=orange, line width=1pt] (h)--(vk);
	\draw[color=orange, line width=1pt] (i)--(vk);	
	\draw[color=orange, line width=1pt] (j)--(vk);
	\draw[color=orange, line width=1pt] (k)--(vk);
	\draw[color=orange, line width=1pt] (l)--(vk);
	\draw[color=red, line width=2pt] (wq)--(vk);
 %coupure========================================
\draw[black,thick,decorate,decoration={snake,amplitude=0.1cm,segment length=1cm}] (4.8,3) -- (4.8,-0.3);			
\draw[black,thick,decorate,decoration={snake,amplitude=0.1cm,segment length=1cm}] (11,3) -- (11,-0.3);

	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_1$] at (a) {};
	\node[vertex] [label = right: $v_2$] at (b) {};	
	\node[vertex] [label = left: a] at (c) {};	
	\node[vertex] [label = above: b] at (d) {};
	\node[vertex] [label = below: c] at (e) {};
	\node[vertex] [label = right: d,fill=orange] at (f) {};
	\node[vertex] [label = right: e,fill=orange] at (g) {};
	\node[vertex] [label = below: f,fill=orange] at (h) {};
	\node[vertex] [label = below: g,fill=orange] at (i) {};
	\node[vertex] [label = below: h,fill=orange] at (j) {};
	\node[vertex] [label = left: i,fill=orange] at (k) {};
	\node[vertex] [label = left: j,fill=orange] at (l) {};l
	\node[vertex] [label = below: l] at (m) {};
	\node[vertex] [label = above: m] at (n) {};
	\node[vertex] [label = above: n] at (o) {};
	\node[vertex] [label = right: o] at (p) {};
	\node[vertex] [label = right: s] at (q) {};
		
	%\node[vertex] [label = right: r,fill=red] at (r) {};
	
	\node[vertex] [label = above: $w_p$,fill=red] at (wp) {};
	\node[vertex] [label = above: $w_q$,fill=red] at (wq) {};
	
	\node[vertex] [label = above : $v_k$,fill=orange] at (vk) {};
	
	\path (0.5,-0.7)  coordinate () {} node[left]{(0,0)} ;
	\path (19,-0.7)  coordinate () {} node[left]{(2k-4, 0)} ;
	\path (8,1)  coordinate () {} node[left]{$G_{k-1}$} ;
	
\end{tikzpicture} 
\captionof{figure}{Insertion du sommet $v_k$ dans le graphe $G_{k-1}$ après le décalage} 
\label{Insertion du sommet $v_k$ dans le graphe $G_{k-1}$ après le décalage}
\end{figure}
Eh bien, une dernière chose que nous devons corriger est que nous avons déplacé tout vers la gauche, donc cela serait (-1,0), mais nous pouvons simplement déplacer l'ensemble du graphe vers la droite de 1, et ensuite les conditions 1, 2 et 3 (\ref{Condition pour dessiner des invariants}) sont clairement satisfaites.

{\color{white}-}
\\
{\color{white}-}

\textbf{Position du sommet $v_k$ sur la grille}
\\ \\
Y a des questions que nous devons se poser, pouvons-nous placer $v_k$ dans cette position d'intersection de la droite passante par $wp$ avec une pente $+1$ et de la droite passante par $w_q$ avec une pente $-1$? Pourrait-il se trouver quelque part au milieu entre les lignes de la grille ? comme illustré dans la figure suivante \ref{Exploration d'une possible position du sommet $v_k$ sur la grille (à vérifier)}. Ou sur une ligne verticale (horizontale) de la grille, mais pas sur une ligne horizontale (verticale) de la grille ? Ou l'inverse ? Cependant, nous pouvons montrer qu'il se trouve réellement sur une ligne de la grille. Cela provient de condition 3. 
\begin{figure}[H]
\centering
\begin{tikzpicture}	[scale=0.7]		
\draw[step=1cm,gray!50,very thin] (0,0) grid (6,4);
%\foreach \x in {1,5} { \draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x}; }
%\foreach \y in {1,...,3} {\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y}; }
\path
(2.5,3.5) coordinate (vk) %vk
(1,2)     coordinate (wp) %wp
(5,1)     coordinate (wq); %wq	;							
		
\draw[dotted, color=black, line width=1pt] (wp)--(vk)--(2,4);
\draw[dotted, color=black, line width=1pt] (wq)--(vk)--(3,4);

\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
\node[vertex] [label = below: $w_p$,fill=red] at (wp) {};
\node[vertex] [label = below: $w_q$,fill=red] at (wq) {};	
\node[vertex] [label = above: $v_k$,fill=orange] at (vk) {};

\draw[color=black, line width=1pt, <->] (-0.3,1) -- (-0.3,2);
\draw[color=black, line width=1pt, <->] (1,-0.3) -- (5,-0.3);

\path (-1,1.5)  coordinate () {} node[left]{$Y$} ;
\path (3.5,-1)  coordinate () {} node[left]{$X$} ;

\end{tikzpicture} 
\captionof{figure}{Exploration d'une possible position du sommet $v_k$ sur la grille (à vérifier)} 
\label{Exploration d'une possible position du sommet $v_k$ sur la grille (à vérifier)}
\end{figure}
De plus, pour cela, nous voulons examiner \textbf{la distance de Manhattan}, c'est ce que nous allons voir sur la section suivante.
% ================== Distance de Manhattan =============

\subsection{Distance de Manhattan}
Et on peut déplacer $v_k$ sur cette nouvelle position, nous pouvons montrer qu'il se trouve vraiment sur une ligne de la grille. De plus, cela découle de la condition 3 \ref{Conditions}.
\\ 
La \textbf{distance de Manhattan} entre X et Y, c'est simplement la somme de la distance en X et la distance en Y, voir l'exemple de la figure suivante:
\\
Example, D = |$x_2$ - $x_1$| + |$y_2$ - $y_1$| = |4 - 1| + |2 - 3| = 3 + 1 = 4 
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=.7]
\draw[step=1cm,gray!50,very thin] (0,0) grid (7,4);
\foreach \x in {1,2,3,4} { \draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x}; }
\foreach \y in {1,2,3} {\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y}; }
	\coordinate (wp) at (1,3);
	\coordinate (wq) at (4,2);
        \coordinate (vk) at (4,3);

	\draw[dashed] (wp) -- (vk) -- (wq);

 \tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
\node[vertex] [label = below: $w_p$,fill=red] at (wp) {};
\node[vertex] [label = below: $w_q$,fill=red] at (wq) {};	
\node[vertex] [label = above: $v_k$,fill=orange] at (vk) {};

\draw[color=black, line width=1pt, <->] (1,1) -- (4,1);
\draw[color=black, line width=1pt, <->] (5,2) -- (5,3);
\path (3.5,.6)   coordinate () {} node[left]{$X=3$} ;
\path (7,2.5)  coordinate () {} node[left]{$Y=1$} ;

\end{tikzpicture}
\captionof{figure}{Distance de Manhattan entre $w_p$ et $w_q$} 
\label{Distance de Manhattan entre $w_p$ et $w_q$}	
\end{figure}

\textbf{Démonstration que l'intersection de la droite passant par wp avec une pente $+1$ et de la droite passant par wq avec une pente $-1$ se situe sur une ligne horizontale et une ligne verticale.}

\begin{proof}[Démonstration que l'intersection se situe sur une ligne horizontale/verticale.]
 Et à partir des pentes, il s'ensuit que la distance de Manhattan est paire entre $w_p$ et $w_q$, entre $w_p$ et  $v_k$, ainsi qu'entre $w_q$ et $v_k$. Donc, si nous nous déplaçons du sommet $w_p$ jusqu'à $v_k$ et suivons simplement les segments, à chaque étape, on a une pente de $+1$. Nous parcourons donc le même nombre de coordonnées vers la droite que vers le haut. Donc, entre chaque paire de sommets consécutifs sur la frontière, nous parcourons toujours la même distance en coordonnée $y$ et la même distance en coordonnée $x$. De même lorsque nous nous déplaçons du sommet $v_k$ jusqu'à $w_q$ nous parcourons aussi la même distance en coordonnée $y$ et la même distance en coordonnée $x$. La distance est également paire entre $w_p$ et $w_q$.
%===================================================
%===================================================
\\ \\
Soit \(w_p(x_p, y_p)\) et \(w_q(x_q, y_q)\) les coordonnées de deux points distincts. 
\\
La droite passante par $w_p$ avec une pente $+1$ peut être exprimée par l'équation suivante : 
\[y = x - (x_p - y_p)\]
La droite passante par $w_q$ avec une pente $-1$ peut être exprimée par l'équation suivante : 
\[y = -x + (x_q + y_q)\]
Pour prouver que l'intersection de ces deux droites se situe sur une ligne horizontale et une ligne verticale de la grille, nous devons montrer que les coordonnées de l'intersection satisfont cette propriété.
\\ \\
Pour trouver l'intersection, nous égalons les deux équations :
\[ x - (x_p - y_p) = -x + (x_q + y_q) \]
En simplifiant cette équation, nous obtenons :
\[2x = (x_q + y_q) + (x_p - y_p)\]
Cela signifie que la coordonnée $x$ de l'intersection est la moitié de la somme des coordonnées \(x_q + y_q \) et \( x_p - y_p\).
\\ \\
Maintenant, pour montrer que l'intersection se situe sur une ligne verticale, nous devons montrer que les coordonnées $x$ sont égales. Pour ce faire, nous égalons les deux équations de départ :
\[x - (x_p - y_p) = -x + (x_q + y_q)\]
En simplifiant cette équation, nous obtenons :
\[2x = (x_q + y_q) + (x_p - y_p)\]
Divisons maintenant cette équation par 2 :
\[x = (x_q + y_q + x_p - y_p) / 2\]
Cela montre que les coordonnées $x$ de l'intersection sont égales à la moyenne des coordonnées \(x_q + y_q \) et \( x_p - y_p\)
\\ \\
De même, pour montrer que l'intersection se situe sur une ligne horizontale, nous devons montrer que les coordonnées $y$ sont égales. Pour ce faire, nous substituons la valeur de $x$ trouvée dans l'une des équations de départ. Par exemple, prenons l'équation de la droite passante par $w_p$ :
\[y = x - (x_p - y_p) \]
En substituant x, nous obtenons :
\[y = (x_q + y_q + x_p - y_p) / 2 - (x_p - y_p) \]
En simplifiant cette équation, nous obtenons :
\[y = (x_q + y_q - x_p + y_p) / 2\]
Cette équation montre que les coordonnées $y$ de l'intersection sont égales à la moyenne des coordonnées \(x_q + y_q \) et \( x_p - y_p\).
\\ \\
Ainsi, en montrant que les coordonnées $x$ et $y$ de l'intersection sont égales à la moyenne des coordonnées des points donnés, et que la distance de Manhattan est paire, alors l'intersection des droites passantes par $w_p$ avec une pente $+1$ et par $w_q$ avec une pente $-1$ se situe à la fois sur une ligne horizontale et une ligne verticale de la grille.
{\color{white}-}
\\
{\color{white}-}
\end{proof}


%================================================================
%================================================================

\newpage
\section{Exploration de la Shift method }
\label{Appliquer Shift méthode}
Dans cette section on va voir comment obtenir des dessins de lignes droites des graphes planaires sur une grille grâce à la mise en place de la Shift method, basé sur l'ordre canonique.
\subsection{Dessin avec Shift method}
%============================   G3  ===================================
Prenons l'exemple suivant de l'ordre canonique d'un graphe planaire maximal qu'on a vu précédemment \ref{Ordre canonique d'un graphe planaire maximal de la figure 25}, tous les sommets seront toujours situés sur une grille.
\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=.7]
	\path 
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4,6.8)	    coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,7.5)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	
	(7,10)   	coordinate	(v16);	
	
	\draw(v1)--(v3)--(v2)--(v1);			
	
	\draw (v4)--(v13)--(v12);
	\draw (v11)--(v6);
	\draw (v4)--(v11)--(v5);
	
	\draw (v1)--(v2)--(v6);
	\draw (v13)--(v10)--(v4);
	%\draw[line width=2pt, color=green!70!black] (v4)--(v13);
	
	\draw (v13) -- (v15);
	\draw (v16) -- (v15);
	\draw (v16) -- (v14);
	\draw (v14)--(v11)--(v12)--(v14)--(v13);
	
	\draw (v2)--(v3)--(v1); 
	\draw (v3)--(v4)--(v2)--(v3);
	\draw (v4)--(v5)--(v2)--(v4); 
	\draw (v5)--(v6); 
	\draw (v1)--(v7)--(v3)--(v1); 
	\draw (v1)--(v8)--(v7)--(v1); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v12)--(v4);	
	
	\draw (v6) to[bend right=25] (v16); 
	\draw (v1) to[bend left=40]  (v16);
	\draw (v2) to[bend right=40] (v16);
	\draw (v6) to[bend right=20] (v14);
	\draw (v1) to[bend left=25] (v15);
	
	\draw[color=black] (v10)--(v8);
	\draw[color=black] (v10)--(v7);
	\draw[color=black] (v10)--(v3);
	
	\draw[color=black] (v11)--(v5);
	
	\draw[color=black] (v13)--(v4);
	
	\draw[color=black] (v14)--(v11);
	\draw[color=black] (v14)--(v12);
	
	\draw[color=black] (v15)--(v9);
	\draw[color=black] (v15)--(v10);
	
	\draw[color=black] (v16)--(v13);
	\draw[color=black] (v16)--(v14);
	\draw[color=black] (v16)--(v15);
	
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$, fill=green!50] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$, fill=green!50] 	at (v2)  {};
	\node[vertex] [label = below: $v_{3}$] 	at (v3)  {};
	\node[vertex] [label = below: $v_{4}$] 	at (v4)  {};
	\node[vertex] [label = below: $v_{5}$] 	at (v5)  {};
	\node[vertex] [label = right: $v_{6}$] 	at (v6)  {};
	\node[vertex] [label = below: $v_{7}$] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = below right: $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above left: $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	\node[vertex] [label = above: $v_{16}$] 	at (v16) {};			
	
	%\path (8 , 0.5)    coordinate () {} node[left]	{$G_{3}$} ;			
\end{tikzpicture}
\captionof{figure}{Ordre canonique d'un graphe planaire maximal de la figure 25} %\includegraphics{images/image1.png}
\label{Ordre canonique d'un graphe planaire maximal de la figure 25}	
\end{figure}

%============================   G3  ===================================
Nous voulons insérer les sommets $v_k$, avec \(k={1,2,3....n}\), donc à l'étape $k$ on insère le sommet $v_k$. et pour les étapes 1, 2 et 3, nous avons déjà les trois points qui composent notre graphe, regardons l'étape k=3.
\\ \\
\textbf{Étape k=3:}
\\
Donc pour le graphe $G_3$ on place le sommet $v_3$ à (1,1), et on a $v_1$ à l'origine (0,0), et pour $v_2$ est à (2,0) selon la formule \((2k-4,0)\) pour k=3: \((2 \times k)-4 = 6-4=2\), illustré à la figure \ref{Insertion du sommet $v_4$ avec Shift method}.
\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
	\centering
	\begin{tikzpicture}[scale=0.5]
		\path 
		(0,0)   coordinate	(v1) 
		(8,0)   coordinate	(v2)
		(4,2)   coordinate	(v3) ;	
		
		\draw[fill=cyan!10] (v1)--(v3)--(v2)--(v1);			
		
		\tikzstyle{vertex} = [draw,circle,fill=teal,inner sep = 3pt]
		\node[vertex] [label = left : $v_{1}$] 	at (v1)  {};
		\node[vertex] [label = right: $v_{2}$] 	at (v2)  {};
		\node[vertex] [label = above: $v_{3}$] 	at (v3)  {};
		
		\path (4.7 , .8)    coordinate () {} node[left]	{$G_{3}$} ;			
	\end{tikzpicture}	
	\caption{Ordre canonique du graphe $G_3$}
	\label{fig:img1}
\end{minipage}
\hfill
\begin{minipage}{0.48\linewidth}
	\centering
	\begin{tikzpicture}[scale=0.7]
		\draw[step=1cm,gray!50,very thin] (-1,-1) grid (3,2);
		
		\foreach \x in {0,1,2} {
			\draw (\x,-0.1) -- (\x,0.1) node[anchor=north,yshift=-2mm] {\x};
		}
		
		\coordinate (1) at (0,0);
		\coordinate (2) at (2,0);
		\coordinate (3) at (1,1);
		
		\draw (1)--(2)--(3)--(1);
		
		\tikzstyle{vertex} = [draw,circle,fill=teal,inner sep = 2pt]
		\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
		\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
		\node[vertex] [label = above: $v_{3}$] 	at (3)  {};	
		
	\end{tikzpicture}
	\caption{Insertion du sommet $v_3$ avec Shift method}
	\label{Insertion du sommet $v_4$ avec Shift method}
\end{minipage}	
\end{figure}
Dans le code Java figure en annexe, nous initialisons les valeurs suivantes: \\
\begin{tabularx}{\textwidth}{|*{3}{X|}}
\hline
$v_1$ & $v_2$ & $v_3$ \\
\hline
(0,0) & (2,0) & (1,1) \\
\hline
\end{tabularx}
%============================   G4  ===================================
\\ \\
\textbf{Étape k=4:}
\\
On passe au sommet $v_4$, il faut s'assurer que $v_1$ est à l'origine, et $v_2$ est à $2k-6$, et c'est le cas : \textit{i.e,} \( 2 \times 2-6 = 2 \).
Le sommet $v_4$ il a deux voisins, le $v_3$ et le $v_2$, qui sont montré sur le dessin, on doit d'abord se déplacer selon l'axe des abscisses, les sommets $v_1$ et $v_3$ se trouvent sur la première partie à gauche ils ne bougent pas, et le sommet $v_2$ se trouve dans la troisième partie à droite, il est donc déplacé de 2 unités vers la droite, voir figure suivante \ref{Diagramme},

\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
	\centering
	\begin{tikzpicture}[scale=0.5]
		\path 
		(0,0)   	coordinate	(v1) 
		(15,0)   	coordinate	(v2)
		(7.5,1.5)   coordinate	(v3)		
		(9.5,2)		coordinate	(v4)
		;	
		
		\draw[fill=cyan!10] (v1)--(v3)--(v2)--(v1);			
		
		\draw (v2)--(v4)--(v3);
		\draw (v2)--(v3)--(v1); 
		
		\tikzstyle{vertex} = [draw,circle,fill=teal,inner sep = 3pt]
		\node[vertex] [label = left : $v_{1}$] 	at (v1)  {};
		\node[vertex] [label = right: $v_{2}$] 	at (v2)  {};
		\node[vertex] [label = above left: $v_{3}$] 	at (v3)  {};
		\node[vertex] [label = above: $v_{4}$] 	at (v4)  {};
		
		\path (8 , 0.5)    coordinate () {} node[left]	{$G_{4}$} ;			
	\end{tikzpicture}
	\captionof{figure}{Ordre canonique du graphe $G_{4}$} %\includegraphics{images/image1.png}
	\label{Ordre canonique du graphe $G_{4}$}	
\end{minipage}	
\hfill
\begin{minipage}{0.48\linewidth}
	\centering
	
	\begin{tikzpicture}[scale=0.7]
		\draw[step=1cm,gray!50,very thin] (-1,-1) grid (5,3);
		\foreach \x in {0,1,...,4} {
			\draw (\x,0) -- (\x,0.1) node[anchor=north,yshift=-2mm] {\x};
		}
		\foreach \y in {1,...,2} {
			\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
		}
		
		\coordinate (1) at (0,0);
		\coordinate (2) at (4,0);
		\coordinate (3) at (1,1);
		\coordinate (4) at (2,2);
		
		\draw [fill = cyan!30!white] (1)--(3)--(1,0)--(1);
		
		\draw[red,thick,decorate,dashed] (2)--(4)--(3);
		\draw (1)--(2)--(3)--(1);
		
		\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
		\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
		\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
		\node[vertex] [label = above: $v_{3}$] 	at (3)  {};	
		
		\node[vertex] [label = right: $v_{4}$,fill=orange] at (4) {};	
		
	\end{tikzpicture}
	\captionof{figure}{Diagramme} 
	\label{Diagramme}	
\end{minipage}
\end{figure}
Et on place le nouveau sommet à l'intersection de ces diagonales, le premier avec une pente de $+1$ passante par $v_3$ et le deuxième avec une pente de $-1$ passante par $v_2$, et comme ça nous aurons notre dessin $G_4$.
\\
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe :
\\
\begin{tabularx}{\textwidth}{|*{4}{X|}}
\hline
$v_1$ & $v_2$ & $v_3$ & $v_4$ \\
\hline
(0,0) & (4,0) & (1,1) & (2,2) \\
\hline
\end{tabularx}
{\color{white}-}
\\
{\color{white}-}
%============================   G5  ===================================
\textbf{Étape k=5:}
\\
Pour le sommet $v_5$ on l'insère entre les deux nouveaux voisins $v_4$ et $v_2$, et donc le $v_3$ et $v_4$ se trouvent à gauche, donc tout ce qui est à sa gauche n'est pas déplacé, mais le $v_2$ est déplacé de 2 unités vers la droite, et nous plaçons le $v_5$ sur l'intersection des deux droites le premier avec une pente de $+1$ passante par $v_4$ et le deuxième avec une pente de $-1$ passante par $v_2$, voir la figure suivante:
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.7]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (7,4);
	\foreach \x in {1,...,5} {
		\draw (\x,0) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,...,3} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	
	\coordinate (1) at (0,0);
	\coordinate (2) at (6,0);
	\coordinate (3) at (1,1);
	\coordinate (4) at (2,2);
	\coordinate (5) at (3,3);
	
	\draw [fill = cyan!30!white] (4)--(1)--(2,0);
	
	\draw[red,thick,decorate,dashed] (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = above left: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = left: $v_{4}$] at (4) {};
	\node[vertex] [label = right: $v_{5}$,fill=orange] at (5) {};	
	\path (3.5, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(5)$}} ;
	\path (3.5, -2.5)  coordinate () {} node[left]	{\Large $G_5$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
Les points créés sont :\\
\begin{tabularx}{\textwidth}{|*{5}{X|}}
\hline
$v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ \\
\hline
(0,0) & (6,0) & (1,1) & (2,2) & (3,3) \\
\hline
\end{tabularx}
{\color{white}-}
\\
{\color{white}-}
%============================   G6  ===================================
\textbf{Étape k=6:}
\\
On passe au sommet suivant est le $v_6$ il a deux voisins, le $v_5$ et le $v_2$, on doit d'abord se déplacer selon l'axe des abscisses, les sommets $v_1$, $v_3$, $v_4$ et $v_5$ se trouvent sur la première partie à gauche, ils ne bougent pas, et le sommet $v_2$ se trouve dans la troisième partie à droite, il est donc déplacé de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons le $v_6$ sur l'intersection des deux droites la première avec une pente de $+1$ passante par $v_4$ et la deuxième avec une pente de $-1$ passante par $v_2$, voir la figure suivante:
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=1]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (9,5);
	\foreach \x in {1,...,6} {
		\draw (\x,0) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,...,4} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	
	\coordinate (1) at (0,0);
	\coordinate (2) at (8,0);
	\coordinate (3) at (1,1);
	\coordinate (4) at (2,2);
	\coordinate (5) at (3,3);
	\coordinate (6) at (4,4);
	
	\draw [fill = cyan!30!white] (5)--(1)--(3,0);
	\draw[red,thick,decorate,dashed] (2)--(6)--(5);
	
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = above left: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = left: $v_{4}$] at (4) {};
	\node[vertex] [label = left: $v_{5}$] at (5) {};  
	\node[vertex] [label = right: $v_{6}$,fill=orange] at (6) {};	
	\path (4.5, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(6)$}} ;
	\path (4.5, -2.5)  coordinate () {} node[left]	{\Large $G_6$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
Les points créés sont :\\
\begin{tabularx}{\textwidth}{|*{6}{X|}}
\hline
$v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ & $v_6$ \\
\hline
(0,0) & (8,0) & (1,1) & (2,2) & (3,3) & (4,4) \\
\hline
\end{tabularx}
{\color{white}-}
\\
{\color{white}-}
%============================   G7  ===================================
\textbf{Étape k=7:}
\\
Pour le sommet suivant $v_7$ il a deux voisins, le $v_1$ et le $v_3$, on doit d'abord se déplacer selon l'axe des abscisses, 
le sommet $v_1$ se trouve sur la première partie à gauche, il ne bouge pas, 
et les sommets $v_2$, $v_3$, $v_4$, $v_5$ et $v_6$ se trouvent dans la troisième partie à droite, ils sont déplacés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons le $v_7$ sur l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_1$ et la deuxième avec une pente de $-1$ passante par $v_3$, voir la figure suivante:	
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=.8]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (11,5);
	\foreach \x in {1,...,8} {
		\draw (\x,0) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,...,4} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	
	\coordinate (1) at (0,0);
	\coordinate (2) at (10,0);
	\coordinate (3) at (3,1);
	\coordinate (4) at (4,2);
	\coordinate (5) at (5,3);
	\coordinate (6) at (6,4);
	\coordinate (7) at (2,2);
	
	\draw [fill = cyan!30!white] (3)--(6)--(2)--(3,0);
	\draw[red,thick,decorate,dashed] (1)--(7)--(3);
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below: $v_{3}$] at (3)  {};	
	\node[vertex] [label = left: $v_{4}$] at (4) {};
	\node[vertex] [label = left: $v_{5}$] at (5) {};  
	\node[vertex] [label = left: $v_{6}$] at (6) {};  
	\node[vertex] [label = left: $v_{7}$,fill=orange] at (7) {};	
	\path (2.5, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(7)$}} ;
	\path (4.5, -2.5)  coordinate () {} node[left]	{\Large $G_7$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
Les points créés sont :\\
\begin{tabularx}{\textwidth}{|*{7}{X|}}
\hline
$v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ & $v_6$ & $v_7$ \\
\hline
(0,0) & (10,0) & (3,1) & (4,2) & (5,3) & (6,4) & (2,2) \\
\hline
\end{tabularx}
{\color{white}-}
\\
{\color{white}-}
%============================   G8  ===================================
\textbf{Étape k=8:}
\\
Pour le sommet suivant $v_8$ il a deux voisins, le $v_1$ et le $v_7$, 
on doit d'abord se déplacer selon l'axe des abscisses, 
le sommet $v_1$ se trouve sur la première partie à gauche, il ne bouge pas, 
et les sommets $v_2$, $v_3$, $v_4$, $v_5$, $v_6$ et $v_7$ se trouvent dans la troisième partie à droite, ils sont décalés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons le $v_8$ sur l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_1$ et la deuxième avec une pente de $-1$ passante par $v_7$, voir la figure suivante:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=.8]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (13,5);
	\foreach \x in {3,...,8,12} {
		\draw (\x,0) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,...,4} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	
	\coordinate (1) at (0,0);
	\coordinate (2) at (12,0);
	\coordinate (3) at (5,1);
	\coordinate (4) at (6,2);
	\coordinate (5) at (7,3);
	\coordinate (6) at (8,4);
	\coordinate (7) at (4,2);
	\coordinate (8) at (3,3);            
	
	\draw [fill = cyan!30!white] (7)--(3)--(6)--(2)--(4,0);
	\draw[red,thick,decorate,dashed] (1)--(8)--(7);
	
	\draw (1)--(7)--(3);
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below: $v_{3}$] at (3)  {};	
	\node[vertex] [label = left: $v_{4}$] at (4) {};
	\node[vertex] [label = left: $v_{5}$] at (5) {};  
	\node[vertex] [label = right: $v_{6}$] at (6) {};  
	\node[vertex] [label = right: $v_{7}$] at (7) {};  
	\node[vertex] [label = left: $v_{8}$,fill=orange] at (8) {};	
	\path (3.5, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(8)$}} ;
	\path (5.5, -2.5)  coordinate () {} node[left]	{\Large $G_8$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
Les points créés sont :\\
\begin{tabularx}{\textwidth}{|*{9}{X|}}
\hline
$v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ & $v_6$ & $v_7$ & $v_8$ \\
\hline
(0,0) & (12,0) & (5,1) & (6,2) & (7,3) & (8,4) & (4,2) & (3,3) \\
\hline
\end{tabularx}
{\color{white}-}
\\
{\color{white}-}
%============================   G9  ===================================
\textbf{Étape k=9:}
\\
Pour le sommet suivant $v_9$ il a deux voisins, le $v_1$ et le $v_8$, 
on doit d'abord se déplacer selon l'axe des abscisses, 
le sommet $v_1$ se trouve sur la première partie à gauche, il ne bouge pas, 
et les sommets $v_2$, $v_3$, $v_4$, $v_5$, $v_6$, $v_7$ et $v_8$ se trouvent dans la troisième partie à droite, ils sont décalés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons le $v_9$ à l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_1$ et la deuxième avec une pente de $-1$ passante par $v_8$, voir la figure suivante:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=.8]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (15,5);
	\foreach \x in {1,...,13} {
		\draw (\x,0) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,...,4} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	
	\coordinate (1) at (0,0);
	\coordinate (2) at (14,0);
	\coordinate (3) at (7,1);
	\coordinate (4) at (8,2);
	\coordinate (5) at (9,3);
	\coordinate (6) at (10,4);
	
	\coordinate (7) at (6,2);
	\coordinate (8) at (5,3);
	\coordinate (9) at (4,4);
	
	\draw [fill = cyan!30!white] (8)--(3)--(6)--(2)--(5,0);
	
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);
	
	\draw (1)--(7)--(3);
	\draw (1)--(8)--(7);
	\draw[red,thick,decorate,dashed] (1)--(9)--(8);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = left: $v_{4}$] at (4) {};
	\node[vertex] [label = left: $v_{5}$] at (5) {};
	\node[vertex] [label = right : $v_{6}$] at (6) {};
	\node[vertex] [label = right: $v_{7}$] at (7) {};
	\node[vertex] [label = right: $v_{8}$] at (8) {};	
	\node[vertex] [label = left: $v_{9}$,inner sep = 3pt,fill=orange] at (9) {};
	
	\path (5, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(9)$}} ;
	\path (7.5, -2.5)  coordinate () {} node[left]	{\Large $G_9$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
Les points créés sont :\\
\begin{tabularx}{\textwidth}{|*{9}{X|}}
\hline
$v_1$ & $v_2$ & $v_3$ & $v_4$ & $v_5$ & $v_6$ & $v_7$ & $v_8$ & $v_9$ \\
\hline
(0,0) & (14,0) & (7,1) & (8,2) & (9,3) & (10,4) & (6,2) & (5,3) & (4,4) \\
\hline
\end{tabularx}
{\color{white}-}
\\
{\color{white}-}

%============================   G10  ===================================
\textbf{Étape k=10:}
\\
Pour le sommet suivant $v_{10}$ il a deux voisins, le $v_9$ et le $v_4$, 
on doit d'abord se déplacer selon l'axe des abscisses, 
le sommet $v_1$ et $v_9$ se trouvent sur la première partie à gauche, il ne bouge pas, 
les sommets $v_3$, $v_7$ et $v_8$ sont au milieu ils bougent de $+1$ unité vers la droite,
et les sommets $v_2$, $v_4$, $v_5$ et $v_6$ se trouvent dans la troisième partie à droite, ils sont décalés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons notre $v_{10}$ sur l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_9$ et la deuxième avec une pente de $-1$ passante par $v_4$, voir la figure suivante:
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.65]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (17,7);
	\foreach \x in {1,...,15} {
		\draw (\x,0) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,...,6} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	
	\coordinate (1) at (0,0);
	\coordinate (2) at (16,0);
	\coordinate (3) at (8,1);
	\coordinate (4) at (10,2);
	\coordinate (5) at (11,3);
	\coordinate (6) at (12,4);
	
	\coordinate (7) at (7,2);
	\coordinate (8) at (6,3);
	\coordinate (9) at (4,4);
	
	\coordinate (10) at (6,6);
	
	\draw [fill = orange!30!white] (8)--(3)--(8,0)--(6,0)--(8);
	\draw [fill = cyan!30!white] (9)--(1)--(4,0);
	\draw [fill = cyan!30!white] (10,0)--(2)--(6)--(4);
	
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);
	
	\draw (1)--(7)--(3);
	\draw (1)--(8)--(7);
	\draw (1)--(9)--(8);
	
	\draw[line width=2pt, color=red, dotted] (9)--(10)--(4);
	\draw[line width=2pt, color=orange] (8)--(10)--(7)--(10)--(3);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = left: $v_{4}$] at (4) {};
	\node[vertex] [label = left: $v_{5}$] at (5) {};
	\node[vertex] [label = right : $v_{6}$] at (6) {};
	\node[vertex] [label = below: $v_{7}$] at (7) {};
	\node[vertex] [label = below: $v_{8}$] at (8) {};	
	\node[vertex] [label = left: $v_{9}$] at (9) {};
	\node[vertex] [label = right: $v_{10}$,inner sep = 3pt, fill=orange] at (10) {};
	
	\path (8, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(10)$}} ;
	\path (7.5, -2.5)  coordinate () {} node[left]	{\Large $G_{10}$};
	
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
Les points créés sont :\\
\begin{tabularx}{\textwidth}{|*{10}{X|}}
\hline
$v_1$ & $v_2$  & $v_3$ & $v_4$  & $v_5$  & $v_6$  & $v_7$ & $v_8$ & $v_9$ & $v_{10}$ \\
\hline
(0,0) & (16,0) & (8,1) & (10,2) & (11,3) & (12,4) & (7,2) & (6,3) & (4,4) & (6,6) \\
\hline
\end{tabularx}
{\color{white}-}
\\
{\color{white}-}
%============================   G11  ===================================
\textbf{Étape k=11:}
\\
Pour le sommet suivant $v_{11}$ il a deux voisins, le $v_4$ et le $v_6$, 
on doit d'abord se déplacer selon l'axe des abscisses, 
les sommets $v_1$, $v_3$, $v_4$, $v_7$, $v_8$, $v_9$ et $v_{10}$ se trouvent sur la première partie à gauche, il ne bouge pas, 
le sommet $v_5$ est au milieu il bouge de $+1$ unité vers la droite,
et les sommets $v_2$ et $v_6$ se trouvent dans la troisième partie à droite, ils sont décalés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons notre $v_{11}$ sur l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_4$ et la deuxième avec une pente de $-1$ passante par $v_6$, voir la figure suivante:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.65]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (19,7);
	\foreach \x in {1,...,17} {
		\draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,...,6} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	\coordinate (1) at (0,0);
	\coordinate (2) at (18,0);
	\coordinate (3) at (8,1);
	\coordinate (4) at (10,2);
	\coordinate (5) at (12,3);
	\coordinate (6) at (14,4);
	\coordinate (7) at (7,2);
	\coordinate (8) at (6,3);
	\coordinate (9) at (4,4);		
	\coordinate (10) at (6,6);	
	\coordinate (11) at (13,5);
	
	\draw [line width=2pt, color=orange] (11)--(5);
	\draw[line width=2pt, color=red, dotted] (4)--(11)--(6);
	\draw [fill = cyan!30!white] (1)--(10)--(4)--(10,0)--(1);
	\draw [fill = cyan!30!white] (2)--(6)--(14,0)--(2);
	\draw [fill = orange!30!white] (11,0)--(11,2.5)--(13,3.5)--(13,0)--(11,0);
	
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);
	\draw (1)--(7)--(3);
	\draw (1)--(8)--(7);
	\draw (1)--(9)--(8);
	\draw (9)--(10)--(4);
	\draw (8)--(10)--(7)--(10)--(3);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = above: $v_{4}$] at (4) {};
	\node[vertex] [label = below: $v_{5}$] at (5) {};
	\node[vertex] [label = right : $v_{6}$] at (6) {};
	\node[vertex] [label = below: $v_{7}$] at (7) {};
	\node[vertex] [label = below: $v_{8}$] at (8) {};	
	\node[vertex] [label = left: $v_{9}$] at (9) {};
	\node[vertex] [label = above: $v_{10}$] at (10) {};
	\node[vertex] [label = above: $v_{11}$,inner sep = 3pt, fill=orange] at (11) {};
	
	\path (13, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(11)$}} ;
	\path (9.5, -2.5)  coordinate () {} node[left]	{\Large $G_{11}$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
Les points créés sont :\\ \\
\begin{tabularx}{\textwidth}{|*{11}{X|}}
\hline
$v_1$ & $v_2$  & $v_3$ & $v_4$  & $v_5$  & $v_6$  & $v_7$ & $v_8$ & $v_9$ & $v_{10}$ & $v_{11}$ \\
\hline
(0,0) & (18,0) & (8,1) & (10,2) & (12,3) & (14,4) & (7,2) & (6,3) & (4,4) & (6,6)    & (13,13) \\
\hline
\end{tabularx}
{\color{white}-}
\\ \\
{\color{white}-}
%============================   G12  ===================================
\textbf{Étape k=12:}
\\
Pour le sommet suivant $v_{12}$ il a deux voisins, le $v_4$ et le $v_{11}$,
on doit d'abord se déplacer selon l'axe des abscisses, 
les sommets $v_1$, $v_3$, $v_4$, $v_7$, $v_8$, $v_9$ et $v_{10}$ se trouvent sur la première partie à gauche, il ne bouge pas, 	
et les sommets $v_2$, $v_5$, $v_6$ et $v_{11}$ se trouvent dans la troisième partie à droite, ils sont décalés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons notre $v_{12}$ sur l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_4$ et la deuxième avec une pente de $-1$ passante par $v_{11}$, voir la figure suivante:
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.7]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (21,7);
	\foreach \x in {1,...,20} {
		\draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,...,6} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	\coordinate (1) at (0,0);
	\coordinate (2) at (20,0);
	\coordinate (3) at (8,1);
	\coordinate (4) at (10,2);
	\coordinate (5) at (14,3);
	\coordinate (6) at (16,4);
	\coordinate (7) at (7,2);
	\coordinate (8) at (6,3);
	\coordinate (9) at (4,4);		
	\coordinate (10) at (6,6);	
	\coordinate (11) at (15,5);
	\coordinate (12) at (14,6);
	
	\draw [fill = cyan!30!white] (1)--(10)--(4)--(10,0)--(1);
	\draw [fill = cyan!30!white] (5)--(11)--(2)--(14,0)--(5);
	%\draw [fill = orange!30!white] (11,0)--(11,2.5)--(13,3.5)--(13,0)--(11,0);
	
	\draw[line width=2pt, color=red, dotted] (4)--(12)--(11);
	\draw (11)--(5);
	\draw (4)--(11)--(6);
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);
	\draw (1)--(7)--(3);
	\draw (1)--(8)--(7);
	\draw (1)--(9)--(8);
	\draw (9)--(10)--(4);
	\draw (8)--(10)--(7)--(10)--(3);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below left: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = above: $v_{4}$] at (4) {};
	\node[vertex] [label = below left: $v_{5}$] at (5) {};
	\node[vertex] [label = right : $v_{6}$] at (6) {};
	\node[vertex] [label = below: $v_{7}$] at (7) {};
	\node[vertex] [label = below: $v_{8}$] at (8) {};	
	\node[vertex] [label = left: $v_{9}$] at (9) {};
	\node[vertex] [label = above: $v_{10}$] at (10) {};
	\node[vertex] [label = above: $v_{11}$] at (11) {};
	\node[vertex] [label = above: $v_{12}$,inner sep = 3pt, fill=orange] at (12) {};
	
	\path (14.5, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(12)$}} ;
	\path (9.5, -2.5)  coordinate () {} node[left]	{\Large $G_{12}$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
Les points créés sont :\\ \\
\begin{tabularx}{\textwidth}{|*{12}{X|}}
\hline
$v_1$ & $v_2$  & $v_3$ & $v_4$  & $v_5$  & $v_6$  & $v_7$ & $v_8$ & $v_9$ & $v_{10}$ & $v_{11}$ & $v_{12}$ \\
\hline
(0,0) & (20,0) & (8,1) & (10,2) & (14,3) & (16,4) & (7,2) & (6,3) & (4,4) & (6,6)    & (15,5)   & (14,6) \\
\hline
\end{tabularx}
{\color{white}-}
\\ \\
{\color{white}-}

%============================   G13  ===================================
\newpage
\textbf{Étape k=13:}
\\
Pour le sommet suivant $v_{13}$ il a deux voisins, le $v_{10}$ et le $v_{12}$,
on doit d'abord se déplacer selon l'axe des abscisses, 
les sommets $v_1$, $v_3$, $v_7$, $v_8$, $v_9$ et $v_{10}$ se trouvent sur la première partie à gauche, il ne bouge pas, 	
le sommet $v_4$ au milieu bouge de $+1$ unité vers la droite,
et les sommets $v_2$, $v_5$, $v_6$, $v_{11}$ et $v_{12}$ se trouvent dans la troisième partie à droite, ils sont décalés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons notre $v_{13}$ sur l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_{10}$ et la deuxième avec une pente de $-1$ passante par $v_{12}$, voir la figure suivante:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.6]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (23,12);
	\foreach \x in {1,4,6,7,8,11,...,15,16,17,18,22} {
		\draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,...,6,9,11} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	
	
	\coordinate (1) at (0,0);
	\coordinate (2) at (22,0);
	\coordinate (3) at (8,1);
	\coordinate (4) at (11,2);
	\coordinate (5) at (16,3);
	\coordinate (6) at (18,4);
	\coordinate (11) at (17,5);
	\coordinate (12) at (16,6);
	
	\coordinate (7) at (7,2);
	\coordinate (8) at (6,3);
	\coordinate (9) at (4,4);		
	\coordinate (10) at (6,6);
	
	\coordinate (13) at (11,11);
	
	\draw [line width=2pt, color=orange] (13)--(4);
	\draw[line width=2pt, color=red, dotted] (12)--(13)--(10);
	\draw [fill = cyan!30!white] (1)--(10)--(3)--(8,0)--(1);
	\draw [fill = cyan!30!white] (2)--(12)--(14,4.4)--(14,0)--(2);
	\draw [fill = orange!30!white] (9,0)--(9,3.6)--(4)--(13,3.6)--(13,0);
	
	\draw (4)--(11)--(12)--(4);
	\draw (6)--(11)--(5);
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);
	
	\draw (1)--(7)--(3);
	\draw (1)--(8)--(7);
	\draw (1)--(9)--(8);
	
	\draw (9)--(10)--(4);
	\draw (8)--(10)--(7)--(10)--(3);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below left: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = below: $v_{4}$] at (4) {};
	\node[vertex] [label = below: $v_{5}$] at (5) {};
	\node[vertex] [label = right: $v_{6}$] at (6) {};
	\node[vertex] [label = below: $v_{7}$] at (7) {};
	\node[vertex] [label = below: $v_{8}$] at (8) {};	
	\node[vertex] [label = left:  $v_{9}$] at (9) {};
	\node[vertex] [label = left: $v_{10}$] at (10) {};
	\node[vertex] [label = right: $v_{11}$] at (11) {};
	\node[vertex] [label = right: $v_{12}$] at (12) {};
	\node[vertex] [label = right: $v_{13}$,inner sep = 3pt, fill=orange] at (13) {};
	
	\path (12, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(13)$}} ;
	\path (11.5, -2.5)  coordinate () {} node[left]	{\Large $G_{13}$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
\begin{tabularx}{\textwidth}{|*{8}{X|}}
\hline
$v_1$ & $v_2$  & $v_3$ & $v_4$  & $v_5$  & $v_6$  & $v_7$ & $v_8$ \\
\hline 
(0,0) & (22,0) & (8,1) & (11,2) & (16,3) & (18,4) & (7,2) & (6,3) \\
\hline
\end{tabularx}
{\color{white}-}
\\
\begin{tabularx}{\textwidth}{|*{5}{X|}}
\hline
$v_9$ & $v_{10}$ & $v_{11}$ & $v_{12}$ & $v_{13}$ \\
\hline 
(4,4) & (6,6)    & (17,5)   & (16,6)   & (11,11) \\
\hline
\end{tabularx}
{\color{white}-}
\\ \\
{\color{white}-}

%============================   G14  ===================================
\newpage
\textbf{Étape k=14:}
\\
Pour le sommet suivant $v_{14}$ il a deux voisins, le $v_{13}$ et le $v_6$,
on doit d'abord se déplacer selon l'axe des abscisses, 
les sommets $v_1$, $v_3$, $v_4$, $v_7$, $v_8$, $v_9$, $v_{10}$ et $v_{13}$ se trouvent sur la première partie à gauche, il ne bouge pas, 	
les sommets $v_5$, $v_{11}$ et $v_{12}$ sont au milieu donc bougent de $+1$ unité vers la droite,
et les sommets $v_2$ et $v_6$ se trouvent dans la troisième partie à droite, ils sont décalés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons notre $v_{14}$ sur l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_{13}$ et la deuxième avec une pente de $-1$ passante par $v_6$, voir la figure suivante:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.6]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (25,13);
	\foreach \x in {1,4,6,7,8,11,12,17,18,20,24} {
		\draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,2,3,4,5,6,9,12} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	\coordinate (1) at (0,0);
	\coordinate (2) at (24,0);
	\coordinate (3) at (8,1);
	\coordinate (4) at (11,2);
	\coordinate (5) at (17,3);
	\coordinate (6) at (20,4);
	\coordinate (11) at (18,5);
	\coordinate (12) at (17,6);	
	\coordinate (7) at (7,2);
	\coordinate (8) at (6,3);
	\coordinate (9) at (4,4);		
	\coordinate (10) at (6,6);	
	\coordinate (13) at (11,11);
	\coordinate (14) at (12,12);
	
	\draw[line width=2pt, color=red, dotted] (6)--(14)--(13);		
	\draw [line width=1pt, color=orange] (11)--(14)--(12);
	
	\draw [fill = cyan!30!white] (11,0)--(1)--(13)--(4);
	\draw [fill = cyan!30!white] (20,0)--(2)--(6);
	\draw [fill = orange!30!white] (15,0)--(15,7.66)--(12)--(11)--(19,4.5)--(19,0);
	
	\draw (4)--(11)--(12)--(4);
	\draw (6)--(11)--(5);
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);	
	\draw (1)--(7)--(3);
	\draw (1)--(8)--(7);
	\draw (1)--(9)--(8);	
	\draw (9)--(10)--(4);
	\draw (8)--(10)--(7)--(10)--(3);	
	\draw (10)--(13)--(4);
	\draw (12)--(13);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below left: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = below: $v_{4}$] at (4) {};
	\node[vertex] [label = below: $v_{5}$] at (5) {};
	\node[vertex] [label = right: $v_{6}$] at (6) {};
	\node[vertex] [label = below: $v_{7}$] at (7) {};
	\node[vertex] [label = below: $v_{8}$] at (8) {};	
	\node[vertex] [label = left:  $v_{9}$] at (9) {};
	\node[vertex] [label = left: $v_{10}$] at (10) {};
	\node[vertex] [label = left: $v_{11}$] at (11) {};
	\node[vertex] [label = left: $v_{12}$] at (12) {};
	\node[vertex] [label = left: $v_{13}$] at (13) {};
	\node[vertex] [label = right: $v_{14}$,inner sep = 3pt, fill=orange] at (14) {};
	
	\path (18, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(14)$}} ;
	\path (12.5, -2.5)  coordinate () {} node[left]	{\Large $G_{14}$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}
Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
\begin{tabularx}{\textwidth}{|*{8}{X|}}
\hline
$v_1$ & $v_2$  & $v_3$ & $v_4$  & $v_5$  & $v_6$  & $v_7$ & $v_8$ \\
\hline 
(0,0) & (24,0) & (8,1) & (11,2) & (17,3) & (20,4) & (7,2) & (6,3) \\
\hline
\end{tabularx}
{\color{white}-}
\\
\begin{tabularx}{\textwidth}{|*{6}{X|}}
\hline
$v_9$ & $v_{10}$ & $v_{11}$ & $v_{12}$ & $v_{13}$ & $v_{14}$ \\
\hline 
(4,4) & (6,6)    & (18,5)   & (17,6)   & (11,11)  & (12,12) \\
\hline
\end{tabularx}
{\color{white}-}
\\ \\
{\color{white}-}

%============================   G15  ===================================

\newpage
\textbf{Étape k=15 :}
\\
Pour le sommet suivant $v_{15}$ il a deux voisins, le $v_1$ et le $v_{13}$,
on doit d'abord se déplacer selon l'axe des abscisses, 
le sommet $v_1$ se trouve sur la première partie à gauche, il ne bouge pas, 	
les sommets $v_3$, $v_7$, $v_8$ $v_9$ et $v_{10}$ sont au milieu donc bougent de $+1$ unité vers la droite,
et les sommets $v_2$, $v_4$, $v_5$, $v_6$, $v_{11}$, $v_{12}$, $v_{13}$ et $v_{14}$ se trouvent dans la troisième partie à droite, ils sont décalés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons notre $v_{15}$ sur l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_1$ et la deuxième avec une pente de $-1$ passante par $v_{13}$, voir la figure suivante:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.6]
	\draw[step=1cm,gray!50,very thin] (-1,-2) grid (27,13);
	\foreach \x in {1,5,7,8,9,12,13,14,19,20,22,26} {
		\draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,2,3,4,5,6,9,12} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	
	\coordinate (1) at (0,0);
	\coordinate (2) at (26,0);
	\coordinate (3) at (9,1);
	\coordinate (4) at (13,2);
	\coordinate (5) at (19,3);
	\coordinate (6) at (22,4);
	\coordinate (11) at (20,5);
	\coordinate (12) at (19,6);
	
	\coordinate (7) at (8,2);
	\coordinate (8) at (7,3);
	\coordinate (9) at (5,4);		
	\coordinate (10) at (7,6);		
	\coordinate (13) at (13,11);
	\coordinate (14) at (14,12);		
	\coordinate (15) at (12,12);
	
	\draw[line width=1pt, color=red, dotted] (13)--(15)--(1);		
	\draw [line width=1pt, color=orange] (10)--(15)--(9);
	
	\draw [fill = cyan!30!white] (13,0)--(2)--(6)--(14)--(13)--(4);
	\draw [fill = orange!30!white] (10,0)--(10,4)--(10)--(9)--(4,3.2)--(4,0)--(10,0);
	
	\draw (6)--(14);
	\draw (12)--(14)--(13);		
	\draw (11)--(14)--(12);
	\draw (4)--(11)--(12)--(4);
	\draw (6)--(11)--(5);
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);		
	\draw (1)--(7)--(3);
	\draw (1)--(8)--(7);
	\draw (1)--(9)--(8);		
	\draw (9)--(10)--(4);
	\draw (8)--(10)--(7)--(10)--(3);		
	\draw (10)--(13)--(4);
	\draw (12)--(13);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = below: $v_{4}$] at (4) {};
	\node[vertex] [label = below: $v_{5}$] at (5) {};
	\node[vertex] [label = right: $v_{6}$] at (6) {};
	\node[vertex] [label = below: $v_{7}$] at (7) {};
	\node[vertex] [label = below: $v_{8}$] at (8) {};	
	\node[vertex] [label = below:  $v_{9}$] at (9) {};
	\node[vertex] [label = right:  $v_{10}$] at (10) {};
	\node[vertex] [label = left:  $v_{11}$] at (11) {};
	\node[vertex] [label = left:  $v_{12}$] at (12) {};
	\node[vertex] [label = left:  $v_{13}$] at (13) {};
	\node[vertex] [label = above: $v_{14}$] at (14) {};
	\node[vertex] [label = above: $v_{15}$,inner sep = 3pt, fill=orange] at (15) {};
	
	\path (8, -1.5)    coordinate () {} node[left]	{\textcolor{orange}{$L(15)$}} ;
	\path (12.5, -2.5) coordinate () {} node[left]	{\Large $G_{15}$};
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}

Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
\begin{tabularx}{\textwidth}{|*{8}{X|}}
\hline
$v_1$ & $v_2$  & $v_3$ & $v_4$  & $v_5$  & $v_6$  & $v_7$ & $v_8$ \\
\hline 
(0,0) & (26,0) & (9,1) & (13,2) & (19,3) & (22,4) & (8,2) & (7,3) \\
\hline
\end{tabularx}
{\color{white}-}
\\
\begin{tabularx}{\textwidth}{|*{7}{X|}}
\hline
$v_9$ & $v_{10}$ & $v_{11}$ & $v_{12}$ & $v_{13}$ & $v_{14}$ & $v_{15}$ \\
\hline 
(5,4) & (7,6)    & (20,5)   & (19,6)   & (13,11)  & (14,12)   & (12,12) \\
\hline
\end{tabularx}
{\color{white}-}
\\ \\
{\color{white}-}

%============================   G16  ===================================

\newpage
\textbf{Étape k=16 :}
\\
Pour le sommet suivant $v_{16}$, il devient un peu plus grand, il a deux voisins, le $v_1$ et le $v_2$,
on doit d'abord se déplacer selon l'axe des abscisses, 
le sommet $v_1$ se trouve sur la première partie à gauche, il ne bouge pas, 	
les sommets $v_3$, $v_4$, $v_5$, $v_6$, $v_7$, $v_8$, $v_9$, $v_{10}$, $v_{11}$, $v_{12}$, $v_{13}$, $v_{14}$ et $v_{15}$ sont au milieu donc bougent de $+1$ unité vers la droite,
et le sommet $v_2$ se trouve dans la troisième partie à droite, il est décalés de 2 unités vers la droite, voir figure suivante, \\
et nous plaçons notre $v_{16}$ sur l'intersection des deux droites: la première avec une pente de $+1$ passante par $v_1$ et la deuxième avec une pente de $-1$ passante par $v_2$, voir la figure suivante:
\\
Donc on peut avoir des arbres, qui contiennent tous les sommets de notre zone orange,
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.5]
	\draw[step=1cm,gray!50,very thin] (-1,-3) grid (29,16);
	\foreach \x in {6,8,9,10,13,14,15,20,21,23} {
		\draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	\foreach \y in {1,2,3,4,5,6,9,11,12,14} {
		\draw (0,\y) -- (0.1,\y) node[anchor=east,xshift=-2mm] {\y};
	}
	
	\coordinate (1) at (0,0);
	\coordinate (2) at (28,0);
	\coordinate (3) at (10,1);
	\coordinate (4) at (14,2);
	\coordinate (5) at (20,3);
	\coordinate (6) at (23,4);
	\coordinate (11) at (21,5);
	\coordinate (12) at (20,6);
	
	\coordinate (7) at (9,2);
	\coordinate (8) at (8,3);
	\coordinate (9) at (6,4);		
	\coordinate (10) at (8,6);		
	\coordinate (13) at (14,11);
	\coordinate (14) at (15,12);		
	\coordinate (15) at (13,12);
	\coordinate (16) at (14,14);
	
	\draw[line width=1pt,  color=red] (1)--(16)--(2);		
	\draw [line width=1pt, color=orange] (6)--(16)--(14);
	\draw [line width=1pt, color=orange] (13)--(16)--(15);
	
	\draw [fill = orange!30!white] (9)--(15)--(13)--(14)--(6)--(23,0)--(6,0)--(9);
	
	\draw (6)--(14);
	\draw (12)--(14)--(13);		
	\draw (11)--(14)--(12);
	\draw (4)--(11)--(12)--(4);
	\draw (6)--(11)--(5);
	\draw (2)--(6)--(5);
	\draw (2)--(5)--(4);
	\draw (2)--(4)--(3);
	\draw (1)--(2)--(3)--(1);		
	\draw (1)--(7)--(3);
	\draw (1)--(8)--(7);
	\draw (1)--(9)--(8);		
	\draw (9)--(10)--(4);
	\draw (8)--(10)--(7)--(10)--(3);		
	\draw (10)--(13)--(4);
	\draw (12)--(13);
	\draw (10)--(15)--(9);
	\draw (13)--(15)--(1);
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
	\node[vertex] [label = below: $v_{3}$] 	at (3)  {};	
	\node[vertex] [label = below: $v_{4}$]  at (4) {};
	\node[vertex] [label = below: $v_{5}$]  at (5) {};
	\node[vertex] [label = right: $v_{6}$]  at (6) {};
	\node[vertex] [label = below: $v_{7}$]  at (7) {};
	\node[vertex] [label = below: $v_{8}$]  at (8) {};	
	\node[vertex] [label = below: $v_{9}$]  at (9) {};
	\node[vertex] [label = right: $v_{10}$] at (10) {};
	\node[vertex] [label = left:  $v_{11}$] at (11) {};
	\node[vertex] [label = left:  $v_{12}$] at (12) {};
	\node[vertex] [label = below left:  $v_{13}$] at (13) {};
	\node[vertex] [label = below: $v_{14}$] at (14) {};
	\node[vertex] [label = above: $v_{15}$] at (15) {};		
	\node[vertex] [label = right: $v_{16}$,inner sep = 3pt, fill=orange] at (16) {};
	
	\path (16, 15  )  coordinate () {} node[left]	{$(n-2 , n-2)$} ;
	\path (1 , -1  )  coordinate () {} node[left]	{$(0,0)$} ;
	\path (29, -1  )  coordinate () {} node[left]	{$(2n-4,0)$};
	
	\path (15, -2  )  coordinate () {} node[left]	{\textcolor{orange}{$L(16)$}} ;
	\path (15, -4)  coordinate () {} node[left]	{\Large $G_{16}$};
	
	
\end{tikzpicture}
\captionof{figure}{Diagramme} 
\label{Diagramme}	
\end{figure}

Les valeurs suivantes sont obtenues à partir du code Java présenté en annexe: \\
\begin{tabularx}{\textwidth}{|*{8}{X|}}
\hline
$v_1$ & $v_2$  & $v_3$ & $v_4$  & $v_5$  & $v_6$  & $v_7$ & $v_8$ \\
\hline 
(0,0) & (28,0) & (10,1) & (14,2) & (20,3) & (23,4) & (9,2) & (8,3) \\
\hline
\end{tabularx}
{\color{white}-}
\\
\begin{tabularx}{\textwidth}{|*{8}{X|}}
\hline
$v_9$ & $v_{10}$ & $v_{11}$ & $v_{12}$ & $v_{13}$ & $v_{14}$ & $v_{15}$ & $v_{16}$ \\
\hline 
(6,4) & (8,6)    & (21,5)   & (20,6)   & (14,11)  & (15,12)   & (13,12) & (14,14) \\
\hline
\end{tabularx}
{\color{white}-}
\\ \\
{\color{white}-}

Et voila ainsi nous avons dessiné notre graphe avec Shift method, 


%===============================================================================
%===================================== début partie corrigé =====================
%===============================================================================
\newpage
\subsection{Analyse de la planarité}
Dans la section précédente, nous avons vu un exemple avec toutes les étapes d'un dessin d'un graphe avec la \textbf{Shift method}. 
\\ \\
\textbf{Avons-nous un dessin d'un graphe planaire ? }
\\ \\
%================================================================
% Déplacement de la sous-section du chapitre 8 ici au chap 9 qui parle de la planarité
%================================================================
%\subsection{Principe}
%Une chose très importante que nous n'avons pas encore prouvé, \textbf{notre dessine est-il toujours un dessin planaire?} 
%\\ \\
Mais avant de répondre à la question, on va examiner un exemple pour nous faire une idée, et pour cela, nous allons marquer la partie au milieu en couleur orange et l'appeler l'ensemble (L) de $v_k$,  on note L($v_k$).

\begin{figure}[H]
\centering
\begin{tikzpicture}	[scale=0.9]		
	\path
	(0,0) coordinate (a)
	(1,1) coordinate (c)
	(2,2) coordinate (d)
	(3,1) coordinate (e)
	(4.5,2) coordinate (f)
	(5,2.65) coordinate (g)
	(6,4) coordinate (h)
	(7,3) coordinate (i)
	(8,4) coordinate (j)
	(9,2.65) coordinate (k)
	(9.5,2) coordinate (l)
	(11,1) coordinate (m)
	(12,2) coordinate (n)
	(13,3) coordinate (o)
	(14,2) coordinate (p)
	(15,1) coordinate (q)			
	(16,0) coordinate (b)
	(7,6)  coordinate (vk)
	(3.7,1.5) coordinate (wp)	
	(10.3,1.5) coordinate (wq)
	%(7,5) coordinate (r)	
	;	
	
	\draw [fill = cyan!30!white] (a)--(c)--(d)--(e)--(f)--(g)--(h)--(i)--(j)--(k)--(l)--(m)--(n)--(o)--(p)--(q)--(b)--(a);
	
	\draw[black,thick,decorate, line width=2pt,name path=A] (4,1.65) -- (4,0);			
	
	\draw[black,thick,decorate, line width=2pt,name path=B] (10,1.65) -- (10,0);
	
	\tikzfillbetween[of=A and B] {fill=orange};	
	
	\draw [fill = orange] (4,1.65)--(f)--(g)--(h)--(i)--(j)--(k)--(l)--(10,1.65);	
	
	\draw[black,thick,decorate, line width=2pt] (4,5) -- (4,1.65);			
	
	\draw[black,thick,decorate, line width=2pt] (10,5) -- (10,1.65);				
	
	%	\draw[line width=2pt, color=orange] (wp)--(r)--(wq);
	%\draw[->, color=red, line width=2pt] (vk) to[bend left=50] (7,5.1);
	
	\draw[color=red, line width=1pt] (wp) -- (vk);
	\draw[color=orange, line width=1pt] (f)--(vk);
	\draw[color=orange, line width=1pt] (g)--(vk);
	\draw[color=orange, line width=1pt] (h)--(vk);
	\draw[color=orange, line width=1pt] (i)--(vk);
	
	\draw[color=orange, line width=1pt] (j)--(vk);
	\draw[color=orange, line width=1pt] (k)--(vk);
	\draw[color=orange, line width=1pt] (l)--(vk);
	\draw[color=red, line width=1pt] (wq)--(vk);
	%coupure========================================
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $v_1$] at (a) {};
	\node[vertex] [label = right: $v_2$] at (b) {};	
	\node[vertex] [label = left: a] at (c) {};	
	\node[vertex] [label = above: b] at (d) {};
	\node[vertex] [label = above: c] at (e) {};
	\node[vertex] [label = right: d,fill=orange] at (f) {};
	\node[vertex] [label = right: e,fill=orange] at (g) {};
	\node[vertex] [label = below: f,fill=orange] at (h) {};
	\node[vertex] [label = below: g,fill=orange] at (i) {};
	\node[vertex] [label = below: h,fill=orange] at (j) {};
	\node[vertex] [label = left: i,fill=orange] at (k) {};
	\node[vertex] [label = left: j,fill=orange] at (l) {};l
	\node[vertex] [label = above: l] at (m) {};
	\node[vertex] [label = above: m] at (n) {};
	\node[vertex] [label = above: n] at (o) {};
	\node[vertex] [label = right: o] at (p) {};
	\node[vertex] [label = right: s] at (q) {};
		
	
	\node[vertex] [label = below: $w_p$,fill=red] at (wp) {};
	\node[vertex] [label = below: $w_q$,fill=red] at (wq) {};
	
	\node[vertex] [label = above : $v_k$,fill=orange] at (vk) {};
	
	\path (0.5,-0.7)  coordinate () {} node[left]{(0,0)} ;
	\path (17,-0.7)  coordinate () {} node[left]{(2k-4, 0)} ;
	\path (8,1)  coordinate () {} node[left]{$G_{k-1}$} ;
			
\end{tikzpicture} 
\captionof{figure}{Exemple d'insertion du sommet $v_k$ avec marquage de l'ensemble L($v_k$)} 
\label{Exemple d'insertion du sommet $v_k$ avec marquage de l'ensemble L($v_k$)}	
\end{figure}
Et quand on fait notre décalage au lieu de se déplacer vers la gauche et la droite,
on va juste déplacer tout ce qui est à l'intérieur de $+1$ unité vers la droite, et tout ce qui est à droite de l'intérieur de +2 unités vers la droite, voir la figure suivat \ref{Illustration du décalage dans la méthode shift}.
\begin{figure}[H]
\centering
\begin{tikzpicture}	[scale=0.7]		
	\path
	(0,0) coordinate (a)
	(2,2) coordinate (d)
	(3,1) coordinate (e)
	(3.7,1.5) coordinate (wp)
	
	(4.3,1.65) coordinate (r)	
	(6.3,4) coordinate (h)
	(7.3,2) coordinate (i)
	(8.3,3) coordinate (j)	
	(10.3,1.65) coordinate (s)	
	
	(12.6,1) coordinate (m)
	(14.6,3) coordinate (o)
	(17.6,0) coordinate (b)
	(10.9,1.5) coordinate (wq)
	
	(7.3,6)  coordinate (vk)		
	;	
	
	\draw [fill = cyan!30!white] (a)--(d)--(e)--(wp)--(3.7,0)--(a);
	\draw [fill = orange!30!white] (4.3,0)--(4.3,1.65)--(h)--(i)--(j)--(s)--(10.3,0)--(4.3,0);
	\draw [fill = cyan!30!white] (wq)--(m)--(o)--(b)--(10.9,0)--(wq);
	
	\draw[color=orange, line width=1pt] (wp) -- (vk);
	
	\draw[color=orange, line width=1pt] (h)--(vk);
	\draw[color=orange, line width=1pt] (i)--(vk);
	\draw[color=orange, line width=1pt] (j)--(vk);
	
	\draw[color=orange, line width=1pt] (wq)--(vk);
	%coupure========================================
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : ] at (a) {};
	\node[vertex] [label = right: ] at (b) {};	
	\node[vertex] [label = right: ] at (d) {};
	\node[vertex] [label = right: ] at (e) {};
	\node[vertex] [label = right: ] at (h) {};
	\node[vertex] [label = right: ] at (i) {};
	\node[vertex] [label = right: ] at (j) {};
	\node[vertex] [label = right: ] at (m) {};
	
	\node[vertex] [label = right: ] at (o) {};
	
	\node[vertex] [label = right: ] at (r) {};
	\node[vertex] [label = right: ] at (s) {};
	
	%\node[vertex] [label = right: r,fill=red] at (r) {};
	
	\node[vertex] [label = left: ,fill=orange] at (wp) {};
	\node[vertex] [label = right: ,fill=orange] at (wq) {};
	
	\node[vertex] [label = above : ,fill=orange] at (vk) {};
	
	\path (7.6,1)   coordinate () {} node[left]{\Large +1} ;
	\path (14.8,1)  coordinate () {} node[left]{\Large +2} ;
	
\end{tikzpicture} 
\captionof{figure}{Illustration du décalage dans la méthode shift} 
\label{Illustration du décalage dans la méthode shift}	
\end{figure}	




%================================================================
%================================================================
{\color{white}-}
\\ \\
\textbf{Preuve de planarité}
\\ \\
Supposons que nous ayons un graphe $G_{k-1}$, auquel nous ajoutons un nouveau sommet $v_{k}$ sur la face externe. Dans $G_{k-1}$, tous les sommets $w_i$ existent avec \( i \in \{1, 2, \dots  t\} \) tel que \(  1 < \dots < p < \dots < q < \dots < t \). Nous avons ainsi les sommets $v_1$, $v_2$, ..., ainsi que les voisins de gauche \(  w_p, w_{p+1},\dots,w_q,\dots \) et ainsi de suite.
\\
Dans ce contexte, certains sommets qui étaient précédemment sur la face externe ne le sont plus maintenant. Nous appelons ces sommets "couverts". Lorsqu'un sommet est retiré de la face externe, cela ne peut se produire qu'une seule fois, ce qui signifie que chaque sommet interne est couvert exactement une fois.
\\
Si nous examinons la relation entre le sommet couvrant $v_{k}$ et les sommets couverts (entourés en bas dans la figure illustrative \ref{Illustration de la relation de couverture et de la forêt de sous-graphes}), nous remarquons que ces derniers peuvent couvrir d'autres sommets en dessous. Cependant, chaque sommet n'est couvert qu'une seule fois, et chaque sommet a donc une seule arête entrante. Ainsi, cette relation de couverture définit un arbre au sein de notre graphe.
\\
Dans les sous-graphes de notre graphe, c'est une \textbf{forêt}. Le sommet $v_{k}$ couvre ceux qui sont colorés en orange, et chacun de ces derniers peut couvrir d'autres sommets. Cependant, les sommets qui ont un indice inférieur à $w_p$, ainsi que les sommets qui ont un indice supérieur à $w_{q}$, ne sont pas couverts par $v_{k}$.
\\
Cela donne lieu à plusieurs \textbf{arbres} distincts, formant une forêt, comme le montre la figure illustrative \ref{Illustration de la relation de couverture et de la forêt de sous-graphes}. Néanmoins, les sommets dont l'indice est inférieur à $w_{p}$ et ceux dont l'indice est supérieur à $w_{q}$ ne sont pas couverts par $v_{k}$.
%\includegraphics[width=0.6\linewidth]{images/image40.png}
\\
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=.8]
	\draw[step=1cm,gray!50,very thin] (-1,-1) grid (13,8);
	
	\coordinate (1) at (0,0);
	\coordinate (11) at (0.06,1);
	\coordinate (12) at (0.37,2);		
	\coordinate (3) at (1,3);
	\coordinate (31) at (2,3.64);		
	\coordinate (4) at (4,4);
	\coordinate (5) at (6,4);
	\coordinate (6) at (8,4);		
	\coordinate (61) at (10,3.64);		
	\coordinate (7) at (11,3);
	\coordinate (71) at (11.63,2);
	\coordinate (72) at (11.94,1);		
	\coordinate (2) at (12,0);
	\coordinate (vk) at (6,7);
	
	\draw (1)--(2);
	\draw (1) to [bend left=20] (3);
	\draw (3) to [bend left=20] (4);
	\draw (4)--(5)--(6);
	\draw (6) to [bend left=20] (7);
	\draw (7) to [bend left=20] (2);
	
	
	\draw[black,thick,decorate,decoration={snake,amplitude=0.02cm,segment length=1cm}] (2.5,6)--(2.7,3)--(2.5,-0.3);
	\draw[black,thick,decorate,decoration={snake,amplitude=0.02cm,segment length=1cm}] (9.5,6)--(9.3,3)--(9.5,-0.3);
	
	\draw [line width=2pt, color=red] (31)--(vk)--(61);
	\draw [line width=2pt, color=orange] (4)--(vk)--(6);
	\draw [line width=2pt, color=orange] (5)--(vk);
	
	
	\draw [fill = cyan!30!white] (0.06,1) to [bend left=20] (0.5,0.2) to [bend left=20] (0.06,1);	
	\draw [fill = cyan!30!white] (0.37,2) to [bend left=20] (0.6,1) to [bend left=20] (0.37,2);		
	%\draw (3) to [bend left=20] (1.2,2) to [bend left=90] (0.8,2) to [bend left=20] (3);
	\draw [fill = cyan!30!white] (3) to [bend left=20] (1.2,2) to [bend left=20] (3);
	\draw [fill = cyan!30!white] (2,3.64) to [bend left=20] (2,2.64) to [bend left=20] (2,3.64);
	
	\draw [fill = orange](4,4) -- (3.5,3)--(3.5,2)--(4,1)--(4.5,2)--(4.5,3) -- (4,4) ;
	\draw [fill = orange](6,4) to [bend left=20] (6,3) to [bend left=20] (6,4);
	\draw [fill = orange](8,4) to [bend left=20] (8,3) to [bend left=20] (8,4);
	
	\draw [fill = cyan!30!white] (10,3.64) to [bend left=20] (10,2.64) to [bend left=20] (10,3.64);
	\draw [fill = cyan!30!white] (11,3) to [bend left=20] (10.8,2) to [bend left=20] (11,3);
	\draw [fill = cyan!30!white] (11.63,2) to [bend left=20] (11.4,1) to [bend left=20] (11.63,2);
	\draw [fill = cyan!30!white] (11.94,1) to [bend left=20] (11.5,0.2) to [bend left=20] (11.94,1);
	
	%========================	2eme partie =================================
	\draw [fill = orange](4,4) to [bend right=20] (3,2) to [bend right=20](4,1) to [bend right=20](5,2) to [bend right=20] (4,4) ;
	
	
	% ====================== l'arbre  ================================
	\draw (3.96,3.93)--(3.7,3);     \draw (3.7,3) node[circle,fill,inner sep=1pt] {};
	\draw (4.04,3.93)--(4.3,3);     \draw (4.3,3) node[circle,fill,inner sep=1pt] {};
	\draw (4.3,3)--(4.5,2.5);     \draw (4.5,2.5) node[circle,fill,inner sep=1pt] {};
	\draw (4.5,2.5)--(4.8,2);     \draw (4.8,2) node[circle,fill,inner sep=1pt] {};
	\draw (4.5,2.5)--(4.3,2);     \draw (4.3,2) node[circle,fill,inner sep=1pt] {};
	
	\draw (3.7,3)--(3.5,2.5); \draw (3.5,2.5) node[circle,fill,inner sep=1pt] {};
	\draw (3.7,3)--(4.1,2.5); \draw (4.1,2.5) node[circle,fill,inner sep=1pt] {};
	
	\draw (3.5,2.5)--(3.2,2); \draw (3.2,2) node[circle,fill,inner sep=1pt] {};		
	\draw (3.5,2.5)--(3.9,2);   \draw (3.9,2) node[circle,fill,inner sep=1pt] {};		
	
	\draw (3.9,2)--(3.6,1.5);   \draw (3.6,1.5) node[circle,fill,inner sep=1pt] {};
	\draw (3.9,2)--(3.9,1.5);     \draw (3.9,1.5) node[circle,fill,inner sep=1pt] {};
	\draw (3.9,2)--(4.2,1.5);   \draw (4.2,1.5) node[circle,fill,inner sep=1pt] {};
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : \Large$w_1$] at (1) {};
	\node[vertex] [label = left : \Large$w_2$] at (11) {};
	\node[vertex] [label = left : ] at (12) {};
	\node[vertex] [label = right: \Large$w_t$] at (2) {};
	
	\node[vertex] [label = left: ] at (3) {};
	\node[vertex] [label = left: \Large$w_{p}$] at (31) {};
	
	\node[vertex] [label = right: ,fill=orange] at (4) {};
	\node[vertex] [label = right: ,fill=orange] at (5) {};	
	\node[vertex] [label = right: ,fill=orange] at (6) {};
	\node[vertex] [label = right: \Large$w_{q}$] at (61) {};	
	
	\node[vertex] [label = right: ] at (7) {};
	\node[vertex] [label = right: ] at (71) {};
	\node[vertex] [label = right: \Large $w_{t-1}$] at (72) {};
	
	\node[vertex] [label = above: \Large$v_k$,fill=orange] at (vk) {};
	
	\path (6.6, 0.5)  coordinate () {} node[left]	{\Large $G_{k-1}$};
	
	\path (6.6, -1) coordinate () {} node[left]	{\large $L(w_i)$};
	\draw[-{Stealth[length=5mm,width=5mm]}, line width=1pt, color=lightgray] (6.6, -1) to [bend right=20] (11,1);
	\draw[-{Stealth[length=5mm,width=5mm]}, line width=1pt, color=lightgray] (6.6, -1) to [bend right=20] (8,2.5);
	\draw[-{Stealth[length=5mm,width=5mm]}, line width=1pt, color=lightgray] (5, -1) to [bend left=20] (2,2.5);
	\draw[-{Stealth[length=5mm,width=5mm]}, line width=1pt, color=lightgray] (5, -1) to [bend left=20] (1,1);
	
\end{tikzpicture}
\captionof{figure}{Illustration de la relation de couverture et de la forêt de sous-graphes} 
\label{Illustration de la relation de couverture et de la forêt de sous-graphes}	
\end{figure}

\textbf{que devons-nous faire, pour être sûrs que notre dessin est planaire ? }
\\
Après avoir effectué notre découpe, nous devons garantir que les nouvelles arêtes n'intersectent aucune des anciennes structures présentes, et que ces anciennes structures demeurent disposées de manière planaire.
\\
Pour la première étape, les éléments en orange sont clairement planaires. En effet, si l'on observe la figure \ref{Exemple d'insertion du sommet $v_k$ avec marquage de l'ensemble L($v_k$)}, les arêtes oranges présentent une pente de \( \pm 1 \). Les trois successeurs, c'est-à-dire les sommets \( d, e \) et $f$ montant de $w_p$, avaient une pente de $+1$ précédemment, et ils ont été déplacés. Par conséquent, nous ne pouvons pas avoir d'intersection en $v_k$. De même, les prédécesseurs, à savoir les sommets \( h, i\) et $j$ descendant de $w_q$, avaient une pente de $-1$, et ils ont également été déplacés. Par conséquent, nous ne pouvons pas non plus avoir d'intersection en $v_k$.
\\
En ce qui concerne les autres arêtes à l'intérieur de la structure, elles présentent une pente plus importante, soit supérieure à $+1$, soit inférieure à $-1$. Par conséquent, nous ne pouvons pas avoir de croisements au sein de la partie orange.
\\ \\ \\
%\textbf{Mais qu'en est-il de la partie $G_{k-1}$ après le décalage ?}
%\includegraphics[width=0.4\linewidth]{images/image41.png}
%\\ \\
\textbf{Observations}
\\
\\1. Chaque sommet interne est couvert exactement une fois.
\\2. La relation de couverture définit un arbre dans G
\\3. Une forêt dans $G_i$, $1 \leq i \leq n-1$.
\\ \\
Pour cela, on utilise une proposition général, c'est-à-dire on examine tous les ensembles de recouvrement \(L(w_i)\), que nous avons définis avant, et prouver que nous pouvons les déplacer d'une certaine manière, et tout reste toujours planaire, donc on va prouver le théorème suivant:
\\ \\
\noindent\fbox{
\parbox{\textwidth}{
	\begin{theorem}
		\label{theorem 8.1}	
		Supposons que $G_k$ soit dessiné de façon planaire.	\\
		Soit $0 < \delta_1 < \delta_2 < ... < \delta_t \in \mathbb{N} $.	\\
		Si nous décalons chaque $L(w_i)$ de $\delta_i$ vers la droite, alors le dessin reste planaire \citep{PhilippKindermann}.
	\end{theorem}
} }
\\ \\
Nous avons quelques variables croissantes qui vont de $\delta_1$ à $\delta_t$, donc $\delta_1$ est égale au moins zéro, $\delta_2$ est égale au moins 1, $\delta_3$ est égale au moins 2, et ainsi de suite, et maintenant si on prends tous les $L(w_i)$, et que nous décalons chacun d'entre eux, de $\delta_i$ vers la droite alors le dessin reste planaire, 
\\ \\
\textbf{Exemple} : On décale $w_1$ de 0, $w_2$ de 1, le suivant de 2, $v_k$ et tous les oranges au milieu par 3, et touts les suivants par 4, $w_t$ aussi par 4, alors c'est planaire.
\\
Dans notre étape inductive, on a $(0 < \delta_1 < \delta_2 < ... < \delta_t)$ uniquement pour les 0, 1 et 2, mais il nous faut une forme générale, pour la preuve inductive,
\\  \\ \\
%\textbf{Comment prouver notre théorème?}
%=====================================================================
\textbf{Démonstration du théorème \ref{theorem 8.1}}
\begin{proof} [Démonstration du théorème \ref{theorem 8.1}]
Initialement, nous avons $G_3$ et, par suite, nous obtenons un graphe. On distingue précisément trois ensembles. Tant que nous procédons à des déplacements selon la méthode décrite, la planarité est préservée. Par conséquent, nous pouvons supposer par induction que si le lemme est vrai pour $G_{k-1}$, il l'est aussi pour $G_k$.
\\  \\
Comment cela se manifeste-t-il ? Si pour $G_k$, nous obtenons un nombre correspondant à tous les sommets sur la face externe (les sommets de $w_1$ à $w_p$, et les sommets de $w_q$ à $w_t$), nous pouvons alors appliquer un décalage à $G_{k-1}$. Plus précisément, nous décalons tous les sommets avant $w_p$ et après $w_q$ dans le dessin de $G_{k-1}$ par exactement ce nombre $(0 < \delta_1 < \delta_2 < ... < \delta_t)$. De plus, nous décalons tous les sommets du milieu par le nombre que nous avons obtenu pour $v_k$. Par induction, notre graphe demeure donc un dessin planaire.
\\ \\
Qu'en est-il de $G_k$ ? Nous avons appliqué le décalage à tous les sommets du graphe et il ne reste plus qu'à déplacer également $v_k$ vers la droite. Toutefois, ce déplacement est effectué avec tout ce qui se trouve en dessous (la partie orange du milieu), garantissant que rien ne change. Par conséquent, nous ne pouvons pas introduire de nouveaux croisements dans la partie orange du milieu.
\\ \\
Quant aux deux arêtes ($v_k$, $w_p$) et ($v_k$, $w_q$), elles demeurent clairement à l'extérieur du dessin central, assurant ainsi que l'ensemble reste planaire.
\end{proof}


En conclusion, après avoir démontré le théorème \ref{theorem 8.1}, nous sommes en mesure d'affirmer que nous pouvons appliquer nos décalages à chaque étape sans introduire de nouveaux croisements. Par conséquent, l'ensemble de la méthode nous fournit un dessin planaire.






%==============================================================================
% Analyse de complexité et implémentation d'algorithme Shift method 
%==============================================================================

\newpage
\section{Analyse de complexité et implémentation d'algorithme Shift method}
\label{Analyse de complexité et implémentation d'algorithme Shift method}
Nous avons prouvé que la méthode du décalage nous donne un dessin sur planaire simple, sur une grille de taille polynomiale, maintenant on a besoin de connaître la durée d'exécution.

\subsection{Pseudo-code}
\label{Pseudo-code}
Pour connaître la durée d'exécution, nous allons jeter un coup d'œil au pseudo-code.
\\ \\

\begin{algorithm}[H]
\label{pseudoCode}
\KwInput{(Graphe, son ordre canonique)}
\KwOutput{(Graphe décalé par la méthode shift)}
\Begin{
	\tcp{Soit $v_1, \dots, v_n$ l'ordre canoniquedu graphe G}
	
	\SetAlgoNoEnd % Ajout de la commande
	\For{(i:=1 \textbf{jusqu'à} 3)}{ 
		L($v_i$) ← \{$v_i$\}
	}
	P($v_1$) ← (0, 0); P($v_2$) ← (2, 0); P($v_3$) ← (1, 1);  \\
	
	\SetAlgoNoEnd % Ajout de la commande
	\For{(i:=4 \textbf{jusqu'à} n)}{
		\tcp{Soit $w_1$=$v_1$, $w_2$, \dots, $w_{t-1}$, $w_t$=$v_2$ désigne la frontière de $G_{i-1}$, et notons $w_p$, \dots, $w_q$ les voisins de $v_i$}
		
		\SetAlgoNoEnd % Ajout de la commande
		\For {($\forall v \in \quad \bigcup_{j=p+1}^{q-1} L(w_j)  $)} {  \tcp{La complexité de cette boucle $\theta(n^2)$}                   
			x($v$) ← x($v$) + 1   
		}
		
		\SetAlgoNoEnd % Ajout de la commande
		\For {($\forall v \in \quad \bigcup_{j=q}^{t} L(w_j)  $)} {
			\tcp{La complexité de cette boucle $\theta(n^2)$}
			x($v$) ← x($v$) + 2  	
		}
		
		P($v_i$) ← intersection des diagonales $ \pm 1$ passante par P($w_p$) et P($w_q$) \\
		L($v_i$) ← $\bigcup_{j=p+1}^{q-1}$ L($w_j$) $\cup$  \{$v_i$\} 
	}
	
}
\caption{Pseudo-code de Shift method}
\end{algorithm}
\ULforem %%%% enable auto underline
%===============================================================
%           Rétrospective
%===============================================================
\subsection{Rétrospective}
Nous supposons que nous avons déjà l'ordre canonique, nous savons que nous pouvons faire cette partie en un temps linéaire. \\
\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=1]
	\draw[step=1cm,gray!50,very thin] (-1,-1) grid (13,8);
	\foreach \x in {1,...,11} {
		\draw (\x,-0.1) -- (\x,0.1) node[anchor=north ,yshift=-2mm] {\x};
	}
	
	\coordinate (1) at (0,0);
	\coordinate (11) at (0.06,1);
	\coordinate (12) at (0.37,2);		
	\coordinate (3) at (1,3);
	\coordinate (31) at (2,3.64);		
	\coordinate (4) at (4,4);
	\coordinate (5) at (6,4);
	\coordinate (6) at (8,4);		
	\coordinate (61) at (10,3.64);		
	\coordinate (7) at (11,3);
	\coordinate (71) at (11.63,2);
	\coordinate (72) at (11.94,1);		
	\coordinate (2) at (12,0);
	\coordinate (vk) at (6,7);
	
	\draw (1)--(2);
	\draw (1) to [bend left=20] (3);
	\draw (3) to [bend left=20] (4);
	\draw (4)--(5)--(6);
	\draw (6) to [bend left=20] (7);
	\draw (7) to [bend left=20] (2);
	
	
	\draw [line width=2pt, color=red] (31)--(vk)--(61);
	\draw [line width=2pt, color=orange] (4)--(vk)--(6);
	\draw [line width=2pt, color=orange] (5)--(vk);
	
	%========================	1er partie =================================
	\draw [fill = cyan!30!white] (0.06,1) to [bend left=20] (0.5,0.2) to [bend left=20] (0.06,1);	
	\draw [fill = cyan!30!white] (0.37,2) to [bend left=20] (0.6,1) to [bend left=20] (0.37,2);		
	%\draw (3) to [bend left=20] (1.2,2) to [bend left=90] (0.8,2) to [bend left=20] (3);
	\draw [fill = cyan!30!white] (3) to [bend left=20] (1.2,2) to [bend left=20] (3);
	\draw [fill = cyan!30!white] (2,3.64) to [bend left=20] (2,2.64) to [bend left=20] (2,3.64);
	
	%========================	2eme partie =================================
	\draw [fill = orange](4,4) to [bend right=20] (3,2) to [bend right=20](4,1) to [bend right=20](5,2) to [bend right=20] (4,4) ;
	
	\draw [fill = orange](6,4) to [bend right=20] (5.5,2.5) to [bend right=60] (6.5,2.5) to [bend right=20] (6,4);
	
	\draw [fill = orange](8,4) to [bend right=20] (7.5,2.5) to [bend right=60] (8.5,2.5) to [bend right=20] (8,4);
	
	%========================	3eme partie =================================
	\draw [fill = cyan!30!white] (10,3.64) to [bend left=20] (10,2.64) to [bend left=20] (10,3.64);
	\draw [fill = cyan!30!white] (11,3) to [bend left=20] (10.8,2) to [bend left=20] (11,3);
	\draw [fill = cyan!30!white] (11.63,2) to [bend left=20] (11.4,1) to [bend left=20] (11.63,2);
	\draw [fill = cyan!30!white] (11.94,1) to [bend left=20] (11.5,0.2) to [bend left=20] (11.94,1);
	
	
	\tikzstyle{vertex} = [draw,circle,fill=teal!30!white,inner sep = 2pt]
	\node[vertex] [label = left : $w_1$] at (1) {};
	\node[vertex] [label = left : $w_2$] at (11) {};
	\node[vertex] [label = left : ] at (12) {};
	\node[vertex] [label = right: $w_t$] at (2) {};
	
	\node[vertex] [label = left: ] at (3) {};
	\node[vertex] [label = left: $w_{p}$] at (31) {};
	
	\node[vertex] [label = above : $w_{p+1}$,fill=orange] at (4) {};
	\node[vertex] [label = right: ,fill=orange] at (5) {};	
	\node[vertex] [label = right: ,fill=orange] at (6) {};
	\node[vertex] [label = right: $w_{q}$] at (61) {};	
	
	\node[vertex] [label = right: ] at (7) {};
	\node[vertex] [label = right: ] at (71) {};
	\node[vertex] [label = right:  $w_{t-1}$] at (72) {};
	
	\node[vertex] [label = above: $v_k$,fill=orange] at (vk) {};
	
	\path (6.6, 1)  coordinate () {} node[left]	{\Large $G_{i-1}$};
	
	% ====================== l'arbre  ================================
	\draw (3.96,3.93)--(3.7,3);     \draw (3.7,3) node[circle,fill,inner sep=1pt] {};
	\draw (4.04,3.93)--(4.3,3);     \draw (4.3,3) node[circle,fill,inner sep=1pt] {};
	\draw (4.3,3)--(4.5,2.5);     \draw (4.5,2.5) node[circle,fill,inner sep=1pt] {};
	\draw (4.5,2.5)--(4.8,2);     \draw (4.8,2) node[circle,fill,inner sep=1pt] {};
	\draw (4.5,2.5)--(4.3,2);     \draw (4.3,2) node[circle,fill,inner sep=1pt] {};
	
	\draw (3.7,3)--(3.5,2.5); \draw (3.5,2.5) node[circle,fill,inner sep=1pt] {};
	\draw (3.7,3)--(4.1,2.5); \draw (4.1,2.5) node[circle,fill,inner sep=1pt] {};
	
	\draw (3.5,2.5)--(3.2,2); \draw (3.2,2) node[circle,fill,inner sep=1pt] {};		
	\draw (3.5,2.5)--(3.9,2);   \draw (3.9,2) node[circle,fill,inner sep=1pt] {};		
	
	\draw (3.9,2)--(3.6,1.5);   \draw (3.6,1.5) node[circle,fill,inner sep=1pt] {};
	\draw (3.9,2)--(3.9,1.5);     \draw (3.9,1.5) node[circle,fill,inner sep=1pt] {};
	\draw (3.9,2)--(4.2,1.5);   \draw (4.2,1.5) node[circle,fill,inner sep=1pt] {};
	
	%		\path (6.6, -1) coordinate () {} node[left]	{\Large $L(w_i)$};
	%\draw[-{Stealth[length=5mm,width=5mm]}, line width=1pt, color=lightgray] (6.6, -1) to [bend right=20] (11,1);
	%\draw[-{Stealth[length=5mm,width=5mm]}, line width=1pt, color=lightgray] (6.6, -1) to [bend right=20] (8,2.5);
	%\draw[-{Stealth[length=5mm,width=5mm]}, line width=1pt, color=lightgray] (5, -1) to [bend left=20] (2,2.5);
	%\draw[-{Stealth[length=5mm,width=5mm]}, line width=1pt, color=lightgray] (5, -1) to [bend left=20] (1,1);
	
\end{tikzpicture}
\captionof{figure}{Illustration de la position du sommet $v_k$ sur le graphe $G_{k−1}$, et l'ensemble L($v_i$) sous forme d'une structure arborescente} 
\label{Illustration de la position du sommet $v_k$ sur le graphe $G_{k−1}$, et l'ensemble L($v_i$) sous forme d'une structure arborescente}	
\end{figure}
Dans un premier lieu on commence à dessiner les trois premiers sommets. Puis dessiner les autres, donc supposons que nous avons déjà dessiné $G{i-1}$, Nous avons les points $w_1$ jusqu’à $w_t$ sur la face externe, et nous avons les voisins de $v_i$ qui vont de $w_p$ jusqu’à $w_q$ voir la figure \ref{Exemple d'insertion du sommet $v_k$ avec marquage de l'ensemble L($v_k$)}. Et donc pour faire notre décalage, on doit trouver l'ensemble L($v_i$) et le déplacer vers la droite, et ce qui est à sa droite, également le déplacer vers la droite, voir la figure \ref{Illustration du décalage dans la méthode shift}.
\\ \\
Nous avons donc trois ensembles, le premier contient tout ce qui est à gauche, on ne va rien faire pour cette partie. Comme illustré dans la photo \ref{Illustration du décalage dans la méthode shift};\\
Et nous avons la partie centrale, et pour cette partie, nous regardons le L($v_i$) de tous les sommets entre $p+1$ et $q-1$, et tous pour ces sommets nous les décalons de $+1$ vers la droite, Comme illustré dans la photo \ref{Illustration du décalage dans la méthode shift};\\
Puis nous avons tous les sommets de droite, qui commence par $w_q$ jusqu'à $w_t$, et tous ces ensembles nous les déplaçons par $+2$ unités vers la droite, Comme illustré dans la photo \ref{Illustration du décalage dans la méthode shift}.
Et c'est comme ça qu'on obtient notre décalage.
\\
Maintenant on veut placer le $v_k$, et pour cela, on doit trouver l’intersection de la droite passante par $w_p$ avec une pente $+1$ et de la droite passante par $w_q$ avec une pente $−1$ illustré dans la figure \ref{Illustration de la position du sommet $v_k$ sur le graphe $G_{k−1}$, et l'ensemble L($v_i$) sous forme d'une structure arborescente}. et nous avons déjà prouvé que cela nous donne un dessin planaire;
\\ \\
La seule chose qui reste à faire, est de trouver l'ensemble L($v_i$). Mais c'est encore une fois, c'est très simple, nous prenons juste l'union des ensembles de tous les sommets dans la partie orange, et nous itérons. Et donc c'est ça notre pseudo code \ref{pseudoCode}.




%==========================================================================
%       Analyse de complexité
%==========================================================================


\subsection{Analyse de complexité}
\label{Analyse de complexité}
Dans le pseudo code \ref{pseudoCode} on remarque que tout est constant en dehors des boucles, donc nous devons seulement regarder ce qui se passe à l’intérieur des boucles.
\\
Nous supposons que le graphe $G$ est déjà triangulé et intégré dans le plan, et qu'un ordre canonique \( \pi = \{v_1, v_2, \dots, v_n\} \) de $G$ est donné. Nous considérons la famille d'ensembles \(L(w_i), L(w_2), \dots, L(w_t)\) pour les sommets externes \(w_1, w_2, \dots, w_t\) du graphe $G_k$ comme une forêt $F$ dans $G_k$ composée d'arbres \(L(w_i), L(w_2),\dots, L(w_t)\) enracinés aux sommets \(w_1, w_2, ..., w_t\) comme illustré dans la figure suivante \ref{Illustration de la relation de couverture et de la forêt de sous-graphes}. Pour bien représenter les ensembles, la foret et l'arbre binaire, nous prenons notre exemple d'avant mais sans le sommet $v_{16}$ car le sommet $v_{16}$ est sommet couvrant de la forêt, ainsi on aura notre graphe $G_{15}$, la forêt $F$ est représentée par des lignes épaisses et solides comme le montre la figure \ref{Illustration de la forêt $F$ dans le graphe $G_{15}$ par des lignes épaisses et solides} 

\begin{figure}[H]
\centering		
\begin{tikzpicture}[scale=.7]
	\path 
	(0,0)   	coordinate	(v1) 
	(15,0)   	coordinate	(v2)
	(7.5,1.5)   coordinate	(v3)		
	(9.5,2)		coordinate	(v4)
	(11.2,2.8)	coordinate	(v5)
	(13,3.5)	coordinate	(v6)	
	(5.7,2)		coordinate	(v7)	
	(4.1,2.5)	coordinate	(v8)
	(2.8,3.5)	coordinate	(v9)
	(5.8,4)		coordinate	(v10)	
	(10.7,5)	coordinate	(v11)
	(4,8)	    coordinate	(v15)
	(8.8,5)		coordinate	(v12)
	(9,8)		coordinate	(v14)	
	(7,6.5)		coordinate	(v13)	;	
	
	\draw(v1)--(v3)--(v2)--(v1);			
	
	\draw (v4)--(v13)--(v12);
	\draw (v4)--(v11)--(v5);
	
	\draw (v1)--(v2)--(v6);
	\draw (v13)--(v10)--(v4);
	%\draw[line width=2pt, color=green!70!black] (v4)--(v13);
	
	\draw (v13) -- (v15);
	\draw (v14)--(v11)--(v12)--(v14)--(v13);
	
	\draw (v2)--(v3)--(v1); 
	\draw (v3)--(v4)--(v2)--(v3);
	\draw (v4)--(v5)--(v2)--(v4); 
	\draw (v5)--(v6); 
	\draw (v1)--(v7)--(v3)--(v1); 
	\draw (v1)--(v8)--(v7)--(v1); 
	\draw (v1)--(v9)--(v8)--(v1);
	\draw (v9)--(v10)--(v8);	
	\draw (v7)--(v10)--(v3); 
	\draw (v12)--(v4);	
	

	\draw (v6) to[bend right=20] (v14);
	\draw (v1) to[bend left=25] (v15);
	
	\draw[color=black, line width=2pt] (v10)--(v8);
	\draw[color=black, line width=2pt] (v10)--(v7);
	\draw[color=black, line width=2pt] (v10)--(v3);
	
	\draw[color=black, line width=2pt] (v11)--(v5);
	
	\draw[color=black, line width=2pt] (v13)--(v4);
	
	\draw[color=black, line width=2pt] (v14)--(v11);
	\draw[color=black, line width=2pt] (v14)--(v12);
	
	\draw[color=black, line width=2pt] (v15)--(v9);
	\draw[color=black, line width=2pt] (v15)--(v10);
	
	
	
	\tikzstyle{vertex} = [draw,circle,fill=white,inner sep = 3pt]
	\node[vertex] [label = left : $v_{1}$] 	at (v1)  {};
	\node[vertex] [label = right: $v_{2}$] 	at (v2)  {};
	\node[vertex] [label = below: $v_{3}$] 	at (v3)  {};
	\node[vertex] [label = below: $v_{4}$] 	at (v4)  {};
	\node[vertex] [label = below: $v_{5}$] 	at (v5)  {};
	\node[vertex] [label = right: $v_{6}$] 	at (v6)  {};
	\node[vertex] [label = below: $v_{7}$] 	at (v7)  {};
	\node[vertex] [label = below: $v_{8}$] 	at (v8)  {};
	\node[vertex] [label = left : $v_{9}$] 	at (v9)  {};
	\node[vertex] [label = right: $v_{10}$] 	at (v10) {};
	\node[vertex] [label = right: $v_{11}$] 	at (v11) {};
	\node[vertex] [label = below right : $v_{12}$] 	at (v12) {};			
	\node[vertex] [label = above : $v_{13}$] 	at (v13) {};			
	\node[vertex] [label = right: $v_{14}$] 	at (v14) {};
	\node[vertex] [label = left : $v_{15}$] 	at (v15) {};
	
	
	%\path (8 , 0.5)    coordinate () {} node[left]	{$G_{3}$} ;			
\end{tikzpicture}
\captionof{figure}{Illustration de la forêt $F$ dans le graphe $G_{15}$ par des lignes épaisses et solides} %\includegraphics{images/image1.png}
\label{Illustration de la forêt $F$ dans le graphe $G_{15}$ par des lignes épaisses et solides}	
\end{figure}

Pour $G_{15}$ la forêt $F$ et est également représentée dans la figure suivante \ref{Illustration de la forêt $F$ du graphe $G_{15}$}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=1]
	
	% ====================== l'arbre  ================================
\path (0.5,7  ) coordinate () {} node[left]	{$L(w_1)$} ;	
\path (0.5,6.5) coordinate () {} node[left]	{$w_1=1$} ;	
\draw (0,6  ) node[circle,fill,inner sep=2pt] {};

\path (2.8,7  ) coordinate () {} node[left]	{$L(w_2)$};
\path (2.8,6.5) coordinate () {} node[left]	{$w_2=v_{15}$};	
\draw (2,6  ) node[circle,fill,inner sep=2pt] {};
\draw (2,6)--(1,5); \draw (1,5) node[circle,fill,inner sep=2pt, label = left : $v_{9}$] {}; %fg v15
\draw (2,6)--(3,5); \draw (3,5) node[circle,fill,inner sep=2pt, label = right : $v_{10}$] {};  %fd v15

\draw (3,5)--(2,4); \draw (2,4) node[circle,fill,inner sep=2pt, label = left : $v_{8}$] {};
\draw (3,5)--(3,4); \draw (3,4) node[circle,fill,inner sep=2pt, label = below : $v_{7}$] {};
\draw (3,5)--(4,4); \draw (4,4) node[circle,fill,inner sep=2pt, label = right : $v_{3}$] {};

\path (6.8,7  ) coordinate () {} node[left]	{$L(w_3)$};
\path (6.8,6.5) coordinate () {} node[left]	{$w_3=v_{13}$};	
\draw (6,6  ) node[circle,fill,inner sep=2pt] {};
\draw (6,6)--(6,5); \draw (6,5) node[circle,fill,inner sep=2pt, label = below : $v_{4}$] {}; %f v13


\path (9.8,7  ) coordinate () {} node[left]	{$L(w_4)$};
\path (9.8,6.5) coordinate () {} node[left]	{$w_4=v_{14}$};	
\draw (9,6  ) node[circle,fill,inner sep=2pt] {};
\draw (9,6)--(8,5); \draw (8,5) node[circle,fill,inner sep=2pt, label = left : $v_{12}$] {}; %fg v14
\draw (9,6)--(10,5); \draw (10,5) node[circle,fill,inner sep=2pt, label = right : $v_{11}$] {}; %fd v14
\draw (10,5)--(10,4); \draw (10,4) node[circle,fill,inner sep=2pt, label = below : $v_{5}$] {}; %fd v14


\path (12.8,7  ) coordinate () {} node[left]	{$L(w_5)$};
\path (12.8,6.5) coordinate () {} node[left]	{$w_5=v_{6}$};	
\draw (12,6  ) node[circle,fill,inner sep=2pt] {};

\path (14.8,7  ) coordinate () {} node[left]	{$L(w_6)$};
\path (14.8,6.5) coordinate () {} node[left]	{$w_6=v_{2}$};	
\draw (14,6  ) node[circle,fill,inner sep=2pt] {};

\end{tikzpicture}
\captionof{figure}{Illustration de la forêt $F$ du graphe $G_{15}$} 
\label{Illustration de la forêt $F$ du graphe $G_{15}$}	
\end{figure}

Les enfants de la racine $w_i$ d'un arbre $L(w_i)$ sont les sommets que $w_i$ couvre, c'est-à-dire ses voisins qui quittent le cycle externe lorsque $w_i$ est installé. La forêt F est représentée par un arbre binaire $T$ comme illustré dans la figure suivante \ref{Illustration de l'arbre $T$ du graphe $G_{15}$}. 

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.6]

	% ====================== l'arbre  ================================
%\path (0.5,7  ) coordinate () {} node[left]	{$L(w_1)$} ;	
%\path (0.5,6.5) coordinate () {} node[left]	{$w_1=1$} ;	
%\draw (0,6  ) node[circle,fill,inner sep=2pt] {};

%\path (2.8,7  ) coordinate () {} node[left]	{$L(w_2)$};
%\path (2.8,6.5) coordinate () {} node[left]	{$w_2=v_{15}$};	
\draw (5,12) node[circle,fill,inner sep=2pt, label = left : $v_{1}$] {};
\draw[line width=1pt, dotted] (5,12)--(3,10); \draw (3,10) node[circle,fill=cyan,inner sep=2pt] {}; %fg v1
\draw (5,12)--(7,10); \draw (7,10) node[circle ,fill,inner sep=2pt, label = right : $v_{15}$] {};  %fd v1
%---------------------- fg de v15 ----------------------------------------------
\draw (7,10)--(3,9); \draw (3,9) node[circle ,fill,inner sep=2pt, label = left : $v_{9}$] {};  %fg 15
\draw (7,10)--(10,9); \draw (10,9) node[circle ,fill,inner sep=2pt, label = right : $v_{13}$] {};  %fd 15

\draw[line width=1pt, dotted] (3,9)--(1,7); \draw (1,7) node[circle,fill=cyan,inner sep=2pt] {};  %fg 9
\draw (3,9)--(5,7); \draw (5,7) node[circle ,fill,inner sep=2pt, label = left : $v_{10}$] {};  %fd 9

\draw[line width=1pt, dotted] (5,7)--(6,5); \draw (6,5) node[circle,fill=cyan,inner sep=2pt] {};  %fd 10
\draw (5,7)--(4,5); \draw (4,5) node[circle ,fill,inner sep=2pt, label = left : $v_{8}$] {};  %fg 10

\draw[line width=1pt, dotted] (4,5)--(2,3); \draw (2,3) node[circle,fill=cyan,inner sep=2pt] {};  %fg 8
\draw (4,5)--(6,3); \draw (6,3) node[circle ,fill,inner sep=2pt, label = right : $v_{7}$] {};  %fd 8

\draw[line width=1pt, dotted] (6,3) --(5,2); \draw (5,2) node[circle,fill=cyan,inner sep=2pt] {};  %fg 7
\draw (6,3) --(7,2); \draw (7,2) node[circle ,fill,inner sep=2pt, label = right : $v_{3}$] {};  %fd 7

\draw[line width=1pt, dotted] (7,2) --(6,1); \draw (6,1) node[circle,fill=cyan,inner sep=2pt] {};  %fg 3
\draw[line width=1pt, dotted] (7,2) --(8,1); \draw (8,1) node[circle ,fill=cyan,inner sep=2pt] {};  %fd 3
%---------------------- fd de v15 ----------------------------------------------
\draw (10,9)--(8,7); \draw (8,7) node[circle ,fill,inner sep=2pt, label = left : $v_{4}$] {};  %fg 13
\draw (10,9)--(12,7); \draw (12,7) node[circle ,fill,inner sep=2pt, label = right : $v_{14}$] {};  %fd 13

\draw[line width=1pt, dotted] (8,7)--(7,5); \draw (7,5) node[circle ,fill=cyan,inner sep=2pt] {};  %fg 4
\draw[line width=1pt, dotted] (8,7)--(9,5); \draw (9,5) node[circle ,fill=cyan,inner sep=2pt] {};  %fd 4

\draw (12,7)--(10,5); \draw (10,5) node[circle ,fill,inner sep=2pt, label = right : $v_{12}$] {};  %fg 14
\draw (12,7)--(14,5); \draw (14,5) node[circle ,fill,inner sep=2pt, label = right : $v_{6}$] {};  %fd 14

\draw[line width=1pt, dotted] (10,5)--(9,3); \draw (9,3) node[circle,fill=cyan,inner sep=2pt] {};  %fg 12
\draw (10,5)--(11,3); \draw (11,3) node[circle ,fill,inner sep=2pt, label = right : $v_{11}$] {};  %fd 12

\draw[line width=1pt, dotted] (11,3)--(12,2); \draw (12,2) node[circle,fill=cyan,inner sep=2pt] {};  %fd 11
\draw (11,3)--(10,2); \draw (10,2) node[circle ,fill,inner sep=2pt, label = left : $v_{5}$] {};  %fg 11

\draw[line width=1pt, dotted] (10,2)--(9,1); \draw (9,1) node[circle ,fill=cyan,inner sep=2pt] {};  %fg 5
\draw[line width=1pt, dotted] (10,2)--(11,1); \draw (11,1) node[circle ,fill=cyan,inner sep=2pt] {};  %fd 5

\draw[line width=1pt, dotted] (14,5)--(13,3); \draw (13,3) node[circle ,fill=cyan,inner sep=2pt] {};  %fg 6
\draw (14,5)--(15,3); \draw (15,3) node[circle ,fill,inner sep=2pt, label = right : $v_{2}$] {};  %fd 6

\draw[line width=1pt, dotted] (15,3) --(16,2); \draw (16,2) node[circle ,fill=cyan,inner sep=2pt] {};  %fg 2
\draw[line width=1pt, dotted] (15,3) --(14,2); \draw (14,2) node[circle ,fill=cyan,inner sep=2pt] {};  %fd 2






\end{tikzpicture}
\captionof{figure}{Illustration de l'arbre $T$ du graphe $G_{15}$} 
\label{Illustration de l'arbre $T$ du graphe $G_{15}$}	
\end{figure}

La racine de $T$ est $w_1 (= v_1)$. Le fils droit de $w_1$ est $w_2$, le fils droit de $w_2$ est $w_3$, et ainsi de suite. L'ensemble $L(w_1)$ est composé de $w_i$ et de tous les nœuds du sous-arbre gauche de $w_i$ dans $T$.
Ainsi, le sous-arbre de $T$ enraciné à $w_i$ est composé des sommets dans $\bigcup_{j\geq1} L(w_j)$. Dans le sous-arbre gauche de $T$ enraciné à $w_i$, le fils gauche de $w_i$ est le fils le plus à gauche de $w_i$ dans l'arbre $L(w_i)$ (s'il existe), le fils droit du fils gauche dans $T$ est son prochain frère à droite dans l'arbre $L(w_i)$ (s'il existe), le fils droit du fils droit du fils gauche dans $T$ est son prochain frère suivant à droite dans l'arbre $L(w_i)$ (s'il existe), et ainsi de suite. Pour $G_3$ dans la figure \ref{(a) Graphe $G_3$, et (b) l'arbre binaire du graphe $G_3$}(a), son arbre binaire $T$ est illustré dans la figure \ref{(a) Graphe $G_3$, et (b) l'arbre binaire du graphe $G_3$}(b).
\begin{figure}[H]
\centering
\begin{minipage}{0.48\linewidth}
	\centering
	\begin{tikzpicture}[scale=0.8]
		\draw[step=1cm,gray!50,very thin] (-1,-1) grid (3,2);
		
		%\foreach \x in {0,1,2} {
		%	\draw (\x,-0.1) -- (\x,0.1) node[anchor=north,yshift=-2mm] {\x};
		%}
		
		\coordinate (1) at (0,0);
		\coordinate (2) at (2,0);
		\coordinate (3) at (1,1);
		
		\draw (1)--(2)--(3)--(1);
		
		\tikzstyle{vertex} = [draw,circle,fill=teal,inner sep = 2pt]
		\node[vertex] [label = left : $v_{1}$] 	at (1)  {};
		\node[vertex] [label = right: $v_{2}$] 	at (2)  {};
		\node[vertex] [label = above: $v_{3}$] 	at (3)  {};	
	\path (2.7 , -2)    coordinate () {} node[left]	{(a)} ;		
	\end{tikzpicture}	
\end{minipage}	
\hfill
\begin{minipage}{0.48\linewidth}
	\centering
	\begin{tikzpicture}[scale=0.8]
		
\draw (5,4) node[circle ,fill,inner sep=2pt, label = right : $v_{1}$] {};  %fg 10

\draw[line width=1pt, dotted] (5,4)--(4,3); \draw (4,3) node[circle,fill=cyan,inner sep=2pt] {};  %fg 8

\draw (5,4)--(6,3); \draw (6,3) node[circle ,fill,inner sep=2pt, label = right : $v_{3}$] {};  %fd 8

\draw[line width=1pt, dotted] (6,3) --(5,2); \draw (5,2) node[circle,fill=cyan,inner sep=2pt] {};  %fg 7
\draw (6,3) --(7,2); \draw (7,2) node[circle ,fill,inner sep=2pt, label = right : $v_{2}$] {};  %fd 7

\draw[line width=1pt, dotted] (7,2) --(6,1); \draw (6,1) node[circle,fill=cyan,inner sep=2pt] {};  %fg 3
\draw[line width=1pt, dotted] (7,2) --(8,1); \draw (8,1) node[circle ,fill=cyan,inner sep=2pt] {};  %fd 3
		\path (4.7 , .8)    coordinate () {} node[left]	{(b)} ;			
	\end{tikzpicture}	
\end{minipage}
\caption{(a) Graphe $G_3$, et (b) l'arbre binaire du graphe $G_3$}
\label{(a) Graphe $G_3$, et (b) l'arbre binaire du graphe $G_3$}
\end{figure}


Étant donné que $v_k$ est intégré en un point $\mu(P_1,P_2)$ d'intersection des deux diagonales, la première avec une pente $+1$ passant par $w_p$ et la deuxième avec une pente $-1$ passant par $w_q$ , on a le point :\\  
\[ (1) : \mu(P_1,P_2) = [ \frac{1}{2}(x(w_q) + x(w_p) + y(w_q) − y(w_p)), \frac{1}{2}(x(w_q) + x(w_p) + y(w_q) − y(w_p)) ] \]
Nous avons :

\[ (2) : x(v_k) = \frac{1}{2} [ x(w_q) + x(w_p) + y(w_q) − y(w_p)] \]
\[ (3) : y(v_k) = \frac{1}{2} [ x(w_q) + x(w_p) + y(w_q) − y(w_p)] \]
\[ (4) : x(vk )-x(wp) = \frac{1}{2} [ x(wq) − x (wp) + y(wq) - y(wp)] \]

La première observation cruciale est que, lorsque nous intégrons $v_k$, il n'est pas nécessaire de connaître la position exacte de $w_p$ et $w_q$. Si nous connaissons uniquement leurs coordonnées $y$ et leurs coordonnées $x$ relatives, c'est-à-dire 
\(x(w_q) - x(w_p)\), alors selon l'équation (3), nous pouvons calculer $y(v_k)$ et selon l'équation (4), nous pouvons calculer la coordonnée $x$ de $v_k$ relative à $w_p$, c'est-à-dire $x(v_k) - x(w_p)$.

\subsection{Implémentation de l'algorithme Shift method}

Pour chaque sommet \(v \neq v_1\), le décalage $x$ de $v$ est défini comme $\Delta x(v) = x(v) - x(w)$, où $w$ est le parent de $v$ dans $T$. Plus généralement, si $w$ est un ancêtre de $v$, alors le décalage $x$ entre $w$ et $v$ est \(\Delta x(w,v) = x(v) - x(w)\).
Avec chaque sommet v, nous stockons les informations suivantes : 
\begin{itemize}
\item $left(v)$ = le fils gauche de $v$ dans $T$ ; 
\item $right(v)$ = le fils droit de $v$ dans $T$ ; 
\item $\Delta x(v)$ = le décalage $x$ de $v$ par rapport à son parent dans $T$ ; 
\item $y(u)$ = la coordonnée $y$ de $v$.
\end{itemize}
{\color{white}-}
\\
{\color{white}-}
L'algorithme se compose de deux phases: Dans la première phase, nous ajoutons de nouveaux sommets un par un, et à chaque ajout d'un sommet, nous calculons son décalage $x$ et sa coordonnée $y$, et mettons à jour les décalages $x$ de un ou deux autres sommets. 
Dans la deuxième phase, nous parcourons l'arbre $T$ et calculons les coordonnées $x$ finales en accumulant les décalages.
\\ \\
\textbf{La première phase} est mise en œuvre comme suit. Tout d'abord, nous initialisons les valeurs stockées à $v_1$, $v_2$ et $v_3$ comme suit voir figure \ref{(a) Graphe $G_3$, et (b) l'arbre binaire du graphe $G_3$} :
\begin{itemize}
\item $\Delta x(v_1) = 0$ ; $y(v_1) = 0$ ; $right(v_1) = v_3$ ; $left(v_1) = nil$ ; 
\item $\Delta x(v_3) = 1$ ; $y(v_3) = 1$ ; $right(v_3) = v_2$ ; $left(v_3) = nil$ ; 
\item $\Delta x(v_2) = 1$ ; $y(v_2) = 0$ ; $right(v_2) = nil$ ; $left(v_2) = nil$. 
\end{itemize}
{\color{white}-}
\\
{\color{white}-}
Ensuite, nous intégrons les autres sommets, un par un, comme suit :
{\color{white}-}
\\
{\color{white}-}
\begin{algorithm}[H]
\label{algorithm}
%\KwInput{(Graphe, son ordre canonique)}
%\KwOutput{(Graphe décalé par la méthode shift)}
\For{(k:=4 \textbf{jusqu'à} 4)}{ 
\SetAlgoNoEnd % Ajout de la commande
\Begin{
	%\tcp{Soit $v_1, \dots, v_n$ l'ordre canoniquedu graphe G}
	
Soit $w_1, w_2,\dots, w_t$ le cycle externe $C_o(G_{k-1})$ de $G_{k-1}$ ; voir figure \ref{Illustration de la position du sommet $v_k$ sur le graphe $G_{k−1}$, et l'ensemble L($v_i$) sous forme d'une structure arborescente}\\
Soit \(w_p, w_{p+1},\dots, w_q\) les voisins de $v_k$ sur $C_o(G_{k-1})$ ; \\
Augmenter le décalage de $w_{p+1},\dots, w_{q-1}$ de $+1$ vers la droite; \\ 
Augmenter le décalage de $w_{q},\dots, w_{t}$ de $+2$ vers la droite; \\ 
\tcp{ Calcules:}
\(\Delta x(w_p,w_q) = \Delta x(w_{p+1}) + \Delta x(w_{p+2}) +....+ \Delta x(w_q)\) ; \\

\(\Delta x(v_k) = \frac{1}{2}[\Delta x(w_p,w_q) + y(w_q) - y(w_p)]\) ; \textit{cf.} (4) \\

\( y(v_k) = \frac{1}{2}[\Delta x(w_p,w_q) + y(w_q) + y(w_p)] \);  \textit{cf.} (3) \\

\(\Delta x(w_q) = \Delta x(w_p,w_q) - \Delta x(v_k) \); \\
\If{\((p + 1) \neq q\)}{ \( \Delta x(w_{p+1}) = \Delta x(w_{p+1}) - \Delta x(v_k) \)\; }
\(right(w_p) = v_k \) et \( right(v_k) = w_q \) ; \\
%\SetKwIF{If}{ElseIf}{Else}{Si}{Alors}{Sinon Si}{Sinon}{Fin si}
%\SetNoline
\If{\((p + 1) \neq q\)}{  \(left(v_k) = w_{p+1} \) et \( right(w_{q-1}) = nil \)\; }
\Else {  \(left(v_k) = nil\)\; }
	}
}
\caption{Algorithm de Shift method}
\end{algorithm}
\ULforem %%%% enable auto underline
{\color{white}-}
\\ \\
{\color{white}-}
On observe dans les formules de calcules, que les formules de la ligne (5), la ligne (6), la ligne (8), la ligne (9), et la ligne (10) sont clairement constants, mais la ligne (7) prend plus de temps, donc il suffit simplement de calculer combien de temps avons-nous réellement besoin pour connaître la durée d'exécution, pour cela, nous devons prendre la distance $x$ de $w_q$ et de tous les sommets à l'intérieur. Mais les sommets à l'intérieur ce sont des sommets déjà traités. donc nous ne devons les regarder qu'une seule fois, car ils disparaissent de la face extérieure, donc nous ne regardons qu'un seul sommet plus la somme des sommets qui sont enlevés de la face extérieure, et ceux à chaque étape, au total nous examinons $n$ sommets ici à la ligne ligne (7) : 
\[\Delta_x(w_{p+1}) + \dots + \Delta_x(w_{q})\]
\\ \\
La figure \ref{Illustration de la position du sommet $v_k$ sur le graphe $G_{k−1}$, et l'ensemble L($v_i$) sous forme d'une structure arborescente} illustre la construction de $T$ pour $G_k$ à partir de $T$ pour $G_{k-1}$ par l'algorithme ci-dessus.
\\ \\
\textbf{Dans la deuxième phase :} 
nous calculons la coordonnée $x(v_i)$ pour chaque sommet $v_i$ dans $G$. Soit $Q$ le chemin de la racine $v_1$ à $v_i$ dans l'arbre $T$. Ensuite, $x(v_i)$ est égal à la somme des déplacements horizontaux $(\Delta(x))$ pour chaque sommet $x$ situé sur le chemin $Q$.
On peut calculer $x(v_i)$ pour tous les sommets $v_i$ en invoquant la procédure Accumulate-Offset$(v_1, 0)$; 
la procédure Accumulate-Offset est la suivante : \\

\begin{algorithm}[H]
\label{algorithm}
\KwInput{($v$: sommet ; $\delta$: entier)}
%\KwOutput{(Graphe décalé par la méthode shift)}
\Begin{
\If{\((p + 1) \neq q\)}{ 
\( \Delta (u) = \Delta (u) + \delta  \)\; 
    Accumulate-Offset$(left(u), Ax(u))$ \; 
    Accumulate-Offset$(droit(v), Ax(v))$ \; 
   } 
}
\caption{Procédure Accumulate-Offset}
\end{algorithm}
\ULforem %%%% enable auto underline
{\color{white}-}
\\ \\
{\color{white}-}
\subsection{Complexité}
\label{Complexité}
Il est clair que \(x(v_i) = \Delta x(v_i)\) pour chaque sommet $v_i$ dans $G$.\\
La première phase prend un temps linéaire, car l'ajout d'un sommet $v_k$ prend au plus un temps $\theta(d(v_k))$, $d(v_k)$ représente le degré du sommet $v_k$ dans le graphe $G$. Le degré d'un sommet fait référence au nombre de voisins qu'il possède, c'est-à-dire le nombre d'arêtes qui y sont incidentes.
\\
La deuxième phase, c'est-à-dire Accumulate-Offset, prend un temps proportionnel au nombre de nœuds dans $T$. Ainsi, l'algorithme prend un temps linéaire au total \citep{TakaoSaidur}.
\\ \\
Et nous obtenons ainsi notre temps d'exécution et notre résultat principal, à savoir que tout graphe planaire à $n$ sommets possède un dessin planaire de ligne droite de taille \((2n-4) \times (n-2)\), peut-être calculer en temps linéaire, cet algorithme est à la base de nombreux algorithmes de dessin de graphes, et même pour les graphes planaires, il y a eu quelques améliorations. 
\\ 
Tout d'abord, en 1996, \textbf{Kant} (\textbf{Chrobak}) a prouvé que si le graphe d'entrée est trié connecté, alors nous pouvons également dessiner toutes les faces convexes, en conservant la même surface, et ce dans le même temps d'exécution, et un an plus tard, avec \textbf{Chrobak}, ils ont même amélioré la limite de surface à \((n-2) \times (n-2)\) , Ce dessin peut être calculé en un temps $\theta(n)$, et cette limite de surface a encore été améliorée, par \textbf{Brandenburg} en 2008, à \((\frac{4}{3}n \times \frac{2}{3}n )\), Ce dessin peut être calculé en un temps $\theta(n)$, il est donc un peu plus large, mais il n'est pas si haut, mais le \((n-2) \times (n-2)\). est $n^2$, alors que celui-ci n'est que \(\frac{8}{9}n^2\), c'est donc un peu mieux et la meilleure borne inférieure connue à ce jour est \(\frac{2}{3}n^2\), cela réduit l'écart entre eux, mais il reste encore à déterminer si la réponse correcte est $\frac{2}{3}$, $\frac{8}{9}$ ou quelque chose entre les deux \citep{PhilippKindermann}.






%==========================================================================
%==========================================================================
%                  Étude expérimentale
%==========================================================================
%==========================================================================

\newpage	
%	\section{Implémtation}
%	\label{Implémtation}

\section{Étude expérimentale}
Dans le cadre de cette étude expérimentale, nous avons réalisé des expériences visant à évaluer les performances de l'algorithme shiftmethode. Nous avons utilisé trois ensembles de données, chacun composé d'une série de valeurs de taille de graphe (nombre de sommets) et de temps d'exécution. Ces ensembles de données nous permettent d'observer comment les performances de l'algorithme évoluent en fonction de la taille des graphes (nombre de sommets). Dans cette section, nous présenterons ces ensembles de données, ainsi que la méthodologie mise en place pour mesurer les temps d'exécution de l'algorithme.

\subsection{Ensembles de données}
Pour chaque ensemble de données, nous avons mesuré le temps d'exécution de l'algorithme pour chaque taille de graphe. Les résultats sont visualisés à l'aide de graphes, mettant en évidence la relation entre la taille du graphe et le temps d'exécution. 
\\ \\
\textbf{Première partie}
Pour les petites tailles des graphe avec un nombre de sommets qui vont 100 à 1.000 sommets répété $\times100$
\\ \\
%*********************************************************************
%*********************************************************************
\begin{tikzpicture}
\begin{axis}[
    title={Pour les sommets qui vont 100 sommets à 1.000},
    xlabel={Nombre de Sommets},
    ylabel={Temps (Nanoseconde)},
    width=15cm,
    height=15cm,
    grid=major,
    minor tick num=4,
    grid style={dashed,gray!30},
    nodes near coords,
    legend pos=north west, % Position de la légende à gauche
    legend entries={$w_p=n$ et $w_q=v_2$}, % Noms des séries de données
]


%=================================
% de 100 à 1.000 x100 wp=n et wq=v2
%=================================
\addplot[mark=*,blue] coordinates {
(100,393202)
(200,576860)
(300,856099)
(400,1144122)
(500,1387455)
(600,1680528)
(800,2211097)
(1000,2896966)


};

\end{axis}
\end{tikzpicture}



\newpage
\textbf{Deuxième partie}
\\ \\

Pour les petites tailles des graphe avec un nombre de sommets qui vont 1.000 à 10.000 sommets répété $\times50$
\\ \\


\begin{tikzpicture}
\begin{axis}[
    title={Pour les sommets qui vont 100 sommets à 1.000},
    xlabel={Nombre de Sommets},
    ylabel={Temps (Nanoseconde)},
    width=15cm,
    height=15cm,
    grid=major,
    minor tick num=4,
    grid style={dashed,gray!30},
    nodes near coords,
    legend pos=north west, % Position de la légende à gauche
    legend entries={$w_p=n$ et $w_q=v_2$}, % Noms des séries de données
]

\addplot[mark=*,red] coordinates {
%====================================
% de 1.000 à 10.000 x50 wp=N wq=2
%=================================
(1000 ,2334168)
(2000 ,5179482)
(3000 ,7187160)
(4000 ,9454684)
(5000 ,14432074)
(6000 ,27266300)
(10000,36247052)

};
\end{axis}
\end{tikzpicture}


\newpage
\textbf{Troisième partie}
\\ \\
Pour les petites tailles des graphe avec un nombre de sommets qui vont 10.00 à 100.000 sommets répété $\times10$
\\ \\


\begin{tikzpicture}
\begin{axis}[
    title={Pour les sommets qui vont 100 sommets à 1.000},
    xlabel={Nombre de Sommets},
    ylabel={Temps (Nanoseconde)},
    width=15cm,
    height=15cm,
    grid=major,
    minor tick num=4,
    grid style={dashed,gray!30},
    nodes near coords,
    legend pos=north west, % Position de la légende à gauche
    legend entries={$w_p=n$ et $w_q=v_2$}, % Noms des séries de données
]

\addplot[mark=*,green!90!black] coordinates {
%====================================
% de 10.000 à 100.000 x10
%=================================
(10000,10680200)
(20000,47793080)
(30000,69966630)
(40000,104774680)
(50000,115678900)
(60000,139739280)
(100000,329836070)
};
\end{axis}
\end{tikzpicture}

\newpage
%*********************************************************************
%\textbf{Tableau Récapitulatif}

%*********************************************************************
%*********************************************************************
Dans cette étude expérimentale, nous avons évalué les performances de l'algorithme shiftmethode pour le dessin de graphes planaires en ligne droite. Trois ensembles de tests ont été réalisés en variant la taille des graphes : les petites tailles (100 à 10.000 sommets), les tailles moyennes (1.000 à 10.000 sommets) et les grandes tailles (10.000 à 100.000 sommets).
\\ \\
Les résultats obtenus ont confirmé la complexité linéaire de l'algorithme shiftmethode, en démontrant une relation directe entre la taille de l'entrée (le nombre de sommets) et le temps d'exécution. Lorsque la taille de l'entrée était multipliée approximativement par 2, le temps d'exécution était également multiplié par environ 2, confirmant ainsi la caractéristique linéaire de l'algorithme.
\\ \\
Ces résultats expérimentaux renforcent donc l'idée que l'algorithme shiftmethode est efficace pour le dessin de graphes planaires en ligne droite, en offrant une complexité linéaire proche de la théorie. Cette méthode présente un intérêt pratique pour le dessin de graphes de différentes tailles, fournissant des résultats satisfaisants en termes de temps d'exécution.
\\ \\
En conclusion, l'étude expérimentale confirme l'efficacité de l'algorithme shiftmethode pour le dessin de graphes planaires en ligne droite, en respectant une complexité linéaire. Les résultats obtenus soutiennent son utilisation pratique dans le domaine, en offrant des performances cohérentes et prévisibles pour des graphes de diverses tailles.

%*********************************************************************
%*********************************************************************
\newpage
\section{Méthodologie}
Dans la méthodologie de cette étude, nous détaillerons le contexte expérimental dans lequel les performances de l'algorithme shiftmethode ont été évaluées, Données d'entrée. 
\\
\subsection{Description de l'environnement de travail}
Nous avons utilisé un système informatique spécifique, dont les caractéristiques sont les suivantes :

\begin{enumerate}
\item \textbf{Configuration matérielle}
\begin{itemize}
	\item \textbf{Processeur} : 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz
	\item \textbf{Type de système} : Système d'exploitation 64 bits, processeur x64
	\item \textbf{Mémoire RAM} : 16,0 Go (15,8 Go utilisables)
\end{itemize}
\item \textbf{Système d'exploitation}
\begin{itemize}
	\item Windows 10 Enterprise
\end{itemize}
\item \textbf{Environnement de développement}
\begin{itemize}
	\item \textbf{Langage de programmation} : Java
	\item \textbf{Bibliothèque système JRE (Java Runtime Environment)} : JavaSE-1.8
	\item \textbf{IDE (Integrated Development Environment)} : Eclipse
\end{itemize}
\end{enumerate}


Par la suite, nous poursuivrons en exposant en détail le code implémenté, en mettant l'accent sur les algorithmes clés utilisés et les structures de données employées pour résoudre efficacement le problème du dessin de graphes planaires en ligne droite.
\\ \\
\subsection{Données d'entrée}
Dans le cadre de la méthodologie, les données d'entrée jouent un rôle crucial dans l'évaluation des performances de l'algorithme shiftmethode. 
\\ \\
\textbf{Premier code}
\\ \\
Dans le premier code utilisé, nous avons adopté une approche interactive où l'utilisateur entre les points un par un, permettant ainsi de définir l'ordre canonique du graphe. Plus précisément,le programme demande à l'utilisateur de spécifier les valeurs de \(w_p\) (point inférieur) et \(w_q\) (point supérieur) par rapport au contour du graphe. Ensuite, le graphe est décalé en conséquence, et l'algorithme calcule les intersections des deux droites : l'une ayant une pente de \(+1\) et passante par \(w_p\), et l'autre ayant une pente de \(-1\) et passante par \(w_q\). Ces intersections forment un triangle isocèle avec un angle droit en \(v_k\), le sommet calculé. 
\\ \\
Le premier code a également pour fonction d'afficher les résultats obtenus. Il affiche les valeurs des points avant et après le décalage, ainsi que les arêtes qui ont été utilisées pour les dessins dans la sous-section 9.1 (Dessin avec shiftmethode) de la section 9 (Appliquer shiftmethode). Ces informations sont essentielles pour comprendre les manipulations effectuées sur le graphe et analyser les résultats obtenus pour pouvoir les dessiner.
\\ \\
\textbf{Deuxième code}
\\ 
Dans le cadre de l'optimisation du code, plusieurs améliorations ont été apportées pour améliorer les performances. Voici un résumé des principales optimisations effectuées :

\begin{enumerate}
\item 1. Utilisation d'une structure de données plus efficace : Au lieu d'utiliser une ArrayList pour stocker les points, une HashMap a été utilisée qui offre une complexité de recherche de \( \theta(1)\), ce qui est plus rapide que la recherche linéaire dans une liste. Cela permet d'accélérer les opérations de recherche et d'accès aux points.

\item 2. Modification des méthodes de gestion des points : Les méthodes getPoints() et addPoint() ont été modifiées pour utiliser les fonctionnalités de la HashMap. La méthode getPoints() renvoie désormais une nouvelle ArrayList de points à partir des valeurs de la HashMap. La méthode addPoint() utilise la méthode put() de la HashMap pour ajouter le point avec son nom comme clé.

\item 3. Amélioration de la méthode printCoordonnee() : A été mise à jour pour obtenir directement le nom et les coordonnées de chaque point, améliorant ainsi l'efficacité de l'affichage.

\item 4. Révision de la méthode getNeighbors() : A été révisée pour tenir compte de l'utilisation de la HashMap. Les indices de matrice ont été ajustés pour correspondre aux noms des points, assurant ainsi une correspondance correcte entre les points et leurs voisins.

\item Pour stocker les points. nous avons modifié la classe GraphNode pour utiliser une HashMap au lieu d'une ArrayList pour stocker les points. Par exemple :
\\
\begin{lstlisting}[caption={Extrait de code de la classe GraphNode.}, label={Extrait de code de la classe GraphNode.}]
private Map<String, MyPoint> points;
	
//lors de l ajout d un point, nous pouvons l ajouter a la HashMap :
public void addPoint(MyPoint point) {
	points.add(point);
	points.put(point.getName(), point);
}
	
// Et on peut obtenir un point par son nom avec une complexite O(1) :
public MyPoint getPointByName(String name) {
	return points.get(name);
}
\end{lstlisting}

Cela nous permettrait de récupérer un point par son nom en temps constant \( \theta(1)\) au lieu du temps linéaire \( \theta(n)\).

\item  Pour améliorer les performances, évitez les appels redondants aux mêmes méthodes de calcul. Par exemple, dans la méthode addPointBetween(), l'appel à la méthode graph.getPointByName(firstPointName) et graph.getPointByName(secondPointName) plusieurs fois. Au lieu de cela, on peut appeler ces méthodes une fois, stocker les résultats dans des variables et les réutiliser par la suite pour éviter les calculs redondants.

\item Dans le code certaines parties, comme dans la méthode apresWq(), y a une boucle while(true) avec une condition de sortie break à l'intérieur. Cela a étè simplifié en une boucle do-while.

\item Commenter les opérations inutiles comme afficher le graphe, et les arrêtes.

\item Pour l'ordre canonique, et lors  les valeurs de $w_p$ et $w_q$ sont générées aléatoirement à mesure que le nombre de sommets augmente. Voici le code qui génère ces valeurs dynamiquement :
\begin{lstlisting}[caption={Extrait de code représentant la génération d'un ordre canonique aléatoire.}, label={Extrait de code représentant la génération d'un ordre canonique aléatoire.}]
	int wp, wq;
	do {
		wp = random.nextInt(tour - 1);
		wq = wp + 1 + random.nextInt(tour - wp - 1);
	} while (wp == wq || wq == tour - 1);
	String wpName = "v" + Integer.toString(wp+1);
	String wqName = "v" + Integer.toString(wq+1);
\end{lstlisting}
Cependant, il s'avère qu'avec cette approche, il existe un risque d'obtenir des cordes dans le graphe. Pour remédier à cela, nous avons décidé de prendre $w_p = n$ et $w_q = v_2$.
\\ \\ 
L’algorithme écrit en langage Java figure en annexe sur ce lien Github : \\
\url{https://github.com/Kazzoul-Youness/StraightLine-ShiftMethod}
\end{enumerate}




%=====================================================
\subsection{Méthode de mesure} 
Pour mesurer les performances de l'algorithme, nous avons utilisé des compteurs de temps en nanosecondes. Ce qui permet une évaluation précise de l'efficacité de l'algorithme en fonction de la taille du graphe. Voici la méthodologie utilisée :
\\ \\
%=====================================================
%{\color{white}-}
%\\ \\ \\
%{\color{white}-}
\textbf{Mesure et calcul des temps d'exécution}
\\ \\
\textbf{Nombre total de tests :}
\\
On a effectué des tests pour la plage de 100 à 1 000 sommets, avec une répétition de chaque test 100 fois.
Pour la plage de 1 000 à 10 000 sommets, on a effectué chaque test 10 fois.
Dans la plage de 10 000 à 100 000 sommets, on a effectué chaque test 10 fois.
\\ \\ \\
\textbf{Calcul du temps d'exécution :}
\\ \\
On a mesuré le temps d'exécution pour chaque test en utilisant la variable "executionTimesTest" pour stocker les temps d'exécution individuels de chaque test.
Pour chaque test, on a calculé le temps d'exécution en sommant les temps d'exécution individuels des sommets générés à l'aide de la méthode de décalage.
Calcul du total d'exécutions :

On a calculé le total d'exécutions en sommant les temps d'exécution de tous les tests en utilisant la variable "sumTest".
Dans cette variable, on a stocké la somme des temps d'exécution de tous les tests effectués pour les différentes plages de nombres de sommets.
{\color{white}-}
\\
{\color{white}-}
\begin{lstlisting}[caption={Extrait de code représentant la Méthode utilisée pour le calcule des mesures.}, label={Extrait de code représentant la Méthode utilisée pour le calcule des mesures.}]
int NBtest = 10;
int NbSommets = 40000; 	    // exemple pour 40.000 sommets
long[] executionTimesTest = new long[NBtest];
long[] executionTimesTour = new long[NbSommets + 1];
long startTimeTest, endTimeTest, startTimeTour, endTimeTour;		

for (int test = 0; test < NBtest; test++) {
    //Chaque sommet qui va etre placer par Shift method, on genere son ordre canonique, et seulement a ce moment qu'on commence le calcule du temps. 
	
    // Debut du calcul du temps en nanosecondes
    long startTime = System.nanoTime();
	
    // Operations de calcul de l'algorithme
    //1. Decalage Milieu +1 unite vers la droite
    //2. Decalage Droit +2 unites vers la droite
    //3. Calcule les coordonnees x et y du point d'intersection
    //4. Creer le point d'intersection avec un nom qui s'incremente automatiquement
    //5. Ajouter le point d'intersection au graphe
    //6. Ajouter le point vk a la liste sur le contour   
	
    // Fin du calcul du temps en nanosecondes
    endTimeTour = System.nanoTime();
    executionTimesTour[tour] = endTimeTour - startTimeTour;
}	
    long sumTour = 0;
    for (int i = 3; i <= NbSommets; i++) {
        sumTour += executionTimesTour[i];
    }					
    executionTimesTest[test] = +sumTour;
    }		
    long avg, sumTest=0;
    for (int i = 0; i < executionTimesTest.length; i++) {
	sumTest += executionTimesTest[i];
    }
    avg = sumTest/NBtest;
    System.out.println("Temps pour "+NbSommets+" sommets = "+ avg + " Nano");
    System.out.println("("+NbSommets+","+ avg + ")");
\end{lstlisting}
{\color{white}-}
\\ \\
{\color{white}-}
L’algorithme écrit en langage Java figure en annexe sur ce lien Github : \\
\url{https://github.com/Kazzoul-Youness/StraightLine-ShiftMethod}

%=====================================================

%=====================================================
\subsection{Limitations et problèmes rencontrés} 
Plusieurs erreurs ont était rencontré, notamment :
\\ \\
Une erreur \textbf{java.lang.ArrayIndexOutOfBoundsException} s'est produite, indiquant une tentative d'accès à un indice en dehors des limites du tableau. Dans le contexte de l'algorithme Shift method, cette erreur était liée à l'initialisation des trois premiers sommets, qui constitue une étape spécifique de l'algorithme. Pour remédier à cette erreur, une correction a été apportée en ajustant la boucle principale pour commencer à partir de l'indice 3, afin d'accéder uniquement aux indices valides du tableau executionTimes.
\\ \\ \\
L'erreur \textbf{java.lang.OutOfMemoryError: Java heap space} s'est produite, indiquant que le programme a tenté d'allouer plus de données à la mémoire heap de la JVM (Java Virtual Machine) qu'elle n'est capable de contenir. Plusieurs approches ont été envisagées pour remédier à cette situation. Dans ce cas spécifique, une tentative a été faite en exécutant le programme sur un système Ubuntu Linux tout en augmentant la taille de la mémoire à 2 Go à l'aide de la commande java -Xmx2g MonProgramme. Cependant, il a été observé que la fermeture des fenêtres et des autres programmes consommateurs de ressources était nécessaire pour libérer suffisamment de mémoire et permettre une exécution correcte du programme. Il convient de souligner l'importance de l'optimisation des ressources et de la gestion efficace de la mémoire pour éviter les erreurs de type OutOfMemoryError.
\\ \\ \\
\textbf{Erreur java.lang.StackOverflowError 
\\
at ShiftMethod.moveChildren(ShiftMethod.java:247)} : Cette erreur s'est produite généralement dans le cas de récursion non contrôlée, où une fonction moveChildren s'appelle elle-même indéfiniment, ce qui a conduit à un débordement de la pile d'appels, celle-ci s'appelle récursivement pour chaque enfant du parent. Et pour résoudre cette erreur, une approche consiste à limiter le nombre maximal de sommets à 100 000, ce qui correspond à la taille maximale du graphe d'entrée. Cette limitation permet de contrôler la profondeur de la récursion et d'éviter le dépassement de la pile d'appels.
\\ \\ \\
En prenant en compte ces erreurs rencontrées lors de l'exécution de l'algorithme Shift method et les solutions qui ont été apportées pour les résoudre, il est possible d'améliorer la stabilité et la fiabilité de l'algorithme. Ces erreurs ont permis de mieux comprendre les contraintes et les limitations de l'algorithme, ainsi que l'importance de mettre en place des mécanismes appropriés pour les détecter, les prévenir ou les gérer de manière efficace. En documentant ces expériences et en tirant des leçons des erreurs rencontrées, il est possible de renforcer la robustesse de l'algorithme et d'optimiser ses performances dans des contextes similaires.
\\ \\ \\
L’algorithme écrit en langage Java figure en annexe sur ce lien GitHub : \\
\url{https://github.com/Kazzoul-Youness/StraightLine-ShiftMethod}


\newpage

\subsection{Implémentation en language Java}
\begin{enumerate}
   \item Dans la première implémentation de la méthode shift dossier \textbf{Graphe} dans le github, nous calculons un sommet à la fois. Pour cela, nous devons définir $w_p$ et $w_q$. Il n'est pas nécessaire d'avoir introduit tout le graphe et son ordre canonique. Les valeurs de $w_p$ et $w_q$ sont définis par l'utilisateur et au fur et à mesure le nombre de sommets augmentent.\\
Lien : \url{https://github.com/Kazzoul-Youness/StraightLine-ShiftMethod/tree/main/Graph}
\\ 
\item Dans la deuxième implémentation de la méthode shift dossier \textbf{ShiftMethodTest} dans le github, vise à calculer les temps d'exécution du programme, nous ne générons pas aléatoirement les valeurs de $w_p$ et $w_q$, il s'avère qu'avec cette approche, il existe un risque d'obtenir des cordes \ref{Corde} qui vont conduire notre graphe à un graphe non 2-connexe, ou avoir des points isolés. Pour remédier à cela, nous avons décidé de prendre : 
$w_p = n$ et $w_q = v_2$, ou $w_p = 1$ et $w_q = i$, avec n le nombre de sommets et i l'indice de l'étape de la boucle principal, \(  3 \leq i \leq n \) \\
Lien : \url{https://github.com/Kazzoul-Youness/StraightLine-ShiftMethod/tree/main/ShiftMethodTest} 
\end{enumerate}
Pour toutes les informations sont sur le dossier parent sur le GitHub : \url{https://github.com/Kazzoul-Youness/StraightLine-ShiftMethod}

%=====================================================
%       Conclusion
%=====================================================
\newpage    
\section{Conclusion}
En conclusion, notre étude approfondie de la méthode Shift method pour la représentation en ligne droite des graphes planaires a mis en évidence son importance dans de nombreux domaines d'application. L'algorithme de Shift method, développé par Fraysseix, Pach et Pollack, offre une approche efficace pour créer des représentations visuelles claires et ordonnées de ces graphes.
\\ \\
Dans ce travail, nous avons examiné en détail les étapes clés de l'algorithme, en mettant l'accent sur l'ordre canonique des sommets, qui joue un rôle crucial dans la préservation de la structure et de la connectivité du graphe d'origine. Nous avons également exploré les techniques utilisées pour organiser les sommets de manière linéaire et créer des tracés optimaux, ainsi que les heuristiques de placement des arêtes pour améliorer l'esthétique des dessins en lignes droites des graphes planaires.
\\ \\
Cette étude a contribué à une meilleure compréhension de la représentation en ligne droite des graphes planaires et a ouvert de nouvelles perspectives intéressantes pour la visualisation et l'analyse de ces graphes. L'adoption de l'algorithme de Shift method comme outil essentiel dans ce domaine est fortement recommandée, étant donné sa capacité à générer des dessins clairs et compréhensibles, tout en préservant la structure sous-jacente du graphe.
\\ \\
Nous avons également analysé la complexité de l'algorithme de Shift method et identifié des opportunités d'optimisation pour améliorer ses performances. Des méthodes alternatives pour le calcul des coordonnées des sommets ont été proposées, permettant de réduire le temps de calcul nécessaire.
\\ \\
En conclusion, la représentation en ligne droite des graphes planaires reste un domaine de recherche riche en applications pratiques et en défis théoriques. L'algorithme de Shift method se positionne comme une approche efficace pour créer des dessins en lignes droites de ces graphes, tout en prenant en compte des considérations esthétiques. Cette étude contribue à une meilleure compréhension de la méthode et encourage l'exploration de nouvelles perspectives dans le domaine de la visualisation et de l'analyse des graphes planaires.
\\
Nous espérons que ce travail incitera à des recherches supplémentaires dans ce domaine et favorisera l'adoption de l'algorithme de Shift method comme outil essentiel pour la représentation en ligne droite des graphes planaires, permettant ainsi d'améliorer la compréhension et l'analyse de ces structures.


%=====================================================

%\citep[chap. 2]{VismaraTamassia}
%	\nocite{BRSG} \nocite{DieterJungnickel} \nocite{HasslerWhitney} \nocite{MathieuSABLIK}
%	\nocite{MatousekNesetril} \nocite{RDiestel} \nocite{PortieMenyr} \nocite{WestDouglasB}
%	\nocite{PhilippKindermann} 
%	\nocite{mehl}

\newpage

\bibliographystyle{plainnat}
%	\bibliography{myrefs}	
%	\bibliographystyle{plain}
\bibliography{ref}


%====================================================================
\end{document}
%====================================================================








