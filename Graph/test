      
        points.add(new Point(0,0)); //V1
        points.add(new Point(2,2)); //V2
        points.add(new Point(5,5)); //V3
        points.add(new Point(7,3)); //V4
        points.add(new Point(8,4)); //WP
        points.add(new Point(9,5)); //WP+1
        points.add(new Point(10,6)); //
        points.add(new Point(12,4));
        points.add(new Point(12,8)); //VP
        points.add(new Point(13,5));
        points.add(new Point(14,6));
        points.add(new Point(15,5)); //Wq_1
        points.add(new Point(16,4)); //Wq
        points.add(new Point(17,3));
        points.add(new Point(19,5));
        points.add(new Point(21,7));
        points.add(new Point(24,4)); //Wt-1
        points.add(new Point(28,0)); //Wt
               
               
        //        System.out.println("=============================================");
//        
//        // Un carré de taille 2 avec un sommet en (0, 0) :
//        List<Point> points3 = new ArrayList<>();
//        points3.add(new Point(0, 0));
//        points3.add(new Point(2, 0));
//        points3.add(new Point(2, 2));
//        points3.add(new Point(0, 2));
//        points3.add(new Point(1, 1));
//        
//     // compute the shifted triangulation
//        List<Point> triangulation3 = shift(points3);
//
//        // print the vertices of the shifted triangulation
//        System.out.println("Vertices of the shifted triangulation: \n"
//        		+ "Carré de taille 2 avec un sommet en (0, 0) :");
//        for (Point point3 : triangulation3) {
//            System.out.println("(" + point3.x + ", " + point3.y + ")");
//        }
//        
//        System.out.println("=============================================");
//        //=====================================================================
//        //Un pentagone régulier de taille 2 avec un sommet en (0, 0) :
//         
//        List<Point> points4 = new ArrayList<>();
//        points4.add(new Point(0, 0));
//        points4.add(new Point(1, (int) Math.sqrt(3)));
//        points4.add(new Point(2, 0));
//        points4.add(new Point(1, -1*(int) Math.sqrt(3)));
//        points4.add(new Point(-1, -1*(int) Math.sqrt(3)));
//        points4.add(new Point(1, 1));
//        points4.add(new Point(0, 2));
//        points4.add(new Point(2, 2));
//        
//     // compute the shifted triangulation
//        List<Point> triangulation4 = shift(points4);
//
//        // print the vertices of the shifted triangulation
//        System.out.println("Vertices of the shifted triangulation: \n"
//        		+ "Pentagone régulier de taille 2 avec un sommet en (0, 0)");
//        for (Point point4 : triangulation4) {
//            System.out.println("(" + point4.x + ", " + point4.y + ")");
//        }
//        
              
              
              
              
              
              
              
              
              
              
              
              
              
              
              import java.util.Scanner;


public class ShiftMethod {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		//System.out.print("Combien de points vous avez ? ");
		// int nbPoints = scanner.nextInt();
		int nbPoints = 3; int stop = 0;
		int[][] points = new int[nbPoints][2];
		// Déclaration d'un tableau temporaire pour les points du milieu
		int[][] pointsMilieu = new int[nbPoints][2];
		int countMilieu = 0;
		
		String[] nomsPoints = new String[nbPoints]; // tableau pour stocker les noms des points
		points[0][0] = 0; points[0][1] = 0;
		nomsPoints[0] = "v_" + (1);
		points[1][0] = (2*nbPoints -4); points[1][1] = 0;
		nomsPoints[1] = "v_" + (2);
		points[2][0] = 1; points[2][1] = 1;
		nomsPoints[2] = "v_" + (3);

		// créer un graphe à partir de ces points
		int[][] adjMatrix = new int[nbPoints][nbPoints];
		adjMatrix[0][2] = 1; // v_1 -> v_3
		adjMatrix[2][1] = 1; // v_3 -> v_2
		adjMatrix[1][0] = 1; // v_2 -> v_1

		do {

			// Afficher la matrice d'adjacence
			// Parcourir la matrice d'adjacence et afficher les arêtes correspondantes
			for (int i = 0; i < nbPoints; i++) {
				for (int j = 0; j < nbPoints; j++) {
					if (adjMatrix[i][j] == 1) {
						System.out.printf("(%s,%s) \n", nomsPoints[i], nomsPoints[j]);
					}
				}
			}


			System.out.println("========================================");
			System.out.println("============= L'étape "+(nbPoints-2)+" ================");
			// Affichage des points créés
			System.out.println("Les points créés sont :");
			for (int i = 0; i < nbPoints; i++) {
				String nom = "v_" + (i + 1);
				int x = points[i][0];
				int y = points[i][1];
				System.out.printf("%s = (%d,%d)\n", nom, x, y);
			}

			System.out.println("========================================");
			// Saisie des indices des points entre lesquels l'utilisateur veut travailler
			System.out.println("Les point d'extrimité du point vk (indices)");
			System.out.print("Le point wp : ");
			int wp = scanner.nextInt() - 1; // ajuster l'indice pour correspondre au tableau
			System.out.print("Le point wq : ");
			int wq = scanner.nextInt() - 1; // ajuster l'indice pour correspondre au tableau

			// Accéder aux points correspondants dans le tableau et faire quelque chose avec eux
			int wpx = points[wp][0] , wpy = points[wp][1];
			int wqx = points[wq][0] , wqy = points[wq][1];
			System.out.printf("Introduction du point vk entre \n wp: %s (%d,%d) et wq: %s (%d,%d)\n\n"
					+ "", nomsPoints[wp],wpx, wpy,nomsPoints[wq],wqx,wqy);



			System.out.println("========================================");

			//=============================================================================
			// Création de nouveaux tableaux temporaires avec une taille augmentée de 1
			int[][] newPoints = new int[nbPoints+1][2];
			String[] newNomsPoints = new String[nbPoints+1];

			// Copie des éléments des tableaux originaux dans les tableaux temporaires
			for (int i = 0; i < nbPoints; i++) {
				newPoints[i] = points[i];
				newNomsPoints[i] = nomsPoints[i];
			}
			// updater wp et wq pour le calcule de vk
			wpx = points[wp][0] ; wpy = points[wp][1];
			wqx = points[wq][0] ; wqy = points[wq][1];


			// Décalage des points
			for (int i = 0; i < nbPoints; i++) {
				String nom = "v_" + (i + 1);
				int x = points[i][0];
				int y = points[i][1];
				if (x <= wpx) { // Les points à gauche de wp ne bougent pas

					System.out.printf(" %s = gauche : (%d,%d)\n", nom, x, y);
					continue;
				} 
				if ( x > wpx && x < wqx ) { // Les points entre wp et wq sont décalés de +1
					System.out.printf("%s milieu +1 : avant (%d,%d) ->", nom, x, y);
					x = x + 1;
					points[i][0] = x;
					// Ajout des points du milieu dans le tableau temporaire
			        pointsMilieu[countMilieu][0] = x;
			        pointsMilieu[countMilieu][1] = y;
			        countMilieu++;
					System.out.printf("Apres : (%d,%d)\n", x, y);
				} 
				else { // Les points après wq sont décalés de +2
					System.out.printf("%s droite +2 : avant (%d,%d) ->", nom, x, y);
					x = x + 2;
					points[i][0] = x;
					System.out.printf("Apres : (%d,%d)\n", x, y);
				}
			}
			
			
			
			// Calculer les coordonnées de vk en utilisant les coordonnées de wp et wq
			int vkx = (int) (0.5 * (wqx + wpx + wqy - wpy));
			int vky = (int) (0.5 * (wqx - wpx + wqy + wpy));

			newPoints[nbPoints][0] = vkx;
			newPoints[nbPoints][1] = vky;
			newNomsPoints[nbPoints] = "v_" + (nbPoints+1);

			// Mise à jour des tableaux originaux avec les tableaux temporaires
			points = newPoints;
			nomsPoints = newNomsPoints;
			nbPoints++; // Augmentation du nombre de points
			System.out.println("========================================");

			// Affichage des points créés
			System.out.println("Affichage final :");
			for (int i = 0; i < nbPoints; i++) {
				String nom = "v_" + (i + 1);
				int x = points[i][0];
				int y = points[i][1];
				System.out.printf("%s = (%d,%d)\n", nom, x, y);
			}


			// Augmenter la taille de la matrice d'adjacence
			int[][] newAdjMatrix = new int[nbPoints][nbPoints];
			for(int i=0; i<nbPoints-1; i++){
				for(int j=0; j<nbPoints-1; j++){
					newAdjMatrix[i][j] = adjMatrix[i][j];
				}
			}
			adjMatrix = newAdjMatrix;

			// Mettre à jour la matrice d'adjacence pour inclure les arêtes (vk, wp) et (vk, wq)
			adjMatrix[wp][nbPoints-1] = 1; // wp -> vk
			adjMatrix[nbPoints-1][wp] = 1; // vk -> wp
			adjMatrix[wq][nbPoints-1] = 1; // wq -> vk
			adjMatrix[nbPoints-1][wq] = 1; // vk -> wq


			System.out.println("**********************");
			// Afficher la matrice d'adjacence
			// Parcourir la matrice d'adjacence et afficher les arêtes correspondantes
			boolean[][] affiche = new boolean[nbPoints][nbPoints];

			for (int i = 0; i < nbPoints; i++) {
				for (int j = 0; j < nbPoints; j++) {
					if (adjMatrix[i][j] == 1 && !affiche[i][j] && !affiche[j][i]) {
						System.out.printf("(%s,%s) \n", nomsPoints[i], nomsPoints[j]);
						affiche[i][j] = true;
						affiche[j][i] = true;
					}
				}
			}

			//			//Verification
			//			System.out.println("**********************")			
			//			// Parcourir la matrice d'adjacence et afficher les arêtes correspondantes
			//			for (int i = 0; i < nbPoints; i++) {
			//				for (int j = 0; j < nbPoints; j++) {
			//					if (adjMatrix[i][j] == 1) {
			//						System.out.printf("(%s,%s) \n", nomsPoints[i], nomsPoints[j]);
			//					}
			//				}
			//			}


			System.out.print("\nAppuyer sur 1 pour arrêter :\n");
			stop = scanner.nextInt();
		} while(stop !=1);
		System.out.print("\nAu revoir!");

	}

} 